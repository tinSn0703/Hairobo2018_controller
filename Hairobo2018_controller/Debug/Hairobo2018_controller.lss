
Hairobo2018_controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000346  00800100  000034fe  00003592  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000034fe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001f0  00800446  00800446  000038d8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000038d8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003908  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007e0  00000000  00000000  00003948  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001c6c4  00000000  00000000  00004128  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000036fa  00000000  00000000  000207ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005071  00000000  00000000  00023ee6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001fb4  00000000  00000000  00028f58  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00009de2  00000000  00000000  0002af0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000c381  00000000  00000000  00034cee  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000830  00000000  00000000  0004106f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 c8 00 	jmp	0x190	; 0x190 <__ctors_end>
       4:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
       8:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
       c:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      10:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      14:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      18:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      1c:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      20:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      24:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      28:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      2c:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      30:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      34:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      38:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      3c:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      40:	0c 94 63 06 	jmp	0xcc6	; 0xcc6 <__vector_16>
      44:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      48:	0c 94 45 05 	jmp	0xa8a	; 0xa8a <__vector_18>
      4c:	0c 94 77 05 	jmp	0xaee	; 0xaee <__vector_19>
      50:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      54:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      58:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      5c:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      60:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      64:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__bad_interrupt>
      68:	cf 08       	sbc	r12, r15
      6a:	68 08       	sbc	r6, r8
      6c:	d3 08       	sbc	r13, r3
      6e:	6b 08       	sbc	r6, r11
      70:	6e 08       	sbc	r6, r14
      72:	71 08       	sbc	r7, r1
      74:	75 08       	sbc	r7, r5
      76:	78 08       	sbc	r7, r8
      78:	7b 08       	sbc	r7, r11
      7a:	7e 08       	sbc	r7, r14
      7c:	81 08       	sbc	r8, r1
      7e:	84 08       	sbc	r8, r4
      80:	87 08       	sbc	r8, r7
      82:	8a 08       	sbc	r8, r10
      84:	8d 08       	sbc	r8, r13
      86:	91 08       	sbc	r9, r1
      88:	94 08       	sbc	r9, r4
      8a:	97 08       	sbc	r9, r7
      8c:	d7 08       	sbc	r13, r7
      8e:	a5 08       	sbc	r10, r5
      90:	a8 08       	sbc	r10, r8
      92:	cd 08       	sbc	r12, r13
      94:	ab 08       	sbc	r10, r11
      96:	cd 08       	sbc	r12, r13
      98:	af 08       	sbc	r10, r15
      9a:	b2 08       	sbc	r11, r2
      9c:	b6 08       	sbc	r11, r6
      9e:	cd 08       	sbc	r12, r13
      a0:	cd 08       	sbc	r12, r13
      a2:	b9 08       	sbc	r11, r9
      a4:	bd 08       	sbc	r11, r13
      a6:	c0 08       	sbc	r12, r0
      a8:	c4 08       	sbc	r12, r4
      aa:	c7 08       	sbc	r12, r7
      ac:	cd 08       	sbc	r12, r13
      ae:	ca 08       	sbc	r12, r10

000000b0 <__trampolines_end>:
      b0:	0a 00       	.word	0x000a	; ????

000000b2 <_ZZN16ControllerCircit5WriteEvE3__c>:
      b2:	09 00                                               ..

000000b4 <_ZL11PS3_BUTTONS>:
      b4:	10 00 00 00 20 00 00 00 40 00 00 00 80 00 00 00     .... ...@.......
      c4:	01 00 00 00 08 00 00 00 02 00 00 00 04 00 00 00     ................
      d4:	00 01 00 00 00 02 00 00 00 04 00 00 00 08 00 00     ................
      e4:	00 10 00 00 00 20 00 00 00 40 00 00 00 80 00 00     ..... ...@......
      f4:	00 00 01 00 00 00 08 00 00 00 10 00                 ............

00000100 <_ZL8PS3_LEDS>:
     100:	00 01 02 04 08 09 0a 0c 0d 0e 0f                    ...........

0000010b <_ZL17PS3_REPORT_BUFFER>:
	...
     113:	00 00 ff 27 10 00 32 ff 27 10 00 32 ff 27 10 00     ...'..2.'..2.'..
     123:	32 ff 27 10 00 32 00 00 00 00 00 00 00 00 00 00     2.'..2..........
	...

0000013b <digital_pin_to_timer_PGM>:
     13b:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
     14b:	00 00 00 00                                         ....

0000014f <digital_pin_to_bit_mask_PGM>:
     14f:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
     15f:	04 08 10 20                                         ... 

00000163 <digital_pin_to_port_PGM>:
     163:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
     173:	03 03 03 03                                         ....

00000177 <port_to_output_PGM>:
     177:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000181 <port_to_mode_PGM>:
     181:	00 00 00 00 24 00 27 00 2a 00 00                    ....$.'.*..

0000018c <__ctors_start>:
     18c:	16 04       	cpc	r1, r6
     18e:	a7 05       	cpc	r26, r7

00000190 <__ctors_end>:
     190:	11 24       	eor	r1, r1
     192:	1f be       	out	0x3f, r1	; 63
     194:	cf ef       	ldi	r28, 0xFF	; 255
     196:	d8 e0       	ldi	r29, 0x08	; 8
     198:	de bf       	out	0x3e, r29	; 62
     19a:	cd bf       	out	0x3d, r28	; 61

0000019c <__do_copy_data>:
     19c:	14 e0       	ldi	r17, 0x04	; 4
     19e:	a0 e0       	ldi	r26, 0x00	; 0
     1a0:	b1 e0       	ldi	r27, 0x01	; 1
     1a2:	ee ef       	ldi	r30, 0xFE	; 254
     1a4:	f4 e3       	ldi	r31, 0x34	; 52
     1a6:	02 c0       	rjmp	.+4      	; 0x1ac <__do_copy_data+0x10>
     1a8:	05 90       	lpm	r0, Z+
     1aa:	0d 92       	st	X+, r0
     1ac:	a6 34       	cpi	r26, 0x46	; 70
     1ae:	b1 07       	cpc	r27, r17
     1b0:	d9 f7       	brne	.-10     	; 0x1a8 <__do_copy_data+0xc>

000001b2 <__do_clear_bss>:
     1b2:	26 e0       	ldi	r18, 0x06	; 6
     1b4:	a6 e4       	ldi	r26, 0x46	; 70
     1b6:	b4 e0       	ldi	r27, 0x04	; 4
     1b8:	01 c0       	rjmp	.+2      	; 0x1bc <.do_clear_bss_start>

000001ba <.do_clear_bss_loop>:
     1ba:	1d 92       	st	X+, r1

000001bc <.do_clear_bss_start>:
     1bc:	a6 33       	cpi	r26, 0x36	; 54
     1be:	b2 07       	cpc	r27, r18
     1c0:	e1 f7       	brne	.-8      	; 0x1ba <.do_clear_bss_loop>

000001c2 <__do_global_ctors>:
     1c2:	10 e0       	ldi	r17, 0x00	; 0
     1c4:	c8 ec       	ldi	r28, 0xC8	; 200
     1c6:	d0 e0       	ldi	r29, 0x00	; 0
     1c8:	04 c0       	rjmp	.+8      	; 0x1d2 <__do_global_ctors+0x10>
     1ca:	21 97       	sbiw	r28, 0x01	; 1
     1cc:	fe 01       	movw	r30, r28
     1ce:	0e 94 4f 19 	call	0x329e	; 0x329e <__tablejump2__>
     1d2:	c6 3c       	cpi	r28, 0xC6	; 198
     1d4:	d1 07       	cpc	r29, r17
     1d6:	c9 f7       	brne	.-14     	; 0x1ca <__do_global_ctors+0x8>
     1d8:	0e 94 d5 05 	call	0xbaa	; 0xbaa <main>
     1dc:	0c 94 7d 1a 	jmp	0x34fa	; 0x34fa <_exit>

000001e0 <__bad_interrupt>:
     1e0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001e4 <_ZN8SPIClass14endTransactionEv.part.1>:

//----------------------------------------------------------------------//

void ControllerCircit::Read()
{
	usb.Task();
     1e4:	9f b7       	in	r25, 0x3f	; 63
     1e6:	f8 94       	cli
     1e8:	20 91 2a 06 	lds	r18, 0x062A	; 0x80062a <_ZN8SPIClass13interruptModeE>
     1ec:	80 91 28 06 	lds	r24, 0x0628	; 0x800628 <_ZN8SPIClass13interruptSaveE>
     1f0:	21 30       	cpi	r18, 0x01	; 1
     1f2:	19 f4       	brne	.+6      	; 0x1fa <_ZN8SPIClass14endTransactionEv.part.1+0x16>
     1f4:	8d bb       	out	0x1d, r24	; 29
     1f6:	9f bf       	out	0x3f, r25	; 63
     1f8:	08 95       	ret
     1fa:	8f bf       	out	0x3f, r24	; 63
     1fc:	08 95       	ret

000001fe <_ZN8SPIClass16beginTransactionE11SPISettings>:
     1fe:	20 91 2a 06 	lds	r18, 0x062A	; 0x80062a <_ZN8SPIClass13interruptModeE>
     202:	22 23       	and	r18, r18
     204:	99 f0       	breq	.+38     	; 0x22c <_ZN8SPIClass16beginTransactionE11SPISettings+0x2e>
     206:	4f b7       	in	r20, 0x3f	; 63
     208:	f8 94       	cli
     20a:	20 91 2a 06 	lds	r18, 0x062A	; 0x80062a <_ZN8SPIClass13interruptModeE>
     20e:	21 30       	cpi	r18, 0x01	; 1
     210:	59 f4       	brne	.+22     	; 0x228 <_ZN8SPIClass16beginTransactionE11SPISettings+0x2a>
     212:	2d b3       	in	r18, 0x1d	; 29
     214:	20 93 28 06 	sts	0x0628, r18	; 0x800628 <_ZN8SPIClass13interruptSaveE>
     218:	3d b3       	in	r19, 0x1d	; 29
     21a:	20 91 29 06 	lds	r18, 0x0629	; 0x800629 <_ZN8SPIClass13interruptMaskE>
     21e:	20 95       	com	r18
     220:	23 23       	and	r18, r19
     222:	2d bb       	out	0x1d, r18	; 29
     224:	4f bf       	out	0x3f, r20	; 63
     226:	02 c0       	rjmp	.+4      	; 0x22c <_ZN8SPIClass16beginTransactionE11SPISettings+0x2e>
     228:	40 93 28 06 	sts	0x0628, r20	; 0x800628 <_ZN8SPIClass13interruptSaveE>
     22c:	8c bd       	out	0x2c, r24	; 44
     22e:	9d bd       	out	0x2d, r25	; 45
     230:	08 95       	ret

00000232 <_Z16PrintHexadecimallj>:
     232:	af 92       	push	r10
     234:	bf 92       	push	r11
     236:	cf 92       	push	r12
     238:	df 92       	push	r13
     23a:	ef 92       	push	r14
     23c:	ff 92       	push	r15
     23e:	0f 93       	push	r16
     240:	1f 93       	push	r17
     242:	cf 93       	push	r28
     244:	df 93       	push	r29
     246:	cd b7       	in	r28, 0x3d	; 61
     248:	de b7       	in	r29, 0x3e	; 62
     24a:	60 97       	sbiw	r28, 0x10	; 16
     24c:	0f b6       	in	r0, 0x3f	; 63
     24e:	f8 94       	cli
     250:	de bf       	out	0x3e, r29	; 62
     252:	0f be       	out	0x3f, r0	; 63
     254:	cd bf       	out	0x3d, r28	; 61
     256:	6b 01       	movw	r12, r22
     258:	7c 01       	movw	r14, r24
     25a:	8a 01       	movw	r16, r20
     25c:	80 e1       	ldi	r24, 0x10	; 16
     25e:	e6 e0       	ldi	r30, 0x06	; 6
     260:	f1 e0       	ldi	r31, 0x01	; 1
     262:	de 01       	movw	r26, r28
     264:	11 96       	adiw	r26, 0x01	; 1
     266:	01 90       	ld	r0, Z+
     268:	0d 92       	st	X+, r0
     26a:	8a 95       	dec	r24
     26c:	e1 f7       	brne	.-8      	; 0x266 <_Z16PrintHexadecimallj+0x34>
     26e:	ca 01       	movw	r24, r20
     270:	01 96       	adiw	r24, 0x01	; 1
     272:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <_Znaj>
     276:	5c 01       	movw	r10, r24
     278:	f7 fe       	sbrs	r15, 7
     27a:	0f c0       	rjmp	.+30     	; 0x29a <_Z16PrintHexadecimallj+0x68>
     27c:	f0 94       	com	r15
     27e:	e0 94       	com	r14
     280:	d0 94       	com	r13
     282:	c0 94       	com	r12
     284:	c1 1c       	adc	r12, r1
     286:	d1 1c       	adc	r13, r1
     288:	e1 1c       	adc	r14, r1
     28a:	f1 1c       	adc	r15, r1
     28c:	01 50       	subi	r16, 0x01	; 1
     28e:	11 09       	sbc	r17, r1
     290:	fc 01       	movw	r30, r24
     292:	e0 0f       	add	r30, r16
     294:	f1 1f       	adc	r31, r17
     296:	8d e2       	ldi	r24, 0x2D	; 45
     298:	80 83       	st	Z, r24
     29a:	f5 01       	movw	r30, r10
     29c:	e0 0f       	add	r30, r16
     29e:	f1 1f       	adc	r31, r17
     2a0:	9f 01       	movw	r18, r30
     2a2:	01 50       	subi	r16, 0x01	; 1
     2a4:	11 09       	sbc	r17, r1
     2a6:	17 fd       	sbrc	r17, 7
     2a8:	18 c0       	rjmp	.+48     	; 0x2da <_Z16PrintHexadecimallj+0xa8>
     2aa:	d7 01       	movw	r26, r14
     2ac:	c6 01       	movw	r24, r12
     2ae:	8f 70       	andi	r24, 0x0F	; 15
     2b0:	99 27       	eor	r25, r25
     2b2:	aa 27       	eor	r26, r26
     2b4:	bb 27       	eor	r27, r27
     2b6:	a1 e0       	ldi	r26, 0x01	; 1
     2b8:	b0 e0       	ldi	r27, 0x00	; 0
     2ba:	ac 0f       	add	r26, r28
     2bc:	bd 1f       	adc	r27, r29
     2be:	a8 0f       	add	r26, r24
     2c0:	b9 1f       	adc	r27, r25
     2c2:	8c 91       	ld	r24, X
     2c4:	d9 01       	movw	r26, r18
     2c6:	8e 93       	st	-X, r24
     2c8:	9d 01       	movw	r18, r26
     2ca:	84 e0       	ldi	r24, 0x04	; 4
     2cc:	f6 94       	lsr	r15
     2ce:	e7 94       	ror	r14
     2d0:	d7 94       	ror	r13
     2d2:	c7 94       	ror	r12
     2d4:	8a 95       	dec	r24
     2d6:	d1 f7       	brne	.-12     	; 0x2cc <_Z16PrintHexadecimallj+0x9a>
     2d8:	e4 cf       	rjmp	.-56     	; 0x2a2 <_Z16PrintHexadecimallj+0x70>
     2da:	10 82       	st	Z, r1
     2dc:	b5 01       	movw	r22, r10
     2de:	82 e8       	ldi	r24, 0x82	; 130
     2e0:	95 e0       	ldi	r25, 0x05	; 5
     2e2:	0e 94 4b 06 	call	0xc96	; 0xc96 <_ZN5Print5printEPKc>
     2e6:	c5 01       	movw	r24, r10
     2e8:	60 96       	adiw	r28, 0x10	; 16
     2ea:	0f b6       	in	r0, 0x3f	; 63
     2ec:	f8 94       	cli
     2ee:	de bf       	out	0x3e, r29	; 62
     2f0:	0f be       	out	0x3f, r0	; 63
     2f2:	cd bf       	out	0x3d, r28	; 61
     2f4:	df 91       	pop	r29
     2f6:	cf 91       	pop	r28
     2f8:	1f 91       	pop	r17
     2fa:	0f 91       	pop	r16
     2fc:	ff 90       	pop	r15
     2fe:	ef 90       	pop	r14
     300:	df 90       	pop	r13
     302:	cf 90       	pop	r12
     304:	bf 90       	pop	r11
     306:	af 90       	pop	r10
     308:	0c 94 e6 05 	jmp	0xbcc	; 0xbcc <_ZdlPv>

0000030c <_ZN16ControllerCircitC1Ev>:
     30c:	8f 92       	push	r8
     30e:	9f 92       	push	r9
     310:	af 92       	push	r10
     312:	cf 92       	push	r12
     314:	ef 92       	push	r14
     316:	0f 93       	push	r16
     318:	cf 93       	push	r28
     31a:	df 93       	push	r29
     31c:	ec 01       	movw	r28, r24
     31e:	4c 01       	movw	r8, r24
     320:	84 eb       	ldi	r24, 0xB4	; 180
     322:	88 0e       	add	r8, r24
     324:	91 1c       	adc	r9, r1
     326:	a1 2c       	mov	r10, r1
     328:	c1 2c       	mov	r12, r1
     32a:	e1 2c       	mov	r14, r1
     32c:	00 e0       	ldi	r16, 0x00	; 0
     32e:	20 e0       	ldi	r18, 0x00	; 0
     330:	40 e0       	ldi	r20, 0x00	; 0
     332:	b4 01       	movw	r22, r8
     334:	ce 01       	movw	r24, r28
     336:	0e 94 8f 0b 	call	0x171e	; 0x171e <_ZN6PS3USBC1EP3USBhhhhhh>
     33a:	68 e0       	ldi	r22, 0x08	; 8
     33c:	ce 01       	movw	r24, r28
     33e:	86 55       	subi	r24, 0x56	; 86
     340:	9f 4f       	sbci	r25, 0xFF	; 255
     342:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <_ZN7MCP_CANC1Eh>
     346:	c4 01       	movw	r24, r8
     348:	0e 94 75 10 	call	0x20ea	; 0x20ea <_ZN3USBC1Ev>
     34c:	fe 01       	movw	r30, r28
     34e:	e5 5d       	subi	r30, 0xD5	; 213
     350:	fe 4f       	sbci	r31, 0xFE	; 254
     352:	cd 5c       	subi	r28, 0xCD	; 205
     354:	de 4f       	sbci	r29, 0xFE	; 254
     356:	10 86       	std	Z+8, r1	; 0x08
     358:	11 92       	st	Z+, r1
     35a:	ec 17       	cp	r30, r28
     35c:	fd 07       	cpc	r31, r29
     35e:	d9 f7       	brne	.-10     	; 0x356 <_ZN16ControllerCircitC1Ev+0x4a>
     360:	df 91       	pop	r29
     362:	cf 91       	pop	r28
     364:	0f 91       	pop	r16
     366:	ef 90       	pop	r14
     368:	cf 90       	pop	r12
     36a:	af 90       	pop	r10
     36c:	9f 90       	pop	r9
     36e:	8f 90       	pop	r8
     370:	08 95       	ret

00000372 <_ZN16ControllerCircit7ConvertEv>:
}

//----------------------------------------------------------------------//

void ControllerCircit::Convert()
{
     372:	ff 92       	push	r15
     374:	0f 93       	push	r16
     376:	1f 93       	push	r17
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
     37c:	8c 01       	movw	r16, r24
	for (int i = 0; i < 4; i++)
	{
		before_data.array[i] = send_data.array[i];
     37e:	fc 01       	movw	r30, r24
     380:	ed 5c       	subi	r30, 0xCD	; 205
     382:	fe 4f       	sbci	r31, 0xFE	; 254
     384:	ec 01       	movw	r28, r24
     386:	c5 5d       	subi	r28, 0xD5	; 213
     388:	de 4f       	sbci	r29, 0xFE	; 254
     38a:	88 81       	ld	r24, Y
     38c:	80 83       	st	Z, r24
     38e:	31 96       	adiw	r30, 0x01	; 1
     390:	d8 01       	movw	r26, r16
     392:	a4 5d       	subi	r26, 0xD4	; 212
     394:	be 4f       	sbci	r27, 0xFE	; 254
     396:	8c 91       	ld	r24, X
     398:	80 83       	st	Z, r24
     39a:	31 96       	adiw	r30, 0x01	; 1
     39c:	11 96       	adiw	r26, 0x01	; 1
     39e:	8c 91       	ld	r24, X
     3a0:	80 83       	st	Z, r24
     3a2:	31 96       	adiw	r30, 0x01	; 1
     3a4:	11 96       	adiw	r26, 0x01	; 1
     3a6:	8c 91       	ld	r24, X
     3a8:	80 83       	st	Z, r24
	}
	
	send_data.bit.stick_left_x = controller.getAnalogHat(LeftHatX) / 17;
     3aa:	60 e0       	ldi	r22, 0x00	; 0
     3ac:	c8 01       	movw	r24, r16
     3ae:	0e 94 0f 0c 	call	0x181e	; 0x181e <_ZN6PS3USB12getAnalogHatE13AnalogHatEnum>
     3b2:	91 e1       	ldi	r25, 0x11	; 17
     3b4:	f9 2e       	mov	r15, r25
     3b6:	6f 2d       	mov	r22, r15
     3b8:	0e 94 21 19 	call	0x3242	; 0x3242 <__udivmodqi4>
     3bc:	8f 70       	andi	r24, 0x0F	; 15
     3be:	98 81       	ld	r25, Y
     3c0:	90 7f       	andi	r25, 0xF0	; 240
     3c2:	89 2b       	or	r24, r25
     3c4:	88 83       	st	Y, r24
	send_data.bit.stick_left_y = controller.getAnalogHat(LeftHatY) / 17;
     3c6:	61 e0       	ldi	r22, 0x01	; 1
     3c8:	c8 01       	movw	r24, r16
     3ca:	0e 94 0f 0c 	call	0x181e	; 0x181e <_ZN6PS3USB12getAnalogHatE13AnalogHatEnum>
     3ce:	6f 2d       	mov	r22, r15
     3d0:	0e 94 21 19 	call	0x3242	; 0x3242 <__udivmodqi4>
     3d4:	82 95       	swap	r24
     3d6:	80 7f       	andi	r24, 0xF0	; 240
     3d8:	98 81       	ld	r25, Y
     3da:	9f 70       	andi	r25, 0x0F	; 15
     3dc:	89 2b       	or	r24, r25
     3de:	88 83       	st	Y, r24
	send_data.bit.stick_right_x = controller.getAnalogHat(RightHatX) / 17;
     3e0:	62 e0       	ldi	r22, 0x02	; 2
     3e2:	c8 01       	movw	r24, r16
     3e4:	0e 94 0f 0c 	call	0x181e	; 0x181e <_ZN6PS3USB12getAnalogHatE13AnalogHatEnum>
     3e8:	6f 2d       	mov	r22, r15
     3ea:	0e 94 21 19 	call	0x3242	; 0x3242 <__udivmodqi4>
     3ee:	8f 70       	andi	r24, 0x0F	; 15
     3f0:	99 81       	ldd	r25, Y+1	; 0x01
     3f2:	90 7f       	andi	r25, 0xF0	; 240
     3f4:	89 2b       	or	r24, r25
     3f6:	89 83       	std	Y+1, r24	; 0x01
	send_data.bit.stick_right_y = controller.getAnalogHat(RightHatY) / 17;
     3f8:	63 e0       	ldi	r22, 0x03	; 3
     3fa:	c8 01       	movw	r24, r16
     3fc:	0e 94 0f 0c 	call	0x181e	; 0x181e <_ZN6PS3USB12getAnalogHatE13AnalogHatEnum>
     400:	6f 2d       	mov	r22, r15
     402:	0e 94 21 19 	call	0x3242	; 0x3242 <__udivmodqi4>
     406:	82 95       	swap	r24
     408:	80 7f       	andi	r24, 0xF0	; 240
     40a:	99 81       	ldd	r25, Y+1	; 0x01
     40c:	9f 70       	andi	r25, 0x0F	; 15
     40e:	89 2b       	or	r24, r25
     410:	89 83       	std	Y+1, r24	; 0x01
	
	send_data.bit.button_L1 = controller.getButtonPress(L1) ? 1 : 0;
     412:	6a e0       	ldi	r22, 0x0A	; 10
     414:	c8 01       	movw	r24, r16
     416:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     41a:	9a 81       	ldd	r25, Y+2	; 0x02
     41c:	80 fb       	bst	r24, 0
     41e:	90 f9       	bld	r25, 0
     420:	9a 83       	std	Y+2, r25	; 0x02
	send_data.bit.button_L2 = controller.getButtonPress(L2) ? 1 : 0;
     422:	68 e0       	ldi	r22, 0x08	; 8
     424:	c8 01       	movw	r24, r16
     426:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     42a:	9a 81       	ldd	r25, Y+2	; 0x02
     42c:	80 fb       	bst	r24, 0
     42e:	91 f9       	bld	r25, 1
     430:	9a 83       	std	Y+2, r25	; 0x02
	send_data.bit.button_L3 = controller.getButtonPress(L3) ? 1 : 0;
     432:	66 e0       	ldi	r22, 0x06	; 6
     434:	c8 01       	movw	r24, r16
     436:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     43a:	9a 81       	ldd	r25, Y+2	; 0x02
     43c:	80 fb       	bst	r24, 0
     43e:	92 f9       	bld	r25, 2
     440:	9a 83       	std	Y+2, r25	; 0x02
	
	send_data.bit.button_R1 = controller.getButtonPress(R1) ? 1 : 0;
     442:	6b e0       	ldi	r22, 0x0B	; 11
     444:	c8 01       	movw	r24, r16
     446:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     44a:	9a 81       	ldd	r25, Y+2	; 0x02
     44c:	80 fb       	bst	r24, 0
     44e:	93 f9       	bld	r25, 3
     450:	9a 83       	std	Y+2, r25	; 0x02
	send_data.bit.button_R2 = controller.getButtonPress(R2) ? 1 : 0;
     452:	69 e0       	ldi	r22, 0x09	; 9
     454:	c8 01       	movw	r24, r16
     456:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     45a:	9a 81       	ldd	r25, Y+2	; 0x02
     45c:	80 fb       	bst	r24, 0
     45e:	94 f9       	bld	r25, 4
     460:	9a 83       	std	Y+2, r25	; 0x02
	send_data.bit.button_R3 = controller.getButtonPress(R3) ? 1 : 0;
     462:	67 e0       	ldi	r22, 0x07	; 7
     464:	c8 01       	movw	r24, r16
     466:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     46a:	9a 81       	ldd	r25, Y+2	; 0x02
     46c:	80 fb       	bst	r24, 0
     46e:	95 f9       	bld	r25, 5
     470:	9a 83       	std	Y+2, r25	; 0x02
	
	send_data.bit.button_circle		= controller.getButtonPress(CIRCLE) ? 1 : 0;
     472:	6d e0       	ldi	r22, 0x0D	; 13
     474:	c8 01       	movw	r24, r16
     476:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     47a:	9b 81       	ldd	r25, Y+3	; 0x03
     47c:	80 fb       	bst	r24, 0
     47e:	90 f9       	bld	r25, 0
     480:	9b 83       	std	Y+3, r25	; 0x03
	send_data.bit.button_square		= controller.getButtonPress(SQUARE) ? 1 : 0;
     482:	6f e0       	ldi	r22, 0x0F	; 15
     484:	c8 01       	movw	r24, r16
     486:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     48a:	9b 81       	ldd	r25, Y+3	; 0x03
     48c:	80 fb       	bst	r24, 0
     48e:	93 f9       	bld	r25, 3
     490:	9b 83       	std	Y+3, r25	; 0x03
	send_data.bit.button_cross		= controller.getButtonPress(CROSS) ? 1 : 0;
     492:	6e e0       	ldi	r22, 0x0E	; 14
     494:	c8 01       	movw	r24, r16
     496:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     49a:	9b 81       	ldd	r25, Y+3	; 0x03
     49c:	80 fb       	bst	r24, 0
     49e:	92 f9       	bld	r25, 2
     4a0:	9b 83       	std	Y+3, r25	; 0x03
	send_data.bit.button_triangle	= controller.getButtonPress(TRIANGLE) ? 1 : 0;
     4a2:	6c e0       	ldi	r22, 0x0C	; 12
     4a4:	c8 01       	movw	r24, r16
     4a6:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     4aa:	9b 81       	ldd	r25, Y+3	; 0x03
     4ac:	80 fb       	bst	r24, 0
     4ae:	91 f9       	bld	r25, 1
     4b0:	9b 83       	std	Y+3, r25	; 0x03
	
	send_data.bit.button_select	= controller.getButtonPress(SELECT) ? 1 : 0;
     4b2:	64 e0       	ldi	r22, 0x04	; 4
     4b4:	c8 01       	movw	r24, r16
     4b6:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     4ba:	9a 81       	ldd	r25, Y+2	; 0x02
     4bc:	80 fb       	bst	r24, 0
     4be:	97 f9       	bld	r25, 7
     4c0:	9a 83       	std	Y+2, r25	; 0x02
	send_data.bit.button_start	= controller.getButtonPress(START) ? 1 : 0;
     4c2:	65 e0       	ldi	r22, 0x05	; 5
     4c4:	c8 01       	movw	r24, r16
     4c6:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     4ca:	9a 81       	ldd	r25, Y+2	; 0x02
     4cc:	80 fb       	bst	r24, 0
     4ce:	96 f9       	bld	r25, 6
     4d0:	9a 83       	std	Y+2, r25	; 0x02
	
	send_data.bit.cross_left	= controller.getButtonPress(LEFT) ? 1 : 0;
     4d2:	63 e0       	ldi	r22, 0x03	; 3
     4d4:	c8 01       	movw	r24, r16
     4d6:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     4da:	9b 81       	ldd	r25, Y+3	; 0x03
     4dc:	80 fb       	bst	r24, 0
     4de:	94 f9       	bld	r25, 4
     4e0:	9b 83       	std	Y+3, r25	; 0x03
	send_data.bit.cross_right	= controller.getButtonPress(RIGHT) ? 1 : 0;
     4e2:	61 e0       	ldi	r22, 0x01	; 1
     4e4:	c8 01       	movw	r24, r16
     4e6:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     4ea:	9b 81       	ldd	r25, Y+3	; 0x03
     4ec:	80 fb       	bst	r24, 0
     4ee:	96 f9       	bld	r25, 6
     4f0:	9b 83       	std	Y+3, r25	; 0x03
	send_data.bit.cross_over	= controller.getButtonPress(UP) ? 1 : 0;
     4f2:	60 e0       	ldi	r22, 0x00	; 0
     4f4:	c8 01       	movw	r24, r16
     4f6:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     4fa:	9b 81       	ldd	r25, Y+3	; 0x03
     4fc:	80 fb       	bst	r24, 0
     4fe:	95 f9       	bld	r25, 5
     500:	9b 83       	std	Y+3, r25	; 0x03
	send_data.bit.cross_under	= controller.getButtonPress(DOWN) ? 1 : 0;
     502:	62 e0       	ldi	r22, 0x02	; 2
     504:	c8 01       	movw	r24, r16
     506:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>
     50a:	9b 81       	ldd	r25, Y+3	; 0x03
     50c:	80 fb       	bst	r24, 0
     50e:	97 f9       	bld	r25, 7
     510:	9b 83       	std	Y+3, r25	; 0x03
}
     512:	df 91       	pop	r29
     514:	cf 91       	pop	r28
     516:	1f 91       	pop	r17
     518:	0f 91       	pop	r16
     51a:	ff 90       	pop	r15
     51c:	08 95       	ret

0000051e <_ZN16ControllerCircit5WriteEv>:

//----------------------------------------------------------------------//

void ControllerCircit::Write()
{
     51e:	af 92       	push	r10
     520:	bf 92       	push	r11
     522:	cf 92       	push	r12
     524:	ef 92       	push	r14
     526:	ff 92       	push	r15
     528:	0f 93       	push	r16
     52a:	1f 93       	push	r17
     52c:	cf 93       	push	r28
     52e:	df 93       	push	r29
     530:	5c 01       	movw	r10, r24
	transfer.sendMsgBuf(0x00, 0, SEND_DATA_LENGTH, send_data.array);
     532:	ec 01       	movw	r28, r24
     534:	c5 5d       	subi	r28, 0xD5	; 213
     536:	de 4f       	sbci	r29, 0xFE	; 254
     538:	cc 24       	eor	r12, r12
     53a:	c3 94       	inc	r12
     53c:	7e 01       	movw	r14, r28
     53e:	08 e0       	ldi	r16, 0x08	; 8
     540:	20 e0       	ldi	r18, 0x00	; 0
     542:	40 e0       	ldi	r20, 0x00	; 0
     544:	50 e0       	ldi	r21, 0x00	; 0
     546:	ba 01       	movw	r22, r20
     548:	86 55       	subi	r24, 0x56	; 86
     54a:	9f 4f       	sbci	r25, 0xFF	; 255
     54c:	0e 94 10 0b 	call	0x1620	; 0x1620 <_ZN7MCP_CAN10sendMsgBufEmhhPKhb>
     550:	85 01       	movw	r16, r10
     552:	01 5d       	subi	r16, 0xD1	; 209
     554:	1e 4f       	sbci	r17, 0xFE	; 254
     556:	ce 01       	movw	r24, r28
     558:	fc 01       	movw	r30, r24
	
	for (int i = 0; i < 4; i++)
	{
		if (before_data.array[i] != send_data.array[i])
     55a:	30 85       	ldd	r19, Z+8	; 0x08
     55c:	01 96       	adiw	r24, 0x01	; 1
     55e:	20 81       	ld	r18, Z
     560:	32 17       	cp	r19, r18
     562:	01 f1       	breq	.+64     	; 0x5a4 <_ZN16ControllerCircit5WriteEv+0x86>
		{
			for (int i = 0; i < 4; i++)
			{
				PrintHexadecimal(send_data.array[i], 2);
     564:	69 91       	ld	r22, Y+
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	80 e0       	ldi	r24, 0x00	; 0
     56a:	90 e0       	ldi	r25, 0x00	; 0
     56c:	42 e0       	ldi	r20, 0x02	; 2
     56e:	50 e0       	ldi	r21, 0x00	; 0
     570:	0e 94 19 01 	call	0x232	; 0x232 <_Z16PrintHexadecimallj>
				Serial.print(F("\t"));
     574:	62 eb       	ldi	r22, 0xB2	; 178
     576:	70 e0       	ldi	r23, 0x00	; 0
     578:	82 e8       	ldi	r24, 0x82	; 130
     57a:	95 e0       	ldi	r25, 0x05	; 5
     57c:	0e 94 27 06 	call	0xc4e	; 0xc4e <_ZN5Print5printEPK19__FlashStringHelper>
	
	for (int i = 0; i < 4; i++)
	{
		if (before_data.array[i] != send_data.array[i])
		{
			for (int i = 0; i < 4; i++)
     580:	c0 17       	cp	r28, r16
     582:	d1 07       	cpc	r29, r17
     584:	79 f7       	brne	.-34     	; 0x564 <_ZN16ControllerCircit5WriteEv+0x46>
			{
				PrintHexadecimal(send_data.array[i], 2);
				Serial.print(F("\t"));
			}
			
			Serial.print(F("\n"));
     586:	60 eb       	ldi	r22, 0xB0	; 176
     588:	70 e0       	ldi	r23, 0x00	; 0
     58a:	82 e8       	ldi	r24, 0x82	; 130
     58c:	95 e0       	ldi	r25, 0x05	; 5
			
			break;
		}
	}
}
     58e:	df 91       	pop	r29
     590:	cf 91       	pop	r28
     592:	1f 91       	pop	r17
     594:	0f 91       	pop	r16
     596:	ff 90       	pop	r15
     598:	ef 90       	pop	r14
     59a:	cf 90       	pop	r12
     59c:	bf 90       	pop	r11
     59e:	af 90       	pop	r10
			{
				PrintHexadecimal(send_data.array[i], 2);
				Serial.print(F("\t"));
			}
			
			Serial.print(F("\n"));
     5a0:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <_ZN5Print5printEPK19__FlashStringHelper>

void ControllerCircit::Write()
{
	transfer.sendMsgBuf(0x00, 0, SEND_DATA_LENGTH, send_data.array);
	
	for (int i = 0; i < 4; i++)
     5a4:	80 17       	cp	r24, r16
     5a6:	91 07       	cpc	r25, r17
     5a8:	b9 f6       	brne	.-82     	; 0x558 <_ZN16ControllerCircit5WriteEv+0x3a>
			Serial.print(F("\n"));
			
			break;
		}
	}
}
     5aa:	df 91       	pop	r29
     5ac:	cf 91       	pop	r28
     5ae:	1f 91       	pop	r17
     5b0:	0f 91       	pop	r16
     5b2:	ff 90       	pop	r15
     5b4:	ef 90       	pop	r14
     5b6:	cf 90       	pop	r12
     5b8:	bf 90       	pop	r11
     5ba:	af 90       	pop	r10
     5bc:	08 95       	ret

000005be <loop>:

//----------------------------------------------------------------------//

void ControllerCircit::Read()
{
	usb.Task();
     5be:	8b ef       	ldi	r24, 0xFB	; 251
     5c0:	94 e0       	ldi	r25, 0x04	; 4
     5c2:	0e 94 8f 17 	call	0x2f1e	; 0x2f1e <_ZN3USB4TaskEv>

void loop()
{
	circit.Read();
	
	circit.Convert();
     5c6:	87 e4       	ldi	r24, 0x47	; 71
     5c8:	94 e0       	ldi	r25, 0x04	; 4
     5ca:	0e 94 b9 01 	call	0x372	; 0x372 <_ZN16ControllerCircit7ConvertEv>
	
	circit.Write();
     5ce:	87 e4       	ldi	r24, 0x47	; 71
     5d0:	94 e0       	ldi	r25, 0x04	; 4
     5d2:	0c 94 8f 02 	jmp	0x51e	; 0x51e <_ZN16ControllerCircit5WriteEv>

000005d6 <_ZN4TPinI5PortbLh2EE3SetEv>:
#ifdef USE_PORTA

MAKE_PORT(PORTA, DDRA, PINA, Porta, 'A')
#endif
#ifdef USE_PORTB
MAKE_PORT(PORTB, DDRB, PINB, Portb, 'B')
     5d6:	2a 9a       	sbi	0x05, 2	; 5
     5d8:	08 95       	ret

000005da <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.3>:
        return;
}

/* single host register read    */
template< typename SPI_SS, typename INTR >
uint8_t MAX3421e< SPI_SS, INTR >::regRd(uint8_t reg) {
     5da:	cf 93       	push	r28
     5dc:	c8 2f       	mov	r28, r24
        XMEM_ACQUIRE_SPI();
#if defined(SPI_HAS_TRANSACTION)
        USB_SPI.beginTransaction(SPISettings(26000000, MSBFIRST, SPI_MODE0)); // The MAX3421E can handle up to 26MHz, use MSB First and SPI mode 0
     5de:	80 e5       	ldi	r24, 0x50	; 80
     5e0:	91 e0       	ldi	r25, 0x01	; 1
     5e2:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
     5e6:	2a 98       	cbi	0x05, 2	; 5
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
     5e8:	ce bd       	out	0x2e, r28	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
     5ea:	00 00       	nop
    while (!(SPSR & _BV(SPIF))) ; // wait
     5ec:	0d b4       	in	r0, 0x2d	; 45
     5ee:	07 fe       	sbrs	r0, 7
     5f0:	fd cf       	rjmp	.-6      	; 0x5ec <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.3+0x12>
    return SPDR;
     5f2:	8e b5       	in	r24, 0x2e	; 46
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
     5f4:	1e bc       	out	0x2e, r1	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
     5f6:	00 00       	nop
    while (!(SPSR & _BV(SPIF))) ; // wait
     5f8:	0d b4       	in	r0, 0x2d	; 45
     5fa:	07 fe       	sbrs	r0, 7
     5fc:	fd cf       	rjmp	.-6      	; 0x5f8 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.3+0x1e>
    return SPDR;
     5fe:	ce b5       	in	r28, 0x2e	; 46
        HAL_SPI_Receive(&SPI_Handle, &rv, 1, HAL_MAX_DELAY);
        SPI_SS::Set();
#elif !defined(SPDR) || defined(SPI_HAS_TRANSACTION)
        USB_SPI.transfer(reg);
        uint8_t rv = USB_SPI.transfer(0); // Send empty byte
        SPI_SS::Set();
     600:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <_ZN4TPinI5PortbLh2EE3SetEv>
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 0;
    #endif

    if (interruptMode > 0) {
     604:	80 91 2a 06 	lds	r24, 0x062A	; 0x80062a <_ZN8SPIClass13interruptModeE>
     608:	81 11       	cpse	r24, r1
     60a:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <_ZN8SPIClass14endTransactionEv.part.1>
#if defined(SPI_HAS_TRANSACTION)
        USB_SPI.endTransaction();
#endif
        XMEM_RELEASE_SPI();
        return (rv);
}
     60e:	8c 2f       	mov	r24, r28
     610:	cf 91       	pop	r28
     612:	08 95       	ret

00000614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>:
#endif
};

/* write single byte into MAX3421 register */
template< typename SPI_SS, typename INTR >
void MAX3421e< SPI_SS, INTR >::regWr(uint8_t reg, uint8_t data) {
     614:	cf 93       	push	r28
     616:	df 93       	push	r29
     618:	c8 2f       	mov	r28, r24
     61a:	d6 2f       	mov	r29, r22
        XMEM_ACQUIRE_SPI();
#if defined(SPI_HAS_TRANSACTION)
        USB_SPI.beginTransaction(SPISettings(26000000, MSBFIRST, SPI_MODE0)); // The MAX3421E can handle up to 26MHz, use MSB First and SPI mode 0
     61c:	80 e5       	ldi	r24, 0x50	; 80
     61e:	91 e0       	ldi	r25, 0x01	; 1
     620:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
     624:	2a 98       	cbi	0x05, 2	; 5
        c[0] = reg | 0x02;
        c[1] = data;
        spi4teensy3::send(c, 2);
#elif defined(SPI_HAS_TRANSACTION) && !defined(ESP8266) && !defined(ESP32)
        uint8_t c[2];
        c[0] = reg | 0x02;
     626:	c2 60       	ori	r28, 0x02	; 2
    return out.val;
  }
  inline static void transfer(void *buf, size_t count) {
    if (count == 0) return;
    uint8_t *p = (uint8_t *)buf;
    SPDR = *p;
     628:	ce bd       	out	0x2e, r28	; 46
    while (--count > 0) {
      uint8_t out = *(p + 1);
      while (!(SPSR & _BV(SPIF))) ;
     62a:	0d b4       	in	r0, 0x2d	; 45
     62c:	07 fe       	sbrs	r0, 7
     62e:	fd cf       	rjmp	.-6      	; 0x62a <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4+0x16>
      uint8_t in = SPDR;
     630:	8e b5       	in	r24, 0x2e	; 46
      SPDR = out;
     632:	de bd       	out	0x2e, r29	; 46
      *p++ = in;
    }
    while (!(SPSR & _BV(SPIF))) ;
     634:	0d b4       	in	r0, 0x2d	; 45
     636:	07 fe       	sbrs	r0, 7
     638:	fd cf       	rjmp	.-6      	; 0x634 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4+0x20>
    *p = SPDR;
     63a:	8e b5       	in	r24, 0x2e	; 46
        while(!(SPSR & (1 << SPIF)));
        SPDR = data;
        while(!(SPSR & (1 << SPIF)));
#endif

        SPI_SS::Set();
     63c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <_ZN4TPinI5PortbLh2EE3SetEv>
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 0;
    #endif

    if (interruptMode > 0) {
     640:	80 91 2a 06 	lds	r24, 0x062A	; 0x80062a <_ZN8SPIClass13interruptModeE>
     644:	88 23       	and	r24, r24
     646:	21 f0       	breq	.+8      	; 0x650 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4+0x3c>
#if defined(SPI_HAS_TRANSACTION)
        USB_SPI.endTransaction();
#endif
        XMEM_RELEASE_SPI();
        return;
};
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	0c 94 f2 00 	jmp	0x1e4	; 0x1e4 <_ZN8SPIClass14endTransactionEv.part.1>
     650:	df 91       	pop	r29
     652:	cf 91       	pop	r28
     654:	08 95       	ret

00000656 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv>:

/* probe bus to determine device presence and speed and switch host to this speed */
template< typename SPI_SS, typename INTR >
void MAX3421e< SPI_SS, INTR >::busprobe() {
        uint8_t bus_sample;
        bus_sample = regRd(rHRSL); //Get J,K status
     656:	88 ef       	ldi	r24, 0xF8	; 248
     658:	0e 94 ed 02 	call	0x5da	; 0x5da <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.3>
        bus_sample &= (bmJSTATUS | bmKSTATUS); //zero the rest of the byte
        switch(bus_sample) { //start full-speed or low-speed host
     65c:	80 7c       	andi	r24, 0xC0	; 192
     65e:	80 34       	cpi	r24, 0x40	; 64
     660:	a1 f0       	breq	.+40     	; 0x68a <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv+0x34>
     662:	18 f4       	brcc	.+6      	; 0x66a <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv+0x14>
     664:	88 23       	and	r24, r24
     666:	01 f1       	breq	.+64     	; 0x6a8 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv+0x52>
     668:	08 95       	ret
     66a:	80 38       	cpi	r24, 0x80	; 128
     66c:	19 f0       	breq	.+6      	; 0x674 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv+0x1e>
     66e:	80 3c       	cpi	r24, 0xC0	; 192
     670:	b9 f0       	breq	.+46     	; 0x6a0 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv+0x4a>
     672:	08 95       	ret
                case( bmJSTATUS):
                        if((regRd(rMODE) & bmLOWSPEED) == 0) {
     674:	88 ed       	ldi	r24, 0xD8	; 216
     676:	0e 94 ed 02 	call	0x5da	; 0x5da <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.3>
     67a:	81 fd       	sbrc	r24, 1
     67c:	0b c0       	rjmp	.+22     	; 0x694 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv+0x3e>
                                regWr(rMODE, MODE_FS_HOST); //start full-speed host
     67e:	69 ec       	ldi	r22, 0xC9	; 201
     680:	88 ed       	ldi	r24, 0xD8	; 216
     682:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>
                                vbusState = FSHOST;
     686:	82 e0       	ldi	r24, 0x02	; 2
     688:	0c c0       	rjmp	.+24     	; 0x6a2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv+0x4c>
                                regWr(rMODE, MODE_LS_HOST); //start low-speed host
                                vbusState = LSHOST;
                        }
                        break;
                case( bmKSTATUS):
                        if((regRd(rMODE) & bmLOWSPEED) == 0) {
     68a:	88 ed       	ldi	r24, 0xD8	; 216
     68c:	0e 94 ed 02 	call	0x5da	; 0x5da <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.3>
     690:	81 fd       	sbrc	r24, 1
     692:	f5 cf       	rjmp	.-22     	; 0x67e <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv+0x28>
                case( bmJSTATUS):
                        if((regRd(rMODE) & bmLOWSPEED) == 0) {
                                regWr(rMODE, MODE_FS_HOST); //start full-speed host
                                vbusState = FSHOST;
                        } else {
                                regWr(rMODE, MODE_LS_HOST); //start low-speed host
     694:	6b ec       	ldi	r22, 0xCB	; 203
     696:	88 ed       	ldi	r24, 0xD8	; 216
     698:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>
                                vbusState = LSHOST;
     69c:	83 e0       	ldi	r24, 0x03	; 3
     69e:	01 c0       	rjmp	.+2      	; 0x6a2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv+0x4c>
                                regWr(rMODE, MODE_FS_HOST); //start full-speed host
                                vbusState = FSHOST;
                        }
                        break;
                case( bmSE1): //illegal state
                        vbusState = SE1;
     6a0:	81 e0       	ldi	r24, 0x01	; 1
     6a2:	80 93 46 04 	sts	0x0446, r24	; 0x800446 <__data_end>
                        break;
     6a6:	08 95       	ret
                case( bmSE0): //disconnected state
                        regWr(rMODE, bmDPPULLDN | bmDMPULLDN | bmHOST | bmSEPIRQ);
     6a8:	61 ed       	ldi	r22, 0xD1	; 209
     6aa:	88 ed       	ldi	r24, 0xD8	; 216
     6ac:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>
                        vbusState = SE0;
     6b0:	10 92 46 04 	sts	0x0446, r1	; 0x800446 <__data_end>
     6b4:	08 95       	ret

000006b6 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE4InitEv>:
        return ( i);
}

/* initialize MAX3421E. Set Host mode, pullups, and stuff. Returns 0 if success, -1 if not */
template< typename SPI_SS, typename INTR >
int8_t MAX3421e< SPI_SS, INTR >::Init() {
     6b6:	0f 93       	push	r16
     6b8:	1f 93       	push	r17
     6ba:	cf 93       	push	r28
     6bc:	df 93       	push	r29
     6be:	8c 01       	movw	r16, r24
     6c0:	22 9a       	sbi	0x04, 2	; 4
        // Moved here.
        // you really should not init hardware in the constructor when it involves locks.
        // Also avoids the vbus flicker issue confusing some devices.
        /* pin and peripheral setup */
        SPI_SS::SetDirWrite();
        SPI_SS::Set();
     6c2:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <_ZN4TPinI5PortbLh2EE3SetEv>
                SPI_SS::SetDirWrite();
                SPI_SS::Set();
        }
#elif defined(SPI_HAS_TRANSACTION)
        static void init() {
                USB_SPI.begin(); // The SPI library with transaction will take care of setting up the pins - settings is set in beginTransaction()
     6c6:	0e 94 23 0b 	call	0x1646	; 0x1646 <_ZN8SPIClass5beginEv>
     6ca:	22 9a       	sbi	0x04, 2	; 4
                SPI_SS::SetDirWrite();
                SPI_SS::Set();
     6cc:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <_ZN4TPinI5PortbLh2EE3SetEv>
     6d0:	21 98       	cbi	0x04, 1	; 4
        spi::init();
        INTR::SetDirRead();
        XMEM_RELEASE_SPI();
        /* MAX3421E - full-duplex SPI, level interrupt */
        // GPX pin on. Moved here, otherwise we flicker the vbus.
        regWr(rPINCTL, (bmFDUPSPI | bmINTLEVEL));
     6d2:	68 e1       	ldi	r22, 0x18	; 24
     6d4:	88 e8       	ldi	r24, 0x88	; 136
     6d6:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>
/* reset MAX3421E. Returns number of cycles it took for PLL to stabilize after reset
  or zero if PLL haven't stabilized in 65535 cycles */
template< typename SPI_SS, typename INTR >
uint16_t MAX3421e< SPI_SS, INTR >::reset() {
        uint16_t i = 0;
        regWr(rUSBCTL, bmCHIPRES);
     6da:	60 e2       	ldi	r22, 0x20	; 32
     6dc:	88 e7       	ldi	r24, 0x78	; 120
     6de:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>
        regWr(rUSBCTL, 0x00);
     6e2:	60 e0       	ldi	r22, 0x00	; 0
     6e4:	88 e7       	ldi	r24, 0x78	; 120
     6e6:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>
     6ea:	c0 e0       	ldi	r28, 0x00	; 0
     6ec:	d0 e0       	ldi	r29, 0x00	; 0
        while(++i) {
                if((regRd(rUSBIRQ) & bmOSCOKIRQ)) {
     6ee:	88 e6       	ldi	r24, 0x68	; 104
     6f0:	0e 94 ed 02 	call	0x5da	; 0x5da <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.3>
     6f4:	21 96       	adiw	r28, 0x01	; 1
     6f6:	80 fd       	sbrc	r24, 0
     6f8:	06 c0       	rjmp	.+12     	; 0x706 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE4InitEv+0x50>
template< typename SPI_SS, typename INTR >
uint16_t MAX3421e< SPI_SS, INTR >::reset() {
        uint16_t i = 0;
        regWr(rUSBCTL, bmCHIPRES);
        regWr(rUSBCTL, 0x00);
        while(++i) {
     6fa:	cf 3f       	cpi	r28, 0xFF	; 255
     6fc:	8f ef       	ldi	r24, 0xFF	; 255
     6fe:	d8 07       	cpc	r29, r24
     700:	b1 f7       	brne	.-20     	; 0x6ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE4InitEv+0x38>
        /* MAX3421E - full-duplex SPI, level interrupt */
        // GPX pin on. Moved here, otherwise we flicker the vbus.
        regWr(rPINCTL, (bmFDUPSPI | bmINTLEVEL));

        if(reset() == 0) { //OSCOKIRQ hasn't asserted in time
                return ( -1);
     702:	8f ef       	ldi	r24, 0xFF	; 255
     704:	1d c0       	rjmp	.+58     	; 0x740 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE4InitEv+0x8a>
        }

        regWr(rMODE, bmDPPULLDN | bmDMPULLDN | bmHOST); // set pull-downs, Host
     706:	61 ec       	ldi	r22, 0xC1	; 193
     708:	88 ed       	ldi	r24, 0xD8	; 216
     70a:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>

        regWr(rHIEN, bmCONDETIE | bmFRAMEIE); //connection detection
     70e:	60 e6       	ldi	r22, 0x60	; 96
     710:	80 ed       	ldi	r24, 0xD0	; 208
     712:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>

        /* check if device is connected */
        regWr(rHCTL, bmSAMPLEBUS); // sample USB bus
     716:	64 e0       	ldi	r22, 0x04	; 4
     718:	88 ee       	ldi	r24, 0xE8	; 232
     71a:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>
        while(!(regRd(rHCTL) & bmSAMPLEBUS)); //wait for sample operation to finish
     71e:	88 ee       	ldi	r24, 0xE8	; 232
     720:	0e 94 ed 02 	call	0x5da	; 0x5da <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.3>
     724:	82 ff       	sbrs	r24, 2
     726:	fb cf       	rjmp	.-10     	; 0x71e <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE4InitEv+0x68>

        busprobe(); //check if anything is connected
     728:	c8 01       	movw	r24, r16
     72a:	0e 94 2b 03 	call	0x656	; 0x656 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv>

        regWr(rHIRQ, bmCONDETIRQ); //clear connection detect interrupt
     72e:	60 e2       	ldi	r22, 0x20	; 32
     730:	88 ec       	ldi	r24, 0xC8	; 200
     732:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>
        regWr(rCPUCTL, 0x01); //enable interrupt pin
     736:	61 e0       	ldi	r22, 0x01	; 1
     738:	80 e8       	ldi	r24, 0x80	; 128
     73a:	0e 94 0a 03 	call	0x614	; 0x614 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.4>
     73e:	80 e0       	ldi	r24, 0x00	; 0

        return ( 0);
}
     740:	df 91       	pop	r29
     742:	cf 91       	pop	r28
     744:	1f 91       	pop	r17
     746:	0f 91       	pop	r16
     748:	08 95       	ret

0000074a <_ZN16ControllerCircit10InitializeEv>:
}

//----------------------------------------------------------------------//

void ControllerCircit::Initialize()
{
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	ec 01       	movw	r28, r24
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     750:	26 e0       	ldi	r18, 0x06	; 6
     752:	40 e0       	ldi	r20, 0x00	; 0
     754:	52 ec       	ldi	r21, 0xC2	; 194
     756:	61 e0       	ldi	r22, 0x01	; 1
     758:	70 e0       	ldi	r23, 0x00	; 0
     75a:	82 e8       	ldi	r24, 0x82	; 130
     75c:	95 e0       	ldi	r25, 0x05	; 5
     75e:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <_ZN14HardwareSerial5beginEmh>
	Serial.begin(115200);
	Serial.println("Hello!! Mr.Suzu! Activate this circuit. Wait a second.");
     762:	66 e1       	ldi	r22, 0x16	; 22
     764:	71 e0       	ldi	r23, 0x01	; 1
     766:	82 e8       	ldi	r24, 0x82	; 130
     768:	95 e0       	ldi	r25, 0x05	; 5
     76a:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>
	
	Serial.println("Confirm connection with Dualshock 3...");
     76e:	6d e4       	ldi	r22, 0x4D	; 77
     770:	71 e0       	ldi	r23, 0x01	; 1
     772:	82 e8       	ldi	r24, 0x82	; 130
     774:	95 e0       	ldi	r25, 0x05	; 5
     776:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>
	
	if (usb.Init() == -1)
     77a:	ce 01       	movw	r24, r28
     77c:	8c 54       	subi	r24, 0x4C	; 76
     77e:	9f 4f       	sbci	r25, 0xFF	; 255
     780:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE4InitEv>
     784:	8f 3f       	cpi	r24, 0xFF	; 255
     786:	91 f4       	brne	.+36     	; 0x7ac <_ZN16ControllerCircit10InitializeEv+0x62>
	{
		Serial.println("Failed connection with Dualshock 3.");
     788:	64 e7       	ldi	r22, 0x74	; 116
     78a:	71 e0       	ldi	r23, 0x01	; 1
     78c:	82 e8       	ldi	r24, 0x82	; 130
     78e:	95 e0       	ldi	r25, 0x05	; 5
     790:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>
		Serial.println("Confirm connection with Dualshock 3 again...");
     794:	68 e9       	ldi	r22, 0x98	; 152
     796:	71 e0       	ldi	r23, 0x01	; 1
     798:	82 e8       	ldi	r24, 0x82	; 130
     79a:	95 e0       	ldi	r25, 0x05	; 5
     79c:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>
		delay(100);
     7a0:	64 e6       	ldi	r22, 0x64	; 100
     7a2:	70 e0       	ldi	r23, 0x00	; 0
     7a4:	80 e0       	ldi	r24, 0x00	; 0
     7a6:	90 e0       	ldi	r25, 0x00	; 0
     7a8:	0e 94 de 06 	call	0xdbc	; 0xdbc <delay>
	}
	
	Serial.println("Successful connection with Dualshock 3!");
     7ac:	65 ec       	ldi	r22, 0xC5	; 197
     7ae:	71 e0       	ldi	r23, 0x01	; 1
     7b0:	82 e8       	ldi	r24, 0x82	; 130
     7b2:	95 e0       	ldi	r25, 0x05	; 5
     7b4:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>
	
	Serial.println("Initialize CAN BUS Shield...");
     7b8:	6d ee       	ldi	r22, 0xED	; 237
     7ba:	71 e0       	ldi	r23, 0x01	; 1
     7bc:	82 e8       	ldi	r24, 0x82	; 130
     7be:	95 e0       	ldi	r25, 0x05	; 5
     7c0:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>
	
	while (transfer.begin(CAN_BPS) != CAN_OK)
     7c4:	c6 55       	subi	r28, 0x56	; 86
     7c6:	df 4f       	sbci	r29, 0xFF	; 255
     7c8:	41 e0       	ldi	r20, 0x01	; 1
     7ca:	60 e1       	ldi	r22, 0x10	; 16
     7cc:	ce 01       	movw	r24, r28
     7ce:	0e 94 84 0a 	call	0x1508	; 0x1508 <_ZN7MCP_CAN5beginEhh>
     7d2:	88 23       	and	r24, r24
     7d4:	99 f0       	breq	.+38     	; 0x7fc <_ZN16ControllerCircit10InitializeEv+0xb2>
	{
		Serial.println("CAN BUS Shield initialization failed");
     7d6:	6a e0       	ldi	r22, 0x0A	; 10
     7d8:	72 e0       	ldi	r23, 0x02	; 2
     7da:	82 e8       	ldi	r24, 0x82	; 130
     7dc:	95 e0       	ldi	r25, 0x05	; 5
     7de:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>
		Serial.println("Initialize CAN BUS Shield again...");
     7e2:	6f e2       	ldi	r22, 0x2F	; 47
     7e4:	72 e0       	ldi	r23, 0x02	; 2
     7e6:	82 e8       	ldi	r24, 0x82	; 130
     7e8:	95 e0       	ldi	r25, 0x05	; 5
     7ea:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>
		delay(100);
     7ee:	64 e6       	ldi	r22, 0x64	; 100
     7f0:	70 e0       	ldi	r23, 0x00	; 0
     7f2:	80 e0       	ldi	r24, 0x00	; 0
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	0e 94 de 06 	call	0xdbc	; 0xdbc <delay>
	
	Serial.println("Successful connection with Dualshock 3!");
	
	Serial.println("Initialize CAN BUS Shield...");
	
	while (transfer.begin(CAN_BPS) != CAN_OK)
     7fa:	e6 cf       	rjmp	.-52     	; 0x7c8 <_ZN16ControllerCircit10InitializeEv+0x7e>
		Serial.println("CAN BUS Shield initialization failed");
		Serial.println("Initialize CAN BUS Shield again...");
		delay(100);
	}
	
	Serial.println("Successful initialization of CAN BUS Shield!");
     7fc:	62 e5       	ldi	r22, 0x52	; 82
     7fe:	72 e0       	ldi	r23, 0x02	; 2
     800:	82 e8       	ldi	r24, 0x82	; 130
     802:	95 e0       	ldi	r25, 0x05	; 5
     804:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>
	
	Serial.println("This circuit activated successfully.");
     808:	6f e7       	ldi	r22, 0x7F	; 127
     80a:	72 e0       	ldi	r23, 0x02	; 2
     80c:	82 e8       	ldi	r24, 0x82	; 130
     80e:	95 e0       	ldi	r25, 0x05	; 5
     810:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>
	Serial.println("Good luck");
     814:	64 ea       	ldi	r22, 0xA4	; 164
     816:	72 e0       	ldi	r23, 0x02	; 2
     818:	82 e8       	ldi	r24, 0x82	; 130
     81a:	95 e0       	ldi	r25, 0x05	; 5
}
     81c:	df 91       	pop	r29
     81e:	cf 91       	pop	r28
	}
	
	Serial.println("Successful initialization of CAN BUS Shield!");
	
	Serial.println("This circuit activated successfully.");
	Serial.println("Good luck");
     820:	0c 94 51 06 	jmp	0xca2	; 0xca2 <_ZN5Print7printlnEPKc>

00000824 <setup>:

//----------------------------------------------------------------------//

void setup()
{
	circit.Initialize();
     824:	87 e4       	ldi	r24, 0x47	; 71
     826:	94 e0       	ldi	r25, 0x04	; 4
     828:	0c 94 a5 03 	jmp	0x74a	; 0x74a <_ZN16ControllerCircit10InitializeEv>

0000082c <_GLOBAL__sub_I__Z16PrintHexadecimallj>:

//----------------------------------------------------------------------//

/************************************************************************/

ControllerCircit circit;
     82c:	87 e4       	ldi	r24, 0x47	; 71
     82e:	94 e0       	ldi	r25, 0x04	; 4
     830:	0c 94 86 01 	jmp	0x30c	; 0x30c <_ZN16ControllerCircitC1Ev>

00000834 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     834:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     836:	91 8d       	ldd	r25, Z+25	; 0x19
     838:	22 8d       	ldd	r18, Z+26	; 0x1a
     83a:	89 2f       	mov	r24, r25
     83c:	90 e0       	ldi	r25, 0x00	; 0
     83e:	80 5c       	subi	r24, 0xC0	; 192
     840:	9f 4f       	sbci	r25, 0xFF	; 255
     842:	82 1b       	sub	r24, r18
     844:	91 09       	sbc	r25, r1
}
     846:	8f 73       	andi	r24, 0x3F	; 63
     848:	99 27       	eor	r25, r25
     84a:	08 95       	ret

0000084c <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
     84c:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
     84e:	91 8d       	ldd	r25, Z+25	; 0x19
     850:	82 8d       	ldd	r24, Z+26	; 0x1a
     852:	98 17       	cp	r25, r24
     854:	31 f0       	breq	.+12     	; 0x862 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     856:	82 8d       	ldd	r24, Z+26	; 0x1a
     858:	e8 0f       	add	r30, r24
     85a:	f1 1d       	adc	r31, r1
     85c:	85 8d       	ldd	r24, Z+29	; 0x1d
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     862:	8f ef       	ldi	r24, 0xFF	; 255
     864:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     866:	08 95       	ret

00000868 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
     868:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     86a:	91 8d       	ldd	r25, Z+25	; 0x19
     86c:	82 8d       	ldd	r24, Z+26	; 0x1a
     86e:	98 17       	cp	r25, r24
     870:	61 f0       	breq	.+24     	; 0x88a <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     872:	82 8d       	ldd	r24, Z+26	; 0x1a
     874:	df 01       	movw	r26, r30
     876:	a8 0f       	add	r26, r24
     878:	b1 1d       	adc	r27, r1
     87a:	5d 96       	adiw	r26, 0x1d	; 29
     87c:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     87e:	92 8d       	ldd	r25, Z+26	; 0x1a
     880:	9f 5f       	subi	r25, 0xFF	; 255
     882:	9f 73       	andi	r25, 0x3F	; 63
     884:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     88a:	8f ef       	ldi	r24, 0xFF	; 255
     88c:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     88e:	08 95       	ret

00000890 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     890:	8d e9       	ldi	r24, 0x9D	; 157
     892:	95 e0       	ldi	r25, 0x05	; 5
     894:	89 2b       	or	r24, r25
     896:	49 f0       	breq	.+18     	; 0x8aa <_Z14serialEventRunv+0x1a>
     898:	80 e0       	ldi	r24, 0x00	; 0
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	89 2b       	or	r24, r25
     89e:	29 f0       	breq	.+10     	; 0x8aa <_Z14serialEventRunv+0x1a>
     8a0:	0e 94 9d 05 	call	0xb3a	; 0xb3a <_Z17Serial0_availablev>
     8a4:	81 11       	cpse	r24, r1
     8a6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
     8aa:	08 95       	ret

000008ac <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     8ac:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     8ae:	84 8d       	ldd	r24, Z+28	; 0x1c
     8b0:	df 01       	movw	r26, r30
     8b2:	a8 0f       	add	r26, r24
     8b4:	b1 1d       	adc	r27, r1
     8b6:	a3 5a       	subi	r26, 0xA3	; 163
     8b8:	bf 4f       	sbci	r27, 0xFF	; 255
     8ba:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     8bc:	84 8d       	ldd	r24, Z+28	; 0x1c
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	8f 73       	andi	r24, 0x3F	; 63
     8c4:	99 27       	eor	r25, r25
     8c6:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
     8c8:	a6 89       	ldd	r26, Z+22	; 0x16
     8ca:	b7 89       	ldd	r27, Z+23	; 0x17
     8cc:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
     8ce:	a0 89       	ldd	r26, Z+16	; 0x10
     8d0:	b1 89       	ldd	r27, Z+17	; 0x11
     8d2:	8c 91       	ld	r24, X
     8d4:	80 64       	ori	r24, 0x40	; 64
     8d6:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
     8d8:	93 8d       	ldd	r25, Z+27	; 0x1b
     8da:	84 8d       	ldd	r24, Z+28	; 0x1c
     8dc:	98 13       	cpse	r25, r24
     8de:	06 c0       	rjmp	.+12     	; 0x8ec <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     8e0:	02 88       	ldd	r0, Z+18	; 0x12
     8e2:	f3 89       	ldd	r31, Z+19	; 0x13
     8e4:	e0 2d       	mov	r30, r0
     8e6:	80 81       	ld	r24, Z
     8e8:	8f 7d       	andi	r24, 0xDF	; 223
     8ea:	80 83       	st	Z, r24
     8ec:	08 95       	ret

000008ee <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     8ee:	ef 92       	push	r14
     8f0:	ff 92       	push	r15
     8f2:	0f 93       	push	r16
     8f4:	1f 93       	push	r17
     8f6:	cf 93       	push	r28
     8f8:	df 93       	push	r29
     8fa:	ec 01       	movw	r28, r24
  _written = true;
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     900:	9b 8d       	ldd	r25, Y+27	; 0x1b
     902:	8c 8d       	ldd	r24, Y+28	; 0x1c
     904:	98 13       	cpse	r25, r24
     906:	05 c0       	rjmp	.+10     	; 0x912 <__stack+0x13>
     908:	e8 89       	ldd	r30, Y+16	; 0x10
     90a:	f9 89       	ldd	r31, Y+17	; 0x11
     90c:	80 81       	ld	r24, Z
     90e:	85 fd       	sbrc	r24, 5
     910:	24 c0       	rjmp	.+72     	; 0x95a <__stack+0x5b>
     912:	f6 2e       	mov	r15, r22
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     914:	0b 8d       	ldd	r16, Y+27	; 0x1b
     916:	10 e0       	ldi	r17, 0x00	; 0
     918:	0f 5f       	subi	r16, 0xFF	; 255
     91a:	1f 4f       	sbci	r17, 0xFF	; 255
     91c:	0f 73       	andi	r16, 0x3F	; 63
     91e:	11 27       	eor	r17, r17
     920:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     922:	8c 8d       	ldd	r24, Y+28	; 0x1c
     924:	e8 12       	cpse	r14, r24
     926:	0c c0       	rjmp	.+24     	; 0x940 <__stack+0x41>
    if (bit_is_clear(SREG, SREG_I)) {
     928:	0f b6       	in	r0, 0x3f	; 63
     92a:	07 fc       	sbrc	r0, 7
     92c:	fa cf       	rjmp	.-12     	; 0x922 <__stack+0x23>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     92e:	e8 89       	ldd	r30, Y+16	; 0x10
     930:	f9 89       	ldd	r31, Y+17	; 0x11
     932:	80 81       	ld	r24, Z
     934:	85 ff       	sbrs	r24, 5
     936:	f5 cf       	rjmp	.-22     	; 0x922 <__stack+0x23>
	_tx_udr_empty_irq();
     938:	ce 01       	movw	r24, r28
     93a:	0e 94 56 04 	call	0x8ac	; 0x8ac <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     93e:	f1 cf       	rjmp	.-30     	; 0x922 <__stack+0x23>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     940:	8b 8d       	ldd	r24, Y+27	; 0x1b
     942:	fe 01       	movw	r30, r28
     944:	e8 0f       	add	r30, r24
     946:	f1 1d       	adc	r31, r1
     948:	e3 5a       	subi	r30, 0xA3	; 163
     94a:	ff 4f       	sbci	r31, 0xFF	; 255
     94c:	f0 82       	st	Z, r15
  _tx_buffer_head = i;
     94e:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
     950:	ea 89       	ldd	r30, Y+18	; 0x12
     952:	fb 89       	ldd	r31, Y+19	; 0x13
     954:	80 81       	ld	r24, Z
     956:	80 62       	ori	r24, 0x20	; 32
     958:	07 c0       	rjmp	.+14     	; 0x968 <__stack+0x69>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
     95a:	ee 89       	ldd	r30, Y+22	; 0x16
     95c:	ff 89       	ldd	r31, Y+23	; 0x17
     95e:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
     960:	e8 89       	ldd	r30, Y+16	; 0x10
     962:	f9 89       	ldd	r31, Y+17	; 0x11
     964:	80 81       	ld	r24, Z
     966:	80 64       	ori	r24, 0x40	; 64
     968:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
     96a:	81 e0       	ldi	r24, 0x01	; 1
     96c:	90 e0       	ldi	r25, 0x00	; 0
     96e:	df 91       	pop	r29
     970:	cf 91       	pop	r28
     972:	1f 91       	pop	r17
     974:	0f 91       	pop	r16
     976:	ff 90       	pop	r15
     978:	ef 90       	pop	r14
     97a:	08 95       	ret

0000097c <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     97c:	cf 93       	push	r28
     97e:	df 93       	push	r29
     980:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     982:	88 8d       	ldd	r24, Y+24	; 0x18
     984:	88 23       	and	r24, r24
     986:	c9 f0       	breq	.+50     	; 0x9ba <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     988:	ea 89       	ldd	r30, Y+18	; 0x12
     98a:	fb 89       	ldd	r31, Y+19	; 0x13
     98c:	80 81       	ld	r24, Z
     98e:	85 fd       	sbrc	r24, 5
     990:	05 c0       	rjmp	.+10     	; 0x99c <_ZN14HardwareSerial5flushEv+0x20>
     992:	a8 89       	ldd	r26, Y+16	; 0x10
     994:	b9 89       	ldd	r27, Y+17	; 0x11
     996:	8c 91       	ld	r24, X
     998:	86 fd       	sbrc	r24, 6
     99a:	0f c0       	rjmp	.+30     	; 0x9ba <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     99c:	0f b6       	in	r0, 0x3f	; 63
     99e:	07 fc       	sbrc	r0, 7
     9a0:	f5 cf       	rjmp	.-22     	; 0x98c <_ZN14HardwareSerial5flushEv+0x10>
     9a2:	80 81       	ld	r24, Z
     9a4:	85 ff       	sbrs	r24, 5
     9a6:	f2 cf       	rjmp	.-28     	; 0x98c <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     9a8:	a8 89       	ldd	r26, Y+16	; 0x10
     9aa:	b9 89       	ldd	r27, Y+17	; 0x11
     9ac:	8c 91       	ld	r24, X
     9ae:	85 ff       	sbrs	r24, 5
     9b0:	ed cf       	rjmp	.-38     	; 0x98c <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
     9b2:	ce 01       	movw	r24, r28
     9b4:	0e 94 56 04 	call	0x8ac	; 0x8ac <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     9b8:	e7 cf       	rjmp	.-50     	; 0x988 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     9ba:	df 91       	pop	r29
     9bc:	cf 91       	pop	r28
     9be:	08 95       	ret

000009c0 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
     9c0:	cf 92       	push	r12
     9c2:	df 92       	push	r13
     9c4:	ef 92       	push	r14
     9c6:	ff 92       	push	r15
     9c8:	1f 93       	push	r17
     9ca:	cf 93       	push	r28
     9cc:	df 93       	push	r29
     9ce:	ec 01       	movw	r28, r24
     9d0:	6a 01       	movw	r12, r20
     9d2:	7b 01       	movw	r14, r22
     9d4:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
     9d6:	e8 89       	ldd	r30, Y+16	; 0x10
     9d8:	f9 89       	ldd	r31, Y+17	; 0x11
     9da:	82 e0       	ldi	r24, 0x02	; 2
     9dc:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     9de:	41 15       	cp	r20, r1
     9e0:	51 4e       	sbci	r21, 0xE1	; 225
     9e2:	61 05       	cpc	r22, r1
     9e4:	71 05       	cpc	r23, r1
     9e6:	b1 f0       	breq	.+44     	; 0xa14 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
     9e8:	60 e0       	ldi	r22, 0x00	; 0
     9ea:	79 e0       	ldi	r23, 0x09	; 9
     9ec:	8d e3       	ldi	r24, 0x3D	; 61
     9ee:	90 e0       	ldi	r25, 0x00	; 0
     9f0:	a7 01       	movw	r20, r14
     9f2:	96 01       	movw	r18, r12
     9f4:	0e 94 2d 19 	call	0x325a	; 0x325a <__udivmodsi4>
     9f8:	da 01       	movw	r26, r20
     9fa:	c9 01       	movw	r24, r18
     9fc:	01 97       	sbiw	r24, 0x01	; 1
     9fe:	a1 09       	sbc	r26, r1
     a00:	b1 09       	sbc	r27, r1
     a02:	b6 95       	lsr	r27
     a04:	a7 95       	ror	r26
     a06:	97 95       	ror	r25
     a08:	87 95       	ror	r24
     a0a:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     a0c:	21 15       	cp	r18, r1
     a0e:	80 e1       	ldi	r24, 0x10	; 16
     a10:	38 07       	cpc	r19, r24
     a12:	a8 f0       	brcs	.+42     	; 0xa3e <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
     a14:	e8 89       	ldd	r30, Y+16	; 0x10
     a16:	f9 89       	ldd	r31, Y+17	; 0x11
     a18:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
     a1a:	60 e8       	ldi	r22, 0x80	; 128
     a1c:	74 e8       	ldi	r23, 0x84	; 132
     a1e:	8e e1       	ldi	r24, 0x1E	; 30
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	a7 01       	movw	r20, r14
     a24:	96 01       	movw	r18, r12
     a26:	0e 94 2d 19 	call	0x325a	; 0x325a <__udivmodsi4>
     a2a:	da 01       	movw	r26, r20
     a2c:	c9 01       	movw	r24, r18
     a2e:	01 97       	sbiw	r24, 0x01	; 1
     a30:	a1 09       	sbc	r26, r1
     a32:	b1 09       	sbc	r27, r1
     a34:	b6 95       	lsr	r27
     a36:	a7 95       	ror	r26
     a38:	97 95       	ror	r25
     a3a:	87 95       	ror	r24
     a3c:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     a3e:	ec 85       	ldd	r30, Y+12	; 0x0c
     a40:	fd 85       	ldd	r31, Y+13	; 0x0d
     a42:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
     a44:	ee 85       	ldd	r30, Y+14	; 0x0e
     a46:	ff 85       	ldd	r31, Y+15	; 0x0f
     a48:	20 83       	st	Z, r18

  _written = false;
     a4a:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
     a4c:	ec 89       	ldd	r30, Y+20	; 0x14
     a4e:	fd 89       	ldd	r31, Y+21	; 0x15
     a50:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
     a52:	ea 89       	ldd	r30, Y+18	; 0x12
     a54:	fb 89       	ldd	r31, Y+19	; 0x13
     a56:	80 81       	ld	r24, Z
     a58:	80 61       	ori	r24, 0x10	; 16
     a5a:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
     a5c:	ea 89       	ldd	r30, Y+18	; 0x12
     a5e:	fb 89       	ldd	r31, Y+19	; 0x13
     a60:	80 81       	ld	r24, Z
     a62:	88 60       	ori	r24, 0x08	; 8
     a64:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
     a66:	ea 89       	ldd	r30, Y+18	; 0x12
     a68:	fb 89       	ldd	r31, Y+19	; 0x13
     a6a:	80 81       	ld	r24, Z
     a6c:	80 68       	ori	r24, 0x80	; 128
     a6e:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
     a70:	ea 89       	ldd	r30, Y+18	; 0x12
     a72:	fb 89       	ldd	r31, Y+19	; 0x13
     a74:	80 81       	ld	r24, Z
     a76:	8f 7d       	andi	r24, 0xDF	; 223
     a78:	80 83       	st	Z, r24
}
     a7a:	df 91       	pop	r29
     a7c:	cf 91       	pop	r28
     a7e:	1f 91       	pop	r17
     a80:	ff 90       	pop	r15
     a82:	ef 90       	pop	r14
     a84:	df 90       	pop	r13
     a86:	cf 90       	pop	r12
     a88:	08 95       	ret

00000a8a <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
     a8a:	1f 92       	push	r1
     a8c:	0f 92       	push	r0
     a8e:	0f b6       	in	r0, 0x3f	; 63
     a90:	0f 92       	push	r0
     a92:	11 24       	eor	r1, r1
     a94:	2f 93       	push	r18
     a96:	8f 93       	push	r24
     a98:	9f 93       	push	r25
     a9a:	ef 93       	push	r30
     a9c:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
     a9e:	e0 91 92 05 	lds	r30, 0x0592	; 0x800592 <Serial+0x10>
     aa2:	f0 91 93 05 	lds	r31, 0x0593	; 0x800593 <Serial+0x11>
     aa6:	80 81       	ld	r24, Z
     aa8:	e0 91 98 05 	lds	r30, 0x0598	; 0x800598 <Serial+0x16>
     aac:	f0 91 99 05 	lds	r31, 0x0599	; 0x800599 <Serial+0x17>
     ab0:	82 fd       	sbrc	r24, 2
     ab2:	12 c0       	rjmp	.+36     	; 0xad8 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
     ab4:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     ab6:	80 91 9b 05 	lds	r24, 0x059B	; 0x80059b <Serial+0x19>
     aba:	8f 5f       	subi	r24, 0xFF	; 255
     abc:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     abe:	20 91 9c 05 	lds	r18, 0x059C	; 0x80059c <Serial+0x1a>
     ac2:	82 17       	cp	r24, r18
     ac4:	51 f0       	breq	.+20     	; 0xada <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
     ac6:	e0 91 9b 05 	lds	r30, 0x059B	; 0x80059b <Serial+0x19>
     aca:	f0 e0       	ldi	r31, 0x00	; 0
     acc:	ee 57       	subi	r30, 0x7E	; 126
     ace:	fa 4f       	sbci	r31, 0xFA	; 250
     ad0:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
     ad2:	80 93 9b 05 	sts	0x059B, r24	; 0x80059b <Serial+0x19>
     ad6:	01 c0       	rjmp	.+2      	; 0xada <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
     ad8:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
     ada:	ff 91       	pop	r31
     adc:	ef 91       	pop	r30
     ade:	9f 91       	pop	r25
     ae0:	8f 91       	pop	r24
     ae2:	2f 91       	pop	r18
     ae4:	0f 90       	pop	r0
     ae6:	0f be       	out	0x3f, r0	; 63
     ae8:	0f 90       	pop	r0
     aea:	1f 90       	pop	r1
     aec:	18 95       	reti

00000aee <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
     aee:	1f 92       	push	r1
     af0:	0f 92       	push	r0
     af2:	0f b6       	in	r0, 0x3f	; 63
     af4:	0f 92       	push	r0
     af6:	11 24       	eor	r1, r1
     af8:	2f 93       	push	r18
     afa:	3f 93       	push	r19
     afc:	4f 93       	push	r20
     afe:	5f 93       	push	r21
     b00:	6f 93       	push	r22
     b02:	7f 93       	push	r23
     b04:	8f 93       	push	r24
     b06:	9f 93       	push	r25
     b08:	af 93       	push	r26
     b0a:	bf 93       	push	r27
     b0c:	ef 93       	push	r30
     b0e:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
     b10:	82 e8       	ldi	r24, 0x82	; 130
     b12:	95 e0       	ldi	r25, 0x05	; 5
     b14:	0e 94 56 04 	call	0x8ac	; 0x8ac <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
     b18:	ff 91       	pop	r31
     b1a:	ef 91       	pop	r30
     b1c:	bf 91       	pop	r27
     b1e:	af 91       	pop	r26
     b20:	9f 91       	pop	r25
     b22:	8f 91       	pop	r24
     b24:	7f 91       	pop	r23
     b26:	6f 91       	pop	r22
     b28:	5f 91       	pop	r21
     b2a:	4f 91       	pop	r20
     b2c:	3f 91       	pop	r19
     b2e:	2f 91       	pop	r18
     b30:	0f 90       	pop	r0
     b32:	0f be       	out	0x3f, r0	; 63
     b34:	0f 90       	pop	r0
     b36:	1f 90       	pop	r1
     b38:	18 95       	reti

00000b3a <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     b3a:	82 e8       	ldi	r24, 0x82	; 130
     b3c:	95 e0       	ldi	r25, 0x05	; 5
     b3e:	0e 94 1a 04 	call	0x834	; 0x834 <_ZN14HardwareSerial9availableEv>
     b42:	21 e0       	ldi	r18, 0x01	; 1
     b44:	89 2b       	or	r24, r25
     b46:	09 f4       	brne	.+2      	; 0xb4a <_Z17Serial0_availablev+0x10>
     b48:	20 e0       	ldi	r18, 0x00	; 0
}
     b4a:	82 2f       	mov	r24, r18
     b4c:	08 95       	ret

00000b4e <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     b4e:	e2 e8       	ldi	r30, 0x82	; 130
     b50:	f5 e0       	ldi	r31, 0x05	; 5
     b52:	13 82       	std	Z+3, r1	; 0x03
     b54:	12 82       	std	Z+2, r1	; 0x02
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
     b56:	88 ee       	ldi	r24, 0xE8	; 232
     b58:	93 e0       	ldi	r25, 0x03	; 3
     b5a:	a0 e0       	ldi	r26, 0x00	; 0
     b5c:	b0 e0       	ldi	r27, 0x00	; 0
     b5e:	84 83       	std	Z+4, r24	; 0x04
     b60:	95 83       	std	Z+5, r25	; 0x05
     b62:	a6 83       	std	Z+6, r26	; 0x06
     b64:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
     b66:	82 eb       	ldi	r24, 0xB2	; 178
     b68:	92 e0       	ldi	r25, 0x02	; 2
     b6a:	91 83       	std	Z+1, r25	; 0x01
     b6c:	80 83       	st	Z, r24
     b6e:	85 ec       	ldi	r24, 0xC5	; 197
     b70:	90 e0       	ldi	r25, 0x00	; 0
     b72:	95 87       	std	Z+13, r25	; 0x0d
     b74:	84 87       	std	Z+12, r24	; 0x0c
     b76:	84 ec       	ldi	r24, 0xC4	; 196
     b78:	90 e0       	ldi	r25, 0x00	; 0
     b7a:	97 87       	std	Z+15, r25	; 0x0f
     b7c:	86 87       	std	Z+14, r24	; 0x0e
     b7e:	80 ec       	ldi	r24, 0xC0	; 192
     b80:	90 e0       	ldi	r25, 0x00	; 0
     b82:	91 8b       	std	Z+17, r25	; 0x11
     b84:	80 8b       	std	Z+16, r24	; 0x10
     b86:	81 ec       	ldi	r24, 0xC1	; 193
     b88:	90 e0       	ldi	r25, 0x00	; 0
     b8a:	93 8b       	std	Z+19, r25	; 0x13
     b8c:	82 8b       	std	Z+18, r24	; 0x12
     b8e:	82 ec       	ldi	r24, 0xC2	; 194
     b90:	90 e0       	ldi	r25, 0x00	; 0
     b92:	95 8b       	std	Z+21, r25	; 0x15
     b94:	84 8b       	std	Z+20, r24	; 0x14
     b96:	86 ec       	ldi	r24, 0xC6	; 198
     b98:	90 e0       	ldi	r25, 0x00	; 0
     b9a:	97 8b       	std	Z+23, r25	; 0x17
     b9c:	86 8b       	std	Z+22, r24	; 0x16
     b9e:	11 8e       	std	Z+25, r1	; 0x19
     ba0:	12 8e       	std	Z+26, r1	; 0x1a
     ba2:	13 8e       	std	Z+27, r1	; 0x1b
     ba4:	14 8e       	std	Z+28, r1	; 0x1c
     ba6:	08 95       	ret

00000ba8 <initVariant>:
     ba8:	08 95       	ret

00000baa <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
     baa:	0e 94 25 07 	call	0xe4a	; 0xe4a <init>

	initVariant();
     bae:	0e 94 d4 05 	call	0xba8	; 0xba8 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
     bb2:	0e 94 12 04 	call	0x824	; 0x824 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
     bb6:	c8 e4       	ldi	r28, 0x48	; 72
     bb8:	d4 e0       	ldi	r29, 0x04	; 4
#endif
	
	setup();
    
	for (;;) {
		loop();
     bba:	0e 94 df 02 	call	0x5be	; 0x5be <loop>
		if (serialEventRun) serialEventRun();
     bbe:	20 97       	sbiw	r28, 0x00	; 0
     bc0:	e1 f3       	breq	.-8      	; 0xbba <main+0x10>
     bc2:	0e 94 48 04 	call	0x890	; 0x890 <_Z14serialEventRunv>
     bc6:	f9 cf       	rjmp	.-14     	; 0xbba <main+0x10>

00000bc8 <_Znaj>:
void *operator new(size_t size) {
  return malloc(size);
}

void *operator new[](size_t size) {
  return malloc(size);
     bc8:	0c 94 55 19 	jmp	0x32aa	; 0x32aa <malloc>

00000bcc <_ZdlPv>:
     bcc:	0c 94 ed 19 	jmp	0x33da	; 0x33da <free>

00000bd0 <_ZN5Print5writeEPKhj>:
size_t Print::println(const String &s)
{
  size_t n = print(s);
  n += println();
  return n;
}
     bd0:	cf 92       	push	r12
     bd2:	df 92       	push	r13
     bd4:	ef 92       	push	r14
     bd6:	ff 92       	push	r15
     bd8:	0f 93       	push	r16
     bda:	1f 93       	push	r17
     bdc:	cf 93       	push	r28
     bde:	df 93       	push	r29
     be0:	6c 01       	movw	r12, r24
     be2:	7a 01       	movw	r14, r20
     be4:	8b 01       	movw	r16, r22
     be6:	c0 e0       	ldi	r28, 0x00	; 0
     be8:	d0 e0       	ldi	r29, 0x00	; 0
     bea:	ce 15       	cp	r28, r14
     bec:	df 05       	cpc	r29, r15
     bee:	81 f0       	breq	.+32     	; 0xc10 <_ZN5Print5writeEPKhj+0x40>
     bf0:	d8 01       	movw	r26, r16
     bf2:	6d 91       	ld	r22, X+
     bf4:	8d 01       	movw	r16, r26
     bf6:	d6 01       	movw	r26, r12
     bf8:	ed 91       	ld	r30, X+
     bfa:	fc 91       	ld	r31, X
     bfc:	01 90       	ld	r0, Z+
     bfe:	f0 81       	ld	r31, Z
     c00:	e0 2d       	mov	r30, r0
     c02:	c6 01       	movw	r24, r12
     c04:	09 95       	icall
     c06:	89 2b       	or	r24, r25
     c08:	11 f0       	breq	.+4      	; 0xc0e <_ZN5Print5writeEPKhj+0x3e>
     c0a:	21 96       	adiw	r28, 0x01	; 1
     c0c:	ee cf       	rjmp	.-36     	; 0xbea <_ZN5Print5writeEPKhj+0x1a>
     c0e:	7e 01       	movw	r14, r28
     c10:	c7 01       	movw	r24, r14
     c12:	df 91       	pop	r29
     c14:	cf 91       	pop	r28
     c16:	1f 91       	pop	r17
     c18:	0f 91       	pop	r16
     c1a:	ff 90       	pop	r15
     c1c:	ef 90       	pop	r14
     c1e:	df 90       	pop	r13
     c20:	cf 90       	pop	r12
     c22:	08 95       	ret

00000c24 <_ZN5Print5writeEPKc>:
     c24:	61 15       	cp	r22, r1
     c26:	71 05       	cpc	r23, r1
     c28:	79 f0       	breq	.+30     	; 0xc48 <_ZN5Print5writeEPKc+0x24>
     c2a:	fb 01       	movw	r30, r22
     c2c:	01 90       	ld	r0, Z+
     c2e:	00 20       	and	r0, r0
     c30:	e9 f7       	brne	.-6      	; 0xc2c <_ZN5Print5writeEPKc+0x8>
     c32:	31 97       	sbiw	r30, 0x01	; 1
     c34:	af 01       	movw	r20, r30
     c36:	46 1b       	sub	r20, r22
     c38:	57 0b       	sbc	r21, r23
     c3a:	dc 01       	movw	r26, r24
     c3c:	ed 91       	ld	r30, X+
     c3e:	fc 91       	ld	r31, X
     c40:	02 80       	ldd	r0, Z+2	; 0x02
     c42:	f3 81       	ldd	r31, Z+3	; 0x03
     c44:	e0 2d       	mov	r30, r0
     c46:	09 94       	ijmp
     c48:	80 e0       	ldi	r24, 0x00	; 0
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	08 95       	ret

00000c4e <_ZN5Print5printEPK19__FlashStringHelper>:
     c4e:	ef 92       	push	r14
     c50:	ff 92       	push	r15
     c52:	0f 93       	push	r16
     c54:	1f 93       	push	r17
     c56:	cf 93       	push	r28
     c58:	df 93       	push	r29
     c5a:	8c 01       	movw	r16, r24
     c5c:	7b 01       	movw	r14, r22
     c5e:	c0 e0       	ldi	r28, 0x00	; 0
     c60:	d0 e0       	ldi	r29, 0x00	; 0
     c62:	f7 01       	movw	r30, r14
     c64:	ec 0f       	add	r30, r28
     c66:	fd 1f       	adc	r31, r29
     c68:	64 91       	lpm	r22, Z
     c6a:	66 23       	and	r22, r22
     c6c:	61 f0       	breq	.+24     	; 0xc86 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
     c6e:	d8 01       	movw	r26, r16
     c70:	ed 91       	ld	r30, X+
     c72:	fc 91       	ld	r31, X
     c74:	01 90       	ld	r0, Z+
     c76:	f0 81       	ld	r31, Z
     c78:	e0 2d       	mov	r30, r0
     c7a:	c8 01       	movw	r24, r16
     c7c:	09 95       	icall
     c7e:	89 2b       	or	r24, r25
     c80:	11 f0       	breq	.+4      	; 0xc86 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
     c82:	21 96       	adiw	r28, 0x01	; 1
     c84:	ee cf       	rjmp	.-36     	; 0xc62 <_ZN5Print5printEPK19__FlashStringHelper+0x14>
     c86:	ce 01       	movw	r24, r28
     c88:	df 91       	pop	r29
     c8a:	cf 91       	pop	r28
     c8c:	1f 91       	pop	r17
     c8e:	0f 91       	pop	r16
     c90:	ff 90       	pop	r15
     c92:	ef 90       	pop	r14
     c94:	08 95       	ret

00000c96 <_ZN5Print5printEPKc>:
     c96:	0c 94 12 06 	jmp	0xc24	; 0xc24 <_ZN5Print5writeEPKc>

00000c9a <_ZN5Print7printlnEv>:
     c9a:	6f ef       	ldi	r22, 0xFF	; 255
     c9c:	72 e0       	ldi	r23, 0x02	; 2
     c9e:	0c 94 12 06 	jmp	0xc24	; 0xc24 <_ZN5Print5writeEPKc>

00000ca2 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
     ca2:	0f 93       	push	r16
     ca4:	1f 93       	push	r17
     ca6:	cf 93       	push	r28
     ca8:	df 93       	push	r29
     caa:	ec 01       	movw	r28, r24
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     cac:	0e 94 12 06 	call	0xc24	; 0xc24 <_ZN5Print5writeEPKc>
     cb0:	8c 01       	movw	r16, r24
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
     cb2:	ce 01       	movw	r24, r28
     cb4:	0e 94 4d 06 	call	0xc9a	; 0xc9a <_ZN5Print7printlnEv>
  return n;
}
     cb8:	80 0f       	add	r24, r16
     cba:	91 1f       	adc	r25, r17
     cbc:	df 91       	pop	r29
     cbe:	cf 91       	pop	r28
     cc0:	1f 91       	pop	r17
     cc2:	0f 91       	pop	r16
     cc4:	08 95       	ret

00000cc6 <__vector_16>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
     cc6:	1f 92       	push	r1
     cc8:	0f 92       	push	r0
     cca:	0f b6       	in	r0, 0x3f	; 63
     ccc:	0f 92       	push	r0
     cce:	11 24       	eor	r1, r1
     cd0:	2f 93       	push	r18
     cd2:	3f 93       	push	r19
     cd4:	8f 93       	push	r24
     cd6:	9f 93       	push	r25
     cd8:	af 93       	push	r26
     cda:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
     cdc:	80 91 20 06 	lds	r24, 0x0620	; 0x800620 <timer0_millis>
     ce0:	90 91 21 06 	lds	r25, 0x0621	; 0x800621 <timer0_millis+0x1>
     ce4:	a0 91 22 06 	lds	r26, 0x0622	; 0x800622 <timer0_millis+0x2>
     ce8:	b0 91 23 06 	lds	r27, 0x0623	; 0x800623 <timer0_millis+0x3>
	unsigned char f = timer0_fract;
     cec:	30 91 1f 06 	lds	r19, 0x061F	; 0x80061f <timer0_fract>

	m += MILLIS_INC;
	f += FRACT_INC;
     cf0:	23 e0       	ldi	r18, 0x03	; 3
     cf2:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
     cf4:	2d 37       	cpi	r18, 0x7D	; 125
     cf6:	20 f4       	brcc	.+8      	; 0xd00 <__vector_16+0x3a>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
     cf8:	01 96       	adiw	r24, 0x01	; 1
     cfa:	a1 1d       	adc	r26, r1
     cfc:	b1 1d       	adc	r27, r1
     cfe:	05 c0       	rjmp	.+10     	; 0xd0a <__vector_16+0x44>
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
     d00:	26 e8       	ldi	r18, 0x86	; 134
     d02:	23 0f       	add	r18, r19
		m += 1;
     d04:	02 96       	adiw	r24, 0x02	; 2
     d06:	a1 1d       	adc	r26, r1
     d08:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
     d0a:	20 93 1f 06 	sts	0x061F, r18	; 0x80061f <timer0_fract>
	timer0_millis = m;
     d0e:	80 93 20 06 	sts	0x0620, r24	; 0x800620 <timer0_millis>
     d12:	90 93 21 06 	sts	0x0621, r25	; 0x800621 <timer0_millis+0x1>
     d16:	a0 93 22 06 	sts	0x0622, r26	; 0x800622 <timer0_millis+0x2>
     d1a:	b0 93 23 06 	sts	0x0623, r27	; 0x800623 <timer0_millis+0x3>
	timer0_overflow_count++;
     d1e:	80 91 24 06 	lds	r24, 0x0624	; 0x800624 <timer0_overflow_count>
     d22:	90 91 25 06 	lds	r25, 0x0625	; 0x800625 <timer0_overflow_count+0x1>
     d26:	a0 91 26 06 	lds	r26, 0x0626	; 0x800626 <timer0_overflow_count+0x2>
     d2a:	b0 91 27 06 	lds	r27, 0x0627	; 0x800627 <timer0_overflow_count+0x3>
     d2e:	01 96       	adiw	r24, 0x01	; 1
     d30:	a1 1d       	adc	r26, r1
     d32:	b1 1d       	adc	r27, r1
     d34:	80 93 24 06 	sts	0x0624, r24	; 0x800624 <timer0_overflow_count>
     d38:	90 93 25 06 	sts	0x0625, r25	; 0x800625 <timer0_overflow_count+0x1>
     d3c:	a0 93 26 06 	sts	0x0626, r26	; 0x800626 <timer0_overflow_count+0x2>
     d40:	b0 93 27 06 	sts	0x0627, r27	; 0x800627 <timer0_overflow_count+0x3>
}
     d44:	bf 91       	pop	r27
     d46:	af 91       	pop	r26
     d48:	9f 91       	pop	r25
     d4a:	8f 91       	pop	r24
     d4c:	3f 91       	pop	r19
     d4e:	2f 91       	pop	r18
     d50:	0f 90       	pop	r0
     d52:	0f be       	out	0x3f, r0	; 63
     d54:	0f 90       	pop	r0
     d56:	1f 90       	pop	r1
     d58:	18 95       	reti

00000d5a <millis>:

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     d5a:	2f b7       	in	r18, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     d5c:	f8 94       	cli
	m = timer0_millis;
     d5e:	60 91 20 06 	lds	r22, 0x0620	; 0x800620 <timer0_millis>
     d62:	70 91 21 06 	lds	r23, 0x0621	; 0x800621 <timer0_millis+0x1>
     d66:	80 91 22 06 	lds	r24, 0x0622	; 0x800622 <timer0_millis+0x2>
     d6a:	90 91 23 06 	lds	r25, 0x0623	; 0x800623 <timer0_millis+0x3>
	SREG = oldSREG;
     d6e:	2f bf       	out	0x3f, r18	; 63

	return m;
}
     d70:	08 95       	ret

00000d72 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     d72:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
     d74:	f8 94       	cli
	m = timer0_overflow_count;
     d76:	80 91 24 06 	lds	r24, 0x0624	; 0x800624 <timer0_overflow_count>
     d7a:	90 91 25 06 	lds	r25, 0x0625	; 0x800625 <timer0_overflow_count+0x1>
     d7e:	a0 91 26 06 	lds	r26, 0x0626	; 0x800626 <timer0_overflow_count+0x2>
     d82:	b0 91 27 06 	lds	r27, 0x0627	; 0x800627 <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
     d86:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     d88:	a8 9b       	sbis	0x15, 0	; 21
     d8a:	05 c0       	rjmp	.+10     	; 0xd96 <micros+0x24>
     d8c:	2f 3f       	cpi	r18, 0xFF	; 255
     d8e:	19 f0       	breq	.+6      	; 0xd96 <micros+0x24>
		m++;
     d90:	01 96       	adiw	r24, 0x01	; 1
     d92:	a1 1d       	adc	r26, r1
     d94:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     d96:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
     d98:	ba 2f       	mov	r27, r26
     d9a:	a9 2f       	mov	r26, r25
     d9c:	98 2f       	mov	r25, r24
     d9e:	88 27       	eor	r24, r24
     da0:	82 0f       	add	r24, r18
     da2:	91 1d       	adc	r25, r1
     da4:	a1 1d       	adc	r26, r1
     da6:	b1 1d       	adc	r27, r1
     da8:	bc 01       	movw	r22, r24
     daa:	cd 01       	movw	r24, r26
     dac:	42 e0       	ldi	r20, 0x02	; 2
     dae:	66 0f       	add	r22, r22
     db0:	77 1f       	adc	r23, r23
     db2:	88 1f       	adc	r24, r24
     db4:	99 1f       	adc	r25, r25
     db6:	4a 95       	dec	r20
     db8:	d1 f7       	brne	.-12     	; 0xdae <micros+0x3c>
}
     dba:	08 95       	ret

00000dbc <delay>:

void delay(unsigned long ms)
{
     dbc:	8f 92       	push	r8
     dbe:	9f 92       	push	r9
     dc0:	af 92       	push	r10
     dc2:	bf 92       	push	r11
     dc4:	cf 92       	push	r12
     dc6:	df 92       	push	r13
     dc8:	ef 92       	push	r14
     dca:	ff 92       	push	r15
     dcc:	6b 01       	movw	r12, r22
     dce:	7c 01       	movw	r14, r24
	uint32_t start = micros();
     dd0:	0e 94 b9 06 	call	0xd72	; 0xd72 <micros>
     dd4:	4b 01       	movw	r8, r22
     dd6:	5c 01       	movw	r10, r24

	while (ms > 0) {
     dd8:	c1 14       	cp	r12, r1
     dda:	d1 04       	cpc	r13, r1
     ddc:	e1 04       	cpc	r14, r1
     dde:	f1 04       	cpc	r15, r1
     de0:	01 f1       	breq	.+64     	; 0xe22 <delay+0x66>
		yield();
     de2:	0e 94 8c 18 	call	0x3118	; 0x3118 <yield>
		while ( ms > 0 && (micros() - start) >= 1000) {
     de6:	0e 94 b9 06 	call	0xd72	; 0xd72 <micros>
     dea:	dc 01       	movw	r26, r24
     dec:	cb 01       	movw	r24, r22
     dee:	88 19       	sub	r24, r8
     df0:	99 09       	sbc	r25, r9
     df2:	aa 09       	sbc	r26, r10
     df4:	bb 09       	sbc	r27, r11
     df6:	88 3e       	cpi	r24, 0xE8	; 232
     df8:	93 40       	sbci	r25, 0x03	; 3
     dfa:	a1 05       	cpc	r26, r1
     dfc:	b1 05       	cpc	r27, r1
     dfe:	60 f3       	brcs	.-40     	; 0xdd8 <delay+0x1c>
			ms--;
     e00:	21 e0       	ldi	r18, 0x01	; 1
     e02:	c2 1a       	sub	r12, r18
     e04:	d1 08       	sbc	r13, r1
     e06:	e1 08       	sbc	r14, r1
     e08:	f1 08       	sbc	r15, r1
			start += 1000;
     e0a:	88 ee       	ldi	r24, 0xE8	; 232
     e0c:	88 0e       	add	r8, r24
     e0e:	83 e0       	ldi	r24, 0x03	; 3
     e10:	98 1e       	adc	r9, r24
     e12:	a1 1c       	adc	r10, r1
     e14:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
     e16:	c1 14       	cp	r12, r1
     e18:	d1 04       	cpc	r13, r1
     e1a:	e1 04       	cpc	r14, r1
     e1c:	f1 04       	cpc	r15, r1
     e1e:	19 f7       	brne	.-58     	; 0xde6 <delay+0x2a>
     e20:	db cf       	rjmp	.-74     	; 0xdd8 <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
     e22:	ff 90       	pop	r15
     e24:	ef 90       	pop	r14
     e26:	df 90       	pop	r13
     e28:	cf 90       	pop	r12
     e2a:	bf 90       	pop	r11
     e2c:	af 90       	pop	r10
     e2e:	9f 90       	pop	r9
     e30:	8f 90       	pop	r8
     e32:	08 95       	ret

00000e34 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
     e34:	82 30       	cpi	r24, 0x02	; 2
     e36:	91 05       	cpc	r25, r1
     e38:	38 f0       	brcs	.+14     	; 0xe48 <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
     e3a:	88 0f       	add	r24, r24
     e3c:	99 1f       	adc	r25, r25
     e3e:	88 0f       	add	r24, r24
     e40:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
     e42:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
     e44:	01 97       	sbiw	r24, 0x01	; 1
     e46:	f1 f7       	brne	.-4      	; 0xe44 <delayMicroseconds+0x10>
     e48:	08 95       	ret

00000e4a <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     e4a:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     e4c:	84 b5       	in	r24, 0x24	; 36
     e4e:	82 60       	ori	r24, 0x02	; 2
     e50:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
     e52:	84 b5       	in	r24, 0x24	; 36
     e54:	81 60       	ori	r24, 0x01	; 1
     e56:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     e58:	85 b5       	in	r24, 0x25	; 37
     e5a:	82 60       	ori	r24, 0x02	; 2
     e5c:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
     e5e:	85 b5       	in	r24, 0x25	; 37
     e60:	81 60       	ori	r24, 0x01	; 1
     e62:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     e64:	ee e6       	ldi	r30, 0x6E	; 110
     e66:	f0 e0       	ldi	r31, 0x00	; 0
     e68:	80 81       	ld	r24, Z
     e6a:	81 60       	ori	r24, 0x01	; 1
     e6c:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     e6e:	e1 e8       	ldi	r30, 0x81	; 129
     e70:	f0 e0       	ldi	r31, 0x00	; 0
     e72:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     e74:	80 81       	ld	r24, Z
     e76:	82 60       	ori	r24, 0x02	; 2
     e78:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     e7a:	80 81       	ld	r24, Z
     e7c:	81 60       	ori	r24, 0x01	; 1
     e7e:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     e80:	e0 e8       	ldi	r30, 0x80	; 128
     e82:	f0 e0       	ldi	r31, 0x00	; 0
     e84:	80 81       	ld	r24, Z
     e86:	81 60       	ori	r24, 0x01	; 1
     e88:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     e8a:	e1 eb       	ldi	r30, 0xB1	; 177
     e8c:	f0 e0       	ldi	r31, 0x00	; 0
     e8e:	80 81       	ld	r24, Z
     e90:	84 60       	ori	r24, 0x04	; 4
     e92:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     e94:	e0 eb       	ldi	r30, 0xB0	; 176
     e96:	f0 e0       	ldi	r31, 0x00	; 0
     e98:	80 81       	ld	r24, Z
     e9a:	81 60       	ori	r24, 0x01	; 1
     e9c:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
     e9e:	ea e7       	ldi	r30, 0x7A	; 122
     ea0:	f0 e0       	ldi	r31, 0x00	; 0
     ea2:	80 81       	ld	r24, Z
     ea4:	84 60       	ori	r24, 0x04	; 4
     ea6:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
     ea8:	80 81       	ld	r24, Z
     eaa:	82 60       	ori	r24, 0x02	; 2
     eac:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
     eae:	80 81       	ld	r24, Z
     eb0:	81 60       	ori	r24, 0x01	; 1
     eb2:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     eb4:	80 81       	ld	r24, Z
     eb6:	80 68       	ori	r24, 0x80	; 128
     eb8:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     eba:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     ebe:	08 95       	ret

00000ec0 <_ZN8SPIClass8transferEh>:
** Descriptions:            send buf
*********************************************************************************************************/
byte MCP_CAN::sendMsgBuf(unsigned long id, byte ext, byte rtrBit, byte len, const byte *buf, bool wait_sent)
{
    return sendMsg(id,ext,rtrBit,len,buf,wait_sent);
}
     ec0:	8e bd       	out	0x2e, r24	; 46
     ec2:	00 00       	nop
     ec4:	0d b4       	in	r0, 0x2d	; 45
     ec6:	07 fe       	sbrs	r0, 7
     ec8:	fd cf       	rjmp	.-6      	; 0xec4 <_ZN8SPIClass8transferEh+0x4>
     eca:	8e b5       	in	r24, 0x2e	; 46
     ecc:	08 95       	ret

00000ece <_ZN8SPIClass14endTransactionEv>:
     ece:	80 91 2a 06 	lds	r24, 0x062A	; 0x80062a <_ZN8SPIClass13interruptModeE>
     ed2:	88 23       	and	r24, r24
     ed4:	61 f0       	breq	.+24     	; 0xeee <_ZN8SPIClass14endTransactionEv+0x20>
     ed6:	9f b7       	in	r25, 0x3f	; 63
     ed8:	f8 94       	cli
     eda:	20 91 2a 06 	lds	r18, 0x062A	; 0x80062a <_ZN8SPIClass13interruptModeE>
     ede:	80 91 28 06 	lds	r24, 0x0628	; 0x800628 <_ZN8SPIClass13interruptSaveE>
     ee2:	21 30       	cpi	r18, 0x01	; 1
     ee4:	19 f4       	brne	.+6      	; 0xeec <_ZN8SPIClass14endTransactionEv+0x1e>
     ee6:	8d bb       	out	0x1d, r24	; 29
     ee8:	9f bf       	out	0x3f, r25	; 63
     eea:	08 95       	ret
     eec:	8f bf       	out	0x3f, r24	; 63
     eee:	08 95       	ret

00000ef0 <_Z11txSidhToRTSh>:
     ef0:	81 34       	cpi	r24, 0x41	; 65
     ef2:	31 f0       	breq	.+12     	; 0xf00 <_Z11txSidhToRTSh+0x10>
     ef4:	81 35       	cpi	r24, 0x51	; 81
     ef6:	31 f0       	breq	.+12     	; 0xf04 <_Z11txSidhToRTSh+0x14>
     ef8:	81 33       	cpi	r24, 0x31	; 49
     efa:	31 f0       	breq	.+12     	; 0xf08 <_Z11txSidhToRTSh+0x18>
     efc:	80 e0       	ldi	r24, 0x00	; 0
     efe:	08 95       	ret
     f00:	82 e8       	ldi	r24, 0x82	; 130
     f02:	08 95       	ret
     f04:	84 e8       	ldi	r24, 0x84	; 132
     f06:	08 95       	ret
     f08:	81 e8       	ldi	r24, 0x81	; 129
     f0a:	08 95       	ret

00000f0c <_Z14txSidhToTxLoadh>:
     f0c:	81 34       	cpi	r24, 0x41	; 65
     f0e:	31 f0       	breq	.+12     	; 0xf1c <_Z14txSidhToTxLoadh+0x10>
     f10:	81 35       	cpi	r24, 0x51	; 81
     f12:	31 f0       	breq	.+12     	; 0xf20 <_Z14txSidhToTxLoadh+0x14>
     f14:	81 33       	cpi	r24, 0x31	; 49
     f16:	31 f0       	breq	.+12     	; 0xf24 <_Z14txSidhToTxLoadh+0x18>
     f18:	80 e0       	ldi	r24, 0x00	; 0
     f1a:	08 95       	ret
     f1c:	82 e4       	ldi	r24, 0x42	; 66
     f1e:	08 95       	ret
     f20:	84 e4       	ldi	r24, 0x44	; 68
     f22:	08 95       	ret
     f24:	80 e4       	ldi	r24, 0x40	; 64
     f26:	08 95       	ret

00000f28 <_ZN7MCP_CAN13mcp2515_resetEv>:
     f28:	cf 93       	push	r28
     f2a:	df 93       	push	r29
     f2c:	ec 01       	movw	r28, r24
     f2e:	80 e5       	ldi	r24, 0x50	; 80
     f30:	91 e0       	ldi	r25, 0x01	; 1
     f32:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
     f36:	60 e0       	ldi	r22, 0x00	; 0
     f38:	8e 81       	ldd	r24, Y+6	; 0x06
     f3a:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
     f3e:	80 ec       	ldi	r24, 0xC0	; 192
     f40:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
     f44:	61 e0       	ldi	r22, 0x01	; 1
     f46:	8e 81       	ldd	r24, Y+6	; 0x06
     f48:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
     f4c:	0e 94 67 07 	call	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>
     f50:	6a e0       	ldi	r22, 0x0A	; 10
     f52:	70 e0       	ldi	r23, 0x00	; 0
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	df 91       	pop	r29
     f5a:	cf 91       	pop	r28
     f5c:	0c 94 de 06 	jmp	0xdbc	; 0xdbc <delay>

00000f60 <_ZN7MCP_CAN20mcp2515_readRegisterEh>:
     f60:	1f 93       	push	r17
     f62:	cf 93       	push	r28
     f64:	df 93       	push	r29
     f66:	ec 01       	movw	r28, r24
     f68:	16 2f       	mov	r17, r22
     f6a:	80 e5       	ldi	r24, 0x50	; 80
     f6c:	91 e0       	ldi	r25, 0x01	; 1
     f6e:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
     f72:	60 e0       	ldi	r22, 0x00	; 0
     f74:	8e 81       	ldd	r24, Y+6	; 0x06
     f76:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
     f7a:	83 e0       	ldi	r24, 0x03	; 3
     f7c:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
     f80:	81 2f       	mov	r24, r17
     f82:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
     f86:	80 e0       	ldi	r24, 0x00	; 0
     f88:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
     f8c:	18 2f       	mov	r17, r24
     f8e:	61 e0       	ldi	r22, 0x01	; 1
     f90:	8e 81       	ldd	r24, Y+6	; 0x06
     f92:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
     f96:	0e 94 67 07 	call	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>
     f9a:	81 2f       	mov	r24, r17
     f9c:	df 91       	pop	r29
     f9e:	cf 91       	pop	r28
     fa0:	1f 91       	pop	r17
     fa2:	08 95       	ret

00000fa4 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>:
     fa4:	0f 93       	push	r16
     fa6:	1f 93       	push	r17
     fa8:	cf 93       	push	r28
     faa:	df 93       	push	r29
     fac:	ec 01       	movw	r28, r24
     fae:	06 2f       	mov	r16, r22
     fb0:	14 2f       	mov	r17, r20
     fb2:	80 e5       	ldi	r24, 0x50	; 80
     fb4:	91 e0       	ldi	r25, 0x01	; 1
     fb6:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
     fba:	60 e0       	ldi	r22, 0x00	; 0
     fbc:	8e 81       	ldd	r24, Y+6	; 0x06
     fbe:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
     fc2:	82 e0       	ldi	r24, 0x02	; 2
     fc4:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
     fc8:	80 2f       	mov	r24, r16
     fca:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
     fce:	81 2f       	mov	r24, r17
     fd0:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
     fd4:	61 e0       	ldi	r22, 0x01	; 1
     fd6:	8e 81       	ldd	r24, Y+6	; 0x06
     fd8:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
     fdc:	df 91       	pop	r29
     fde:	cf 91       	pop	r28
     fe0:	1f 91       	pop	r17
     fe2:	0f 91       	pop	r16
     fe4:	0c 94 67 07 	jmp	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>

00000fe8 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>:
     fe8:	ff 92       	push	r15
     fea:	0f 93       	push	r16
     fec:	1f 93       	push	r17
     fee:	cf 93       	push	r28
     ff0:	df 93       	push	r29
     ff2:	ec 01       	movw	r28, r24
     ff4:	f6 2e       	mov	r15, r22
     ff6:	04 2f       	mov	r16, r20
     ff8:	12 2f       	mov	r17, r18
     ffa:	80 e5       	ldi	r24, 0x50	; 80
     ffc:	91 e0       	ldi	r25, 0x01	; 1
     ffe:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
    1002:	60 e0       	ldi	r22, 0x00	; 0
    1004:	8e 81       	ldd	r24, Y+6	; 0x06
    1006:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
    100a:	85 e0       	ldi	r24, 0x05	; 5
    100c:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    1010:	8f 2d       	mov	r24, r15
    1012:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    1016:	80 2f       	mov	r24, r16
    1018:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    101c:	81 2f       	mov	r24, r17
    101e:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    1022:	61 e0       	ldi	r22, 0x01	; 1
    1024:	8e 81       	ldd	r24, Y+6	; 0x06
    1026:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
    102a:	df 91       	pop	r29
    102c:	cf 91       	pop	r28
    102e:	1f 91       	pop	r17
    1030:	0f 91       	pop	r16
    1032:	ff 90       	pop	r15
    1034:	0c 94 67 07 	jmp	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>

00001038 <_ZN7MCP_CAN18mcp2515_readStatusEv>:
    1038:	1f 93       	push	r17
    103a:	cf 93       	push	r28
    103c:	df 93       	push	r29
    103e:	ec 01       	movw	r28, r24
    1040:	80 e5       	ldi	r24, 0x50	; 80
    1042:	91 e0       	ldi	r25, 0x01	; 1
    1044:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
    1048:	60 e0       	ldi	r22, 0x00	; 0
    104a:	8e 81       	ldd	r24, Y+6	; 0x06
    104c:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
    1050:	80 ea       	ldi	r24, 0xA0	; 160
    1052:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    105c:	18 2f       	mov	r17, r24
    105e:	61 e0       	ldi	r22, 0x01	; 1
    1060:	8e 81       	ldd	r24, Y+6	; 0x06
    1062:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
    1066:	0e 94 67 07 	call	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>
    106a:	81 2f       	mov	r24, r17
    106c:	df 91       	pop	r29
    106e:	cf 91       	pop	r28
    1070:	1f 91       	pop	r17
    1072:	08 95       	ret

00001074 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>:
    1074:	0f 93       	push	r16
    1076:	1f 93       	push	r17
    1078:	cf 93       	push	r28
    107a:	8c 01       	movw	r16, r24
    107c:	c6 2f       	mov	r28, r22
    107e:	26 2f       	mov	r18, r22
    1080:	40 ee       	ldi	r20, 0xE0	; 224
    1082:	6f e0       	ldi	r22, 0x0F	; 15
    1084:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1088:	6f e0       	ldi	r22, 0x0F	; 15
    108a:	c8 01       	movw	r24, r16
    108c:	0e 94 b0 07 	call	0xf60	; 0xf60 <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1090:	98 2f       	mov	r25, r24
    1092:	90 7e       	andi	r25, 0xE0	; 224
    1094:	81 e0       	ldi	r24, 0x01	; 1
    1096:	9c 13       	cpse	r25, r28
    1098:	01 c0       	rjmp	.+2      	; 0x109c <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh+0x28>
    109a:	80 e0       	ldi	r24, 0x00	; 0
    109c:	cf 91       	pop	r28
    109e:	1f 91       	pop	r17
    10a0:	0f 91       	pop	r16
    10a2:	08 95       	ret

000010a4 <_ZN7MCP_CAN18mcp2515_configRateEhh>:
    10a4:	0f 93       	push	r16
    10a6:	1f 93       	push	r17
    10a8:	cf 93       	push	r28
    10aa:	df 93       	push	r29
    10ac:	41 30       	cpi	r20, 0x01	; 1
    10ae:	21 f0       	breq	.+8      	; 0x10b8 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x14>
    10b0:	42 30       	cpi	r20, 0x02	; 2
    10b2:	09 f4       	brne	.+2      	; 0x10b6 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x12>
    10b4:	3f c0       	rjmp	.+126    	; 0x1134 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x90>
    10b6:	71 c0       	rjmp	.+226    	; 0x119a <_ZN7MCP_CAN18mcp2515_configRateEhh+0xf6>
    10b8:	46 2f       	mov	r20, r22
    10ba:	50 e0       	ldi	r21, 0x00	; 0
    10bc:	fa 01       	movw	r30, r20
    10be:	31 97       	sbiw	r30, 0x01	; 1
    10c0:	e2 31       	cpi	r30, 0x12	; 18
    10c2:	f1 05       	cpc	r31, r1
    10c4:	08 f0       	brcs	.+2      	; 0x10c8 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x24>
    10c6:	69 c0       	rjmp	.+210    	; 0x119a <_ZN7MCP_CAN18mcp2515_configRateEhh+0xf6>
    10c8:	ec 5c       	subi	r30, 0xCC	; 204
    10ca:	ff 4f       	sbci	r31, 0xFF	; 255
    10cc:	0c 94 4f 19 	jmp	0x329e	; 0x329e <__tablejump2__>
    10d0:	c7 e8       	ldi	r28, 0x87	; 135
    10d2:	df ef       	ldi	r29, 0xFF	; 255
    10d4:	6e c0       	rjmp	.+220    	; 0x11b2 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x10e>
    10d6:	c7 e0       	ldi	r28, 0x07	; 7
    10d8:	da eb       	ldi	r29, 0xBA	; 186
    10da:	67 c0       	rjmp	.+206    	; 0x11aa <_ZN7MCP_CAN18mcp2515_configRateEhh+0x106>
    10dc:	c5 e8       	ldi	r28, 0x85	; 133
    10de:	d1 ef       	ldi	r29, 0xF1	; 241
    10e0:	64 c0       	rjmp	.+200    	; 0x11aa <_ZN7MCP_CAN18mcp2515_configRateEhh+0x106>
    10e2:	c7 e0       	ldi	r28, 0x07	; 7
    10e4:	de eb       	ldi	r29, 0xBE	; 190
    10e6:	49 e0       	ldi	r20, 0x09	; 9
    10e8:	65 c0       	rjmp	.+202    	; 0x11b4 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x110>
    10ea:	c7 e8       	ldi	r28, 0x87	; 135
    10ec:	df ef       	ldi	r29, 0xFF	; 255
    10ee:	35 c0       	rjmp	.+106    	; 0x115a <_ZN7MCP_CAN18mcp2515_configRateEhh+0xb6>
    10f0:	c7 e8       	ldi	r28, 0x87	; 135
    10f2:	da ef       	ldi	r29, 0xFA	; 250
    10f4:	32 c0       	rjmp	.+100    	; 0x115a <_ZN7MCP_CAN18mcp2515_configRateEhh+0xb6>
    10f6:	c7 e8       	ldi	r28, 0x87	; 135
    10f8:	df ef       	ldi	r29, 0xFF	; 255
    10fa:	36 c0       	rjmp	.+108    	; 0x1168 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xc4>
    10fc:	c7 e0       	ldi	r28, 0x07	; 7
    10fe:	de eb       	ldi	r29, 0xBE	; 190
    1100:	33 c0       	rjmp	.+102    	; 0x1168 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xc4>
    1102:	c7 e0       	ldi	r28, 0x07	; 7
    1104:	dd ea       	ldi	r29, 0xAD	; 173
    1106:	30 c0       	rjmp	.+96     	; 0x1168 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xc4>
    1108:	c7 e8       	ldi	r28, 0x87	; 135
    110a:	da ef       	ldi	r29, 0xFA	; 250
    110c:	2d c0       	rjmp	.+90     	; 0x1168 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xc4>
    110e:	c6 e8       	ldi	r28, 0x86	; 134
    1110:	d0 ef       	ldi	r29, 0xF0	; 240
    1112:	2a c0       	rjmp	.+84     	; 0x1168 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xc4>
    1114:	c7 e8       	ldi	r28, 0x87	; 135
    1116:	da ef       	ldi	r29, 0xFA	; 250
    1118:	2e c0       	rjmp	.+92     	; 0x1176 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xd2>
    111a:	c5 e8       	ldi	r28, 0x85	; 133
    111c:	d1 ef       	ldi	r29, 0xF1	; 241
    111e:	41 e4       	ldi	r20, 0x41	; 65
    1120:	49 c0       	rjmp	.+146    	; 0x11b4 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x110>
    1122:	c6 e8       	ldi	r28, 0x86	; 134
    1124:	d0 ef       	ldi	r29, 0xF0	; 240
    1126:	2e c0       	rjmp	.+92     	; 0x1184 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xe0>
    1128:	c4 e0       	ldi	r28, 0x04	; 4
    112a:	d0 ea       	ldi	r29, 0xA0	; 160
    112c:	2b c0       	rjmp	.+86     	; 0x1184 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xe0>
    112e:	c2 e8       	ldi	r28, 0x82	; 130
    1130:	d0 ed       	ldi	r29, 0xD0	; 208
    1132:	28 c0       	rjmp	.+80     	; 0x1184 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xe0>
    1134:	46 2f       	mov	r20, r22
    1136:	50 e0       	ldi	r21, 0x00	; 0
    1138:	fa 01       	movw	r30, r20
    113a:	31 97       	sbiw	r30, 0x01	; 1
    113c:	e2 31       	cpi	r30, 0x12	; 18
    113e:	f1 05       	cpc	r31, r1
    1140:	60 f5       	brcc	.+88     	; 0x119a <_ZN7MCP_CAN18mcp2515_configRateEhh+0xf6>
    1142:	ea 5b       	subi	r30, 0xBA	; 186
    1144:	ff 4f       	sbci	r31, 0xFF	; 255
    1146:	0c 94 4f 19 	jmp	0x329e	; 0x329e <__tablejump2__>
    114a:	c7 e0       	ldi	r28, 0x07	; 7
    114c:	df eb       	ldi	r29, 0xBF	; 191
    114e:	2d c0       	rjmp	.+90     	; 0x11aa <_ZN7MCP_CAN18mcp2515_configRateEhh+0x106>
    1150:	c7 e0       	ldi	r28, 0x07	; 7
    1152:	df eb       	ldi	r29, 0xBF	; 191
    1154:	02 c0       	rjmp	.+4      	; 0x115a <_ZN7MCP_CAN18mcp2515_configRateEhh+0xb6>
    1156:	c4 e0       	ldi	r28, 0x04	; 4
    1158:	d4 ea       	ldi	r29, 0xA4	; 164
    115a:	47 e0       	ldi	r20, 0x07	; 7
    115c:	2b c0       	rjmp	.+86     	; 0x11b4 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x110>
    115e:	c7 e0       	ldi	r28, 0x07	; 7
    1160:	df eb       	ldi	r29, 0xBF	; 191
    1162:	02 c0       	rjmp	.+4      	; 0x1168 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xc4>
    1164:	c6 e0       	ldi	r28, 0x06	; 6
    1166:	d4 eb       	ldi	r29, 0xB4	; 180
    1168:	43 e0       	ldi	r20, 0x03	; 3
    116a:	24 c0       	rjmp	.+72     	; 0x11b4 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x110>
    116c:	c7 e0       	ldi	r28, 0x07	; 7
    116e:	df eb       	ldi	r29, 0xBF	; 191
    1170:	02 c0       	rjmp	.+4      	; 0x1176 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xd2>
    1172:	c6 e0       	ldi	r28, 0x06	; 6
    1174:	d4 eb       	ldi	r29, 0xB4	; 180
    1176:	41 e0       	ldi	r20, 0x01	; 1
    1178:	1d c0       	rjmp	.+58     	; 0x11b4 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x110>
    117a:	c5 e0       	ldi	r28, 0x05	; 5
    117c:	d1 eb       	ldi	r29, 0xB1	; 177
    117e:	fb cf       	rjmp	.-10     	; 0x1176 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xd2>
    1180:	c6 e0       	ldi	r28, 0x06	; 6
    1182:	d4 eb       	ldi	r29, 0xB4	; 180
    1184:	40 e0       	ldi	r20, 0x00	; 0
    1186:	16 c0       	rjmp	.+44     	; 0x11b4 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x110>
    1188:	c5 e0       	ldi	r28, 0x05	; 5
    118a:	d1 eb       	ldi	r29, 0xB1	; 177
    118c:	fb cf       	rjmp	.-10     	; 0x1184 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xe0>
    118e:	c2 e0       	ldi	r28, 0x02	; 2
    1190:	d0 e9       	ldi	r29, 0x90	; 144
    1192:	f8 cf       	rjmp	.-16     	; 0x1184 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xe0>
    1194:	c0 e0       	ldi	r28, 0x00	; 0
    1196:	d0 e8       	ldi	r29, 0x80	; 128
    1198:	f5 cf       	rjmp	.-22     	; 0x1184 <_ZN7MCP_CAN18mcp2515_configRateEhh+0xe0>
    119a:	81 e0       	ldi	r24, 0x01	; 1
    119c:	1a c0       	rjmp	.+52     	; 0x11d2 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x12e>
    119e:	c7 e8       	ldi	r28, 0x87	; 135
    11a0:	df ef       	ldi	r29, 0xFF	; 255
    11a2:	4f e3       	ldi	r20, 0x3F	; 63
    11a4:	07 c0       	rjmp	.+14     	; 0x11b4 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x110>
    11a6:	c7 e8       	ldi	r28, 0x87	; 135
    11a8:	df ef       	ldi	r29, 0xFF	; 255
    11aa:	4f e0       	ldi	r20, 0x0F	; 15
    11ac:	03 c0       	rjmp	.+6      	; 0x11b4 <_ZN7MCP_CAN18mcp2515_configRateEhh+0x110>
    11ae:	c7 e0       	ldi	r28, 0x07	; 7
    11b0:	df eb       	ldi	r29, 0xBF	; 191
    11b2:	4f e1       	ldi	r20, 0x1F	; 31
    11b4:	8c 01       	movw	r16, r24
    11b6:	6a e2       	ldi	r22, 0x2A	; 42
    11b8:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    11bc:	4d 2f       	mov	r20, r29
    11be:	69 e2       	ldi	r22, 0x29	; 41
    11c0:	c8 01       	movw	r24, r16
    11c2:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    11c6:	4c 2f       	mov	r20, r28
    11c8:	68 e2       	ldi	r22, 0x28	; 40
    11ca:	c8 01       	movw	r24, r16
    11cc:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    11d0:	80 e0       	ldi	r24, 0x00	; 0
    11d2:	df 91       	pop	r29
    11d4:	cf 91       	pop	r28
    11d6:	1f 91       	pop	r17
    11d8:	0f 91       	pop	r16
    11da:	08 95       	ret

000011dc <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>:
    11dc:	0f 93       	push	r16
    11de:	1f 93       	push	r17
    11e0:	cf 93       	push	r28
    11e2:	8c 01       	movw	r16, r24
    11e4:	c0 e3       	ldi	r28, 0x30	; 48
    11e6:	40 e0       	ldi	r20, 0x00	; 0
    11e8:	6c 2f       	mov	r22, r28
    11ea:	c8 01       	movw	r24, r16
    11ec:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    11f0:	60 e1       	ldi	r22, 0x10	; 16
    11f2:	6c 0f       	add	r22, r28
    11f4:	40 e0       	ldi	r20, 0x00	; 0
    11f6:	c8 01       	movw	r24, r16
    11f8:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    11fc:	60 e2       	ldi	r22, 0x20	; 32
    11fe:	6c 0f       	add	r22, r28
    1200:	40 e0       	ldi	r20, 0x00	; 0
    1202:	c8 01       	movw	r24, r16
    1204:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1208:	cf 5f       	subi	r28, 0xFF	; 255
    120a:	ce 33       	cpi	r28, 0x3E	; 62
    120c:	61 f7       	brne	.-40     	; 0x11e6 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv+0xa>
    120e:	40 e0       	ldi	r20, 0x00	; 0
    1210:	60 e6       	ldi	r22, 0x60	; 96
    1212:	c8 01       	movw	r24, r16
    1214:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1218:	40 e0       	ldi	r20, 0x00	; 0
    121a:	60 e7       	ldi	r22, 0x70	; 112
    121c:	c8 01       	movw	r24, r16
    121e:	cf 91       	pop	r28
    1220:	1f 91       	pop	r17
    1222:	0f 91       	pop	r16
    1224:	0c 94 d2 07 	jmp	0xfa4	; 0xfa4 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>

00001228 <_ZN7MCP_CAN12mcp2515_initEhh>:
    1228:	ff 92       	push	r15
    122a:	0f 93       	push	r16
    122c:	1f 93       	push	r17
    122e:	cf 93       	push	r28
    1230:	df 93       	push	r29
    1232:	ec 01       	movw	r28, r24
    1234:	06 2f       	mov	r16, r22
    1236:	f4 2e       	mov	r15, r20
    1238:	0e 94 94 07 	call	0xf28	; 0xf28 <_ZN7MCP_CAN13mcp2515_resetEv>
    123c:	60 e8       	ldi	r22, 0x80	; 128
    123e:	ce 01       	movw	r24, r28
    1240:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    1244:	18 2f       	mov	r17, r24
    1246:	88 23       	and	r24, r24
    1248:	19 f0       	breq	.+6      	; 0x1250 <_ZN7MCP_CAN12mcp2515_initEhh+0x28>
    124a:	6a ec       	ldi	r22, 0xCA	; 202
    124c:	72 e0       	ldi	r23, 0x02	; 2
    124e:	36 c0       	rjmp	.+108    	; 0x12bc <_ZN7MCP_CAN12mcp2515_initEhh+0x94>
    1250:	64 ee       	ldi	r22, 0xE4	; 228
    1252:	72 e0       	ldi	r23, 0x02	; 2
    1254:	82 e8       	ldi	r24, 0x82	; 130
    1256:	95 e0       	ldi	r25, 0x05	; 5
    1258:	0e 94 4b 06 	call	0xc96	; 0xc96 <_ZN5Print5printEPKc>
    125c:	4f 2d       	mov	r20, r15
    125e:	60 2f       	mov	r22, r16
    1260:	ce 01       	movw	r24, r28
    1262:	0e 94 52 08 	call	0x10a4	; 0x10a4 <_ZN7MCP_CAN18mcp2515_configRateEhh>
    1266:	88 23       	and	r24, r24
    1268:	19 f0       	breq	.+6      	; 0x1270 <_ZN7MCP_CAN12mcp2515_initEhh+0x48>
    126a:	62 e0       	ldi	r22, 0x02	; 2
    126c:	73 e0       	ldi	r23, 0x03	; 3
    126e:	26 c0       	rjmp	.+76     	; 0x12bc <_ZN7MCP_CAN12mcp2515_initEhh+0x94>
    1270:	64 e1       	ldi	r22, 0x14	; 20
    1272:	73 e0       	ldi	r23, 0x03	; 3
    1274:	82 e8       	ldi	r24, 0x82	; 130
    1276:	95 e0       	ldi	r25, 0x05	; 5
    1278:	0e 94 4b 06 	call	0xc96	; 0xc96 <_ZN5Print5printEPKc>
    127c:	ce 01       	movw	r24, r28
    127e:	0e 94 ee 08 	call	0x11dc	; 0x11dc <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>
    1282:	43 e0       	ldi	r20, 0x03	; 3
    1284:	6b e2       	ldi	r22, 0x2B	; 43
    1286:	ce 01       	movw	r24, r28
    1288:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    128c:	24 e0       	ldi	r18, 0x04	; 4
    128e:	44 e6       	ldi	r20, 0x64	; 100
    1290:	60 e6       	ldi	r22, 0x60	; 96
    1292:	ce 01       	movw	r24, r28
    1294:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1298:	20 e0       	ldi	r18, 0x00	; 0
    129a:	40 e6       	ldi	r20, 0x60	; 96
    129c:	60 e7       	ldi	r22, 0x70	; 112
    129e:	ce 01       	movw	r24, r28
    12a0:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    12a4:	60 e0       	ldi	r22, 0x00	; 0
    12a6:	ce 01       	movw	r24, r28
    12a8:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    12ac:	18 2f       	mov	r17, r24
    12ae:	88 23       	and	r24, r24
    12b0:	19 f0       	breq	.+6      	; 0x12b8 <_ZN7MCP_CAN12mcp2515_initEhh+0x90>
    12b2:	69 e2       	ldi	r22, 0x29	; 41
    12b4:	73 e0       	ldi	r23, 0x03	; 3
    12b6:	02 c0       	rjmp	.+4      	; 0x12bc <_ZN7MCP_CAN12mcp2515_initEhh+0x94>
    12b8:	64 e4       	ldi	r22, 0x44	; 68
    12ba:	73 e0       	ldi	r23, 0x03	; 3
    12bc:	82 e8       	ldi	r24, 0x82	; 130
    12be:	95 e0       	ldi	r25, 0x05	; 5
    12c0:	0e 94 4b 06 	call	0xc96	; 0xc96 <_ZN5Print5printEPKc>
    12c4:	81 2f       	mov	r24, r17
    12c6:	df 91       	pop	r29
    12c8:	cf 91       	pop	r28
    12ca:	1f 91       	pop	r17
    12cc:	0f 91       	pop	r16
    12ce:	ff 90       	pop	r15
    12d0:	08 95       	ret

000012d2 <_Z17mcp2515_id_to_bufhmPh>:
    12d2:	f9 01       	movw	r30, r18
    12d4:	81 30       	cpi	r24, 0x01	; 1
    12d6:	b1 f4       	brne	.+44     	; 0x1304 <_Z17mcp2515_id_to_bufhmPh+0x32>
    12d8:	43 83       	std	Z+3, r20	; 0x03
    12da:	52 83       	std	Z+2, r21	; 0x02
    12dc:	ab 01       	movw	r20, r22
    12de:	66 27       	eor	r22, r22
    12e0:	77 27       	eor	r23, r23
    12e2:	94 2f       	mov	r25, r20
    12e4:	9c 71       	andi	r25, 0x1C	; 28
    12e6:	84 2f       	mov	r24, r20
    12e8:	83 70       	andi	r24, 0x03	; 3
    12ea:	28 e0       	ldi	r18, 0x08	; 8
    12ec:	92 9f       	mul	r25, r18
    12ee:	80 0d       	add	r24, r0
    12f0:	11 24       	eor	r1, r1
    12f2:	88 60       	ori	r24, 0x08	; 8
    12f4:	81 83       	std	Z+1, r24	; 0x01
    12f6:	65 e0       	ldi	r22, 0x05	; 5
    12f8:	56 95       	lsr	r21
    12fa:	47 95       	ror	r20
    12fc:	6a 95       	dec	r22
    12fe:	e1 f7       	brne	.-8      	; 0x12f8 <_Z17mcp2515_id_to_bufhmPh+0x26>
    1300:	40 83       	st	Z, r20
    1302:	08 95       	ret
    1304:	ca 01       	movw	r24, r20
    1306:	23 e0       	ldi	r18, 0x03	; 3
    1308:	96 95       	lsr	r25
    130a:	87 95       	ror	r24
    130c:	2a 95       	dec	r18
    130e:	e1 f7       	brne	.-8      	; 0x1308 <_Z17mcp2515_id_to_bufhmPh+0x36>
    1310:	80 83       	st	Z, r24
    1312:	42 95       	swap	r20
    1314:	44 0f       	add	r20, r20
    1316:	40 7e       	andi	r20, 0xE0	; 224
    1318:	41 83       	std	Z+1, r20	; 0x01
    131a:	13 82       	std	Z+3, r1	; 0x03
    131c:	12 82       	std	Z+2, r1	; 0x02
    131e:	08 95       	ret

00001320 <_ZN7MCP_CAN22mcp2515_start_transmitEh>:
    1320:	1f 93       	push	r17
    1322:	cf 93       	push	r28
    1324:	df 93       	push	r29
    1326:	ec 01       	movw	r28, r24
    1328:	16 2f       	mov	r17, r22
    132a:	80 e5       	ldi	r24, 0x50	; 80
    132c:	91 e0       	ldi	r25, 0x01	; 1
    132e:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
    1332:	60 e0       	ldi	r22, 0x00	; 0
    1334:	8e 81       	ldd	r24, Y+6	; 0x06
    1336:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
    133a:	81 2f       	mov	r24, r17
    133c:	0e 94 78 07 	call	0xef0	; 0xef0 <_Z11txSidhToRTSh>
    1340:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    1344:	61 e0       	ldi	r22, 0x01	; 1
    1346:	8e 81       	ldd	r24, Y+6	; 0x06
    1348:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
    134c:	df 91       	pop	r29
    134e:	cf 91       	pop	r28
    1350:	1f 91       	pop	r17
    1352:	0c 94 67 07 	jmp	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>

00001356 <_ZN7MCP_CAN20mcp2515_write_canMsgEhmhhhPVKh>:
    1356:	4f 92       	push	r4
    1358:	5f 92       	push	r5
    135a:	6f 92       	push	r6
    135c:	7f 92       	push	r7
    135e:	8f 92       	push	r8
    1360:	9f 92       	push	r9
    1362:	af 92       	push	r10
    1364:	bf 92       	push	r11
    1366:	cf 92       	push	r12
    1368:	df 92       	push	r13
    136a:	ef 92       	push	r14
    136c:	ff 92       	push	r15
    136e:	0f 93       	push	r16
    1370:	1f 93       	push	r17
    1372:	cf 93       	push	r28
    1374:	df 93       	push	r29
    1376:	00 d0       	rcall	.+0      	; 0x1378 <_ZN7MCP_CAN20mcp2515_write_canMsgEhmhhhPVKh+0x22>
    1378:	00 d0       	rcall	.+0      	; 0x137a <_ZN7MCP_CAN20mcp2515_write_canMsgEhmhhhPVKh+0x24>
    137a:	cd b7       	in	r28, 0x3d	; 61
    137c:	de b7       	in	r29, 0x3e	; 62
    137e:	4c 01       	movw	r8, r24
    1380:	d6 2e       	mov	r13, r22
    1382:	29 01       	movw	r4, r18
    1384:	3a 01       	movw	r6, r20
    1386:	86 2f       	mov	r24, r22
    1388:	0e 94 86 07 	call	0xf0c	; 0xf0c <_Z14txSidhToTxLoadh>
    138c:	18 2f       	mov	r17, r24
    138e:	e1 10       	cpse	r14, r1
    1390:	02 c0       	rjmp	.+4      	; 0x1396 <_ZN7MCP_CAN20mcp2515_write_canMsgEhmhhhPVKh+0x40>
    1392:	f1 2c       	mov	r15, r1
    1394:	02 c0       	rjmp	.+4      	; 0x139a <_ZN7MCP_CAN20mcp2515_write_canMsgEhmhhhPVKh+0x44>
    1396:	80 e4       	ldi	r24, 0x40	; 64
    1398:	f8 2e       	mov	r15, r24
    139a:	9e 01       	movw	r18, r28
    139c:	2f 5f       	subi	r18, 0xFF	; 255
    139e:	3f 4f       	sbci	r19, 0xFF	; 255
    13a0:	b3 01       	movw	r22, r6
    13a2:	a2 01       	movw	r20, r4
    13a4:	80 2f       	mov	r24, r16
    13a6:	0e 94 69 09 	call	0x12d2	; 0x12d2 <_Z17mcp2515_id_to_bufhmPh>
    13aa:	80 e5       	ldi	r24, 0x50	; 80
    13ac:	91 e0       	ldi	r25, 0x01	; 1
    13ae:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
    13b2:	60 e0       	ldi	r22, 0x00	; 0
    13b4:	f4 01       	movw	r30, r8
    13b6:	86 81       	ldd	r24, Z+6	; 0x06
    13b8:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
    13bc:	81 2f       	mov	r24, r17
    13be:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    13c2:	8e 01       	movw	r16, r28
    13c4:	0f 5f       	subi	r16, 0xFF	; 255
    13c6:	1f 4f       	sbci	r17, 0xFF	; 255
    13c8:	3e 01       	movw	r6, r28
    13ca:	f5 e0       	ldi	r31, 0x05	; 5
    13cc:	6f 0e       	add	r6, r31
    13ce:	71 1c       	adc	r7, r1
    13d0:	f8 01       	movw	r30, r16
    13d2:	81 91       	ld	r24, Z+
    13d4:	8f 01       	movw	r16, r30
    13d6:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    13da:	06 15       	cp	r16, r6
    13dc:	17 05       	cpc	r17, r7
    13de:	c1 f7       	brne	.-16     	; 0x13d0 <_ZN7MCP_CAN20mcp2515_write_canMsgEhmhhhPVKh+0x7a>
    13e0:	8c 2d       	mov	r24, r12
    13e2:	8f 29       	or	r24, r15
    13e4:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    13e8:	75 01       	movw	r14, r10
    13ea:	10 e0       	ldi	r17, 0x00	; 0
    13ec:	1c 15       	cp	r17, r12
    13ee:	49 f0       	breq	.+18     	; 0x1402 <_ZN7MCP_CAN20mcp2515_write_canMsgEhmhhhPVKh+0xac>
    13f0:	18 30       	cpi	r17, 0x08	; 8
    13f2:	39 f0       	breq	.+14     	; 0x1402 <_ZN7MCP_CAN20mcp2515_write_canMsgEhmhhhPVKh+0xac>
    13f4:	f7 01       	movw	r30, r14
    13f6:	81 91       	ld	r24, Z+
    13f8:	7f 01       	movw	r14, r30
    13fa:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    13fe:	1f 5f       	subi	r17, 0xFF	; 255
    1400:	f5 cf       	rjmp	.-22     	; 0x13ec <_ZN7MCP_CAN20mcp2515_write_canMsgEhmhhhPVKh+0x96>
    1402:	61 e0       	ldi	r22, 0x01	; 1
    1404:	f4 01       	movw	r30, r8
    1406:	86 81       	ldd	r24, Z+6	; 0x06
    1408:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
    140c:	0e 94 67 07 	call	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>
    1410:	6d 2d       	mov	r22, r13
    1412:	c4 01       	movw	r24, r8
    1414:	0e 94 90 09 	call	0x1320	; 0x1320 <_ZN7MCP_CAN22mcp2515_start_transmitEh>
    1418:	0f 90       	pop	r0
    141a:	0f 90       	pop	r0
    141c:	0f 90       	pop	r0
    141e:	0f 90       	pop	r0
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	1f 91       	pop	r17
    1426:	0f 91       	pop	r16
    1428:	ff 90       	pop	r15
    142a:	ef 90       	pop	r14
    142c:	df 90       	pop	r13
    142e:	cf 90       	pop	r12
    1430:	bf 90       	pop	r11
    1432:	af 90       	pop	r10
    1434:	9f 90       	pop	r9
    1436:	8f 90       	pop	r8
    1438:	7f 90       	pop	r7
    143a:	6f 90       	pop	r6
    143c:	5f 90       	pop	r5
    143e:	4f 90       	pop	r4
    1440:	08 95       	ret

00001442 <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh>:
    1442:	ef 92       	push	r14
    1444:	ff 92       	push	r15
    1446:	0f 93       	push	r16
    1448:	1f 93       	push	r17
    144a:	cf 93       	push	r28
    144c:	8c 01       	movw	r16, r24
    144e:	7b 01       	movw	r14, r22
    1450:	0e 94 1c 08 	call	0x1038	; 0x1038 <_ZN7MCP_CAN18mcp2515_readStatusEv>
    1454:	84 75       	andi	r24, 0x54	; 84
    1456:	f7 01       	movw	r30, r14
    1458:	10 82       	st	Z, r1
    145a:	84 35       	cpi	r24, 0x54	; 84
    145c:	91 f1       	breq	.+100    	; 0x14c2 <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x80>
    145e:	f8 01       	movw	r30, r16
    1460:	91 85       	ldd	r25, Z+9	; 0x09
    1462:	43 e0       	ldi	r20, 0x03	; 3
    1464:	50 e0       	ldi	r21, 0x00	; 0
    1466:	49 1b       	sub	r20, r25
    1468:	51 09       	sbc	r21, r1
    146a:	eb e1       	ldi	r30, 0x1B	; 27
    146c:	f4 e0       	ldi	r31, 0x04	; 4
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	29 2f       	mov	r18, r25
    1472:	30 e0       	ldi	r19, 0x00	; 0
    1474:	24 17       	cp	r18, r20
    1476:	35 07       	cpc	r19, r21
    1478:	24 f5       	brge	.+72     	; 0x14c2 <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x80>
    147a:	93 30       	cpi	r25, 0x03	; 3
    147c:	10 f4       	brcc	.+4      	; 0x1482 <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x40>
    147e:	c0 81       	ld	r28, Z
    1480:	01 c0       	rjmp	.+2      	; 0x1484 <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x42>
    1482:	cf ef       	ldi	r28, 0xFF	; 255
    1484:	c8 23       	and	r28, r24
    1486:	31 96       	adiw	r30, 0x01	; 1
    1488:	c1 11       	cpse	r28, r1
    148a:	19 c0       	rjmp	.+50     	; 0x14be <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x7c>
    148c:	93 30       	cpi	r25, 0x03	; 3
    148e:	28 f4       	brcc	.+10     	; 0x149a <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x58>
    1490:	f9 01       	movw	r30, r18
    1492:	ef 5d       	subi	r30, 0xDF	; 223
    1494:	fb 4f       	sbci	r31, 0xFB	; 251
    1496:	80 81       	ld	r24, Z
    1498:	01 c0       	rjmp	.+2      	; 0x149c <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x5a>
    149a:	80 e5       	ldi	r24, 0x50	; 80
    149c:	8f 5f       	subi	r24, 0xFF	; 255
    149e:	f7 01       	movw	r30, r14
    14a0:	80 83       	st	Z, r24
    14a2:	93 30       	cpi	r25, 0x03	; 3
    14a4:	28 f4       	brcc	.+10     	; 0x14b0 <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x6e>
    14a6:	f9 01       	movw	r30, r18
    14a8:	e2 5e       	subi	r30, 0xE2	; 226
    14aa:	fb 4f       	sbci	r31, 0xFB	; 251
    14ac:	40 81       	ld	r20, Z
    14ae:	01 c0       	rjmp	.+2      	; 0x14b2 <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x70>
    14b0:	40 e0       	ldi	r20, 0x00	; 0
    14b2:	20 e0       	ldi	r18, 0x00	; 0
    14b4:	6c e2       	ldi	r22, 0x2C	; 44
    14b6:	c8 01       	movw	r24, r16
    14b8:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    14bc:	03 c0       	rjmp	.+6      	; 0x14c4 <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x82>
    14be:	9f 5f       	subi	r25, 0xFF	; 255
    14c0:	d7 cf       	rjmp	.-82     	; 0x1470 <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh+0x2e>
    14c2:	c2 e0       	ldi	r28, 0x02	; 2
    14c4:	8c 2f       	mov	r24, r28
    14c6:	cf 91       	pop	r28
    14c8:	1f 91       	pop	r17
    14ca:	0f 91       	pop	r16
    14cc:	ff 90       	pop	r15
    14ce:	ef 90       	pop	r14
    14d0:	08 95       	ret

000014d2 <_ZN7MCP_CAN7init_CSEh>:
    14d2:	cf 93       	push	r28
    14d4:	df 93       	push	r29
    14d6:	ec 01       	movw	r28, r24
    14d8:	66 23       	and	r22, r22
    14da:	59 f0       	breq	.+22     	; 0x14f2 <_ZN7MCP_CAN7init_CSEh+0x20>
    14dc:	86 2f       	mov	r24, r22
    14de:	6e 83       	std	Y+6, r22	; 0x06
    14e0:	61 e0       	ldi	r22, 0x01	; 1
    14e2:	0e 94 b6 18 	call	0x316c	; 0x316c <pinMode>
    14e6:	61 e0       	ldi	r22, 0x01	; 1
    14e8:	8e 81       	ldd	r24, Y+6	; 0x06
    14ea:	df 91       	pop	r29
    14ec:	cf 91       	pop	r28
    14ee:	0c 94 f2 18 	jmp	0x31e4	; 0x31e4 <digitalWrite>
    14f2:	df 91       	pop	r29
    14f4:	cf 91       	pop	r28
    14f6:	08 95       	ret

000014f8 <_ZN7MCP_CANC1Eh>:
    14f8:	fc 01       	movw	r30, r24
    14fa:	11 86       	std	Z+9, r1	; 0x09
    14fc:	2c e2       	ldi	r18, 0x2C	; 44
    14fe:	36 e0       	ldi	r19, 0x06	; 6
    1500:	30 87       	std	Z+8, r19	; 0x08
    1502:	27 83       	std	Z+7, r18	; 0x07
    1504:	0c 94 69 0a 	jmp	0x14d2	; 0x14d2 <_ZN7MCP_CAN7init_CSEh>

00001508 <_ZN7MCP_CAN5beginEhh>:
    1508:	0f 93       	push	r16
    150a:	1f 93       	push	r17
    150c:	cf 93       	push	r28
    150e:	df 93       	push	r29
    1510:	ec 01       	movw	r28, r24
    1512:	16 2f       	mov	r17, r22
    1514:	04 2f       	mov	r16, r20
    1516:	0e 94 23 0b 	call	0x1646	; 0x1646 <_ZN8SPIClass5beginEv>
    151a:	40 2f       	mov	r20, r16
    151c:	61 2f       	mov	r22, r17
    151e:	ce 01       	movw	r24, r28
    1520:	0e 94 14 09 	call	0x1228	; 0x1228 <_ZN7MCP_CAN12mcp2515_initEhh>
    1524:	91 e0       	ldi	r25, 0x01	; 1
    1526:	81 11       	cpse	r24, r1
    1528:	01 c0       	rjmp	.+2      	; 0x152c <_ZN7MCP_CAN5beginEhh+0x24>
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	89 2f       	mov	r24, r25
    152e:	df 91       	pop	r29
    1530:	cf 91       	pop	r28
    1532:	1f 91       	pop	r17
    1534:	0f 91       	pop	r16
    1536:	08 95       	ret

00001538 <_ZN7MCP_CAN7sendMsgEmhhhPKhb>:
    1538:	2f 92       	push	r2
    153a:	3f 92       	push	r3
    153c:	4f 92       	push	r4
    153e:	5f 92       	push	r5
    1540:	6f 92       	push	r6
    1542:	7f 92       	push	r7
    1544:	8f 92       	push	r8
    1546:	9f 92       	push	r9
    1548:	af 92       	push	r10
    154a:	bf 92       	push	r11
    154c:	cf 92       	push	r12
    154e:	df 92       	push	r13
    1550:	ef 92       	push	r14
    1552:	ff 92       	push	r15
    1554:	0f 93       	push	r16
    1556:	1f 93       	push	r17
    1558:	cf 93       	push	r28
    155a:	df 93       	push	r29
    155c:	1f 92       	push	r1
    155e:	cd b7       	in	r28, 0x3d	; 61
    1560:	de b7       	in	r29, 0x3e	; 62
    1562:	4c 01       	movw	r8, r24
    1564:	2a 01       	movw	r4, r20
    1566:	3b 01       	movw	r6, r22
    1568:	22 2e       	mov	r2, r18
    156a:	30 2e       	mov	r3, r16
    156c:	fa 2c       	mov	r15, r10
    156e:	fc 01       	movw	r30, r24
    1570:	41 83       	std	Z+1, r20	; 0x01
    1572:	52 83       	std	Z+2, r21	; 0x02
    1574:	63 83       	std	Z+3, r22	; 0x03
    1576:	74 83       	std	Z+4, r23	; 0x04
    1578:	20 83       	st	Z, r18
    157a:	05 83       	std	Z+5, r16	; 0x05
    157c:	00 e0       	ldi	r16, 0x00	; 0
    157e:	10 e0       	ldi	r17, 0x00	; 0
    1580:	be 01       	movw	r22, r28
    1582:	6f 5f       	subi	r22, 0xFF	; 255
    1584:	7f 4f       	sbci	r23, 0xFF	; 255
    1586:	c4 01       	movw	r24, r8
    1588:	0e 94 21 0a 	call	0x1442	; 0x1442 <_ZN7MCP_CAN24mcp2515_getNextFreeTXBufEPh>
    158c:	0f 5f       	subi	r16, 0xFF	; 255
    158e:	1f 4f       	sbci	r17, 0xFF	; 255
    1590:	82 30       	cpi	r24, 0x02	; 2
    1592:	41 f4       	brne	.+16     	; 0x15a4 <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0x6c>
    1594:	02 33       	cpi	r16, 0x32	; 50
    1596:	11 05       	cpc	r17, r1
    1598:	61 f1       	breq	.+88     	; 0x15f2 <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0xba>
    159a:	8a e0       	ldi	r24, 0x0A	; 10
    159c:	90 e0       	ldi	r25, 0x00	; 0
    159e:	0e 94 1a 07 	call	0xe34	; 0xe34 <delayMicroseconds>
    15a2:	ee cf       	rjmp	.-36     	; 0x1580 <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0x48>
    15a4:	02 33       	cpi	r16, 0x32	; 50
    15a6:	11 05       	cpc	r17, r1
    15a8:	21 f1       	breq	.+72     	; 0x15f2 <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0xba>
    15aa:	56 01       	movw	r10, r12
    15ac:	ce 2c       	mov	r12, r14
    15ae:	e3 2c       	mov	r14, r3
    15b0:	02 2d       	mov	r16, r2
    15b2:	a3 01       	movw	r20, r6
    15b4:	92 01       	movw	r18, r4
    15b6:	69 81       	ldd	r22, Y+1	; 0x01
    15b8:	c4 01       	movw	r24, r8
    15ba:	0e 94 ab 09 	call	0x1356	; 0x1356 <_ZN7MCP_CAN20mcp2515_write_canMsgEhmhhhPVKh>
    15be:	ff 20       	and	r15, r15
    15c0:	b1 f0       	breq	.+44     	; 0x15ee <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0xb6>
    15c2:	00 e0       	ldi	r16, 0x00	; 0
    15c4:	10 e0       	ldi	r17, 0x00	; 0
    15c6:	0f 5f       	subi	r16, 0xFF	; 255
    15c8:	1f 4f       	sbci	r17, 0xFF	; 255
    15ca:	69 81       	ldd	r22, Y+1	; 0x01
    15cc:	61 50       	subi	r22, 0x01	; 1
    15ce:	c4 01       	movw	r24, r8
    15d0:	0e 94 b0 07 	call	0xf60	; 0xf60 <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    15d4:	83 ff       	sbrs	r24, 3
    15d6:	08 c0       	rjmp	.+16     	; 0x15e8 <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0xb0>
    15d8:	02 33       	cpi	r16, 0x32	; 50
    15da:	11 05       	cpc	r17, r1
    15dc:	61 f0       	breq	.+24     	; 0x15f6 <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0xbe>
    15de:	8a e0       	ldi	r24, 0x0A	; 10
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	0e 94 1a 07 	call	0xe34	; 0xe34 <delayMicroseconds>
    15e6:	ef cf       	rjmp	.-34     	; 0x15c6 <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0x8e>
    15e8:	02 33       	cpi	r16, 0x32	; 50
    15ea:	11 05       	cpc	r17, r1
    15ec:	21 f0       	breq	.+8      	; 0x15f6 <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0xbe>
    15ee:	80 e0       	ldi	r24, 0x00	; 0
    15f0:	03 c0       	rjmp	.+6      	; 0x15f8 <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0xc0>
    15f2:	86 e0       	ldi	r24, 0x06	; 6
    15f4:	01 c0       	rjmp	.+2      	; 0x15f8 <_ZN7MCP_CAN7sendMsgEmhhhPKhb+0xc0>
    15f6:	87 e0       	ldi	r24, 0x07	; 7
    15f8:	0f 90       	pop	r0
    15fa:	df 91       	pop	r29
    15fc:	cf 91       	pop	r28
    15fe:	1f 91       	pop	r17
    1600:	0f 91       	pop	r16
    1602:	ff 90       	pop	r15
    1604:	ef 90       	pop	r14
    1606:	df 90       	pop	r13
    1608:	cf 90       	pop	r12
    160a:	bf 90       	pop	r11
    160c:	af 90       	pop	r10
    160e:	9f 90       	pop	r9
    1610:	8f 90       	pop	r8
    1612:	7f 90       	pop	r7
    1614:	6f 90       	pop	r6
    1616:	5f 90       	pop	r5
    1618:	4f 90       	pop	r4
    161a:	3f 90       	pop	r3
    161c:	2f 90       	pop	r2
    161e:	08 95       	ret

00001620 <_ZN7MCP_CAN10sendMsgBufEmhhPKhb>:
/*********************************************************************************************************
** Function name:           sendMsgBuf
** Descriptions:            send buf
*********************************************************************************************************/
byte MCP_CAN::sendMsgBuf(unsigned long id, byte ext, byte len, const byte *buf, bool wait_sent)
{
    1620:	af 92       	push	r10
    1622:	cf 92       	push	r12
    1624:	df 92       	push	r13
    1626:	ef 92       	push	r14
    1628:	ff 92       	push	r15
    162a:	0f 93       	push	r16
    return sendMsg(id,ext,0,len,buf,wait_sent);
    162c:	ac 2c       	mov	r10, r12
    162e:	67 01       	movw	r12, r14
    1630:	e0 2e       	mov	r14, r16
    1632:	00 e0       	ldi	r16, 0x00	; 0
    1634:	0e 94 9c 0a 	call	0x1538	; 0x1538 <_ZN7MCP_CAN7sendMsgEmhhhPKhb>
}
    1638:	0f 91       	pop	r16
    163a:	ff 90       	pop	r15
    163c:	ef 90       	pop	r14
    163e:	df 90       	pop	r13
    1640:	cf 90       	pop	r12
    1642:	af 90       	pop	r10
    1644:	08 95       	ret

00001646 <_ZN8SPIClass5beginEv>:
#ifdef SPI_TRANSACTION_MISMATCH_LED
uint8_t SPIClass::inTransactionFlag = 0;
#endif

void SPIClass::begin()
{
    1646:	cf 93       	push	r28
  uint8_t sreg = SREG;
    1648:	cf b7       	in	r28, 0x3f	; 63
  noInterrupts(); // Protect from a scheduler and prevent transactionBegin
    164a:	f8 94       	cli
  if (!initialized) {
    164c:	80 91 2b 06 	lds	r24, 0x062B	; 0x80062b <_ZN8SPIClass11initializedE>
    1650:	81 11       	cpse	r24, r1
    1652:	27 c0       	rjmp	.+78     	; 0x16a2 <_ZN8SPIClass5beginEv+0x5c>
    // Set SS to high so a connected chip will be "deselected" by default
    uint8_t port = digitalPinToPort(SS);
    1654:	ed e6       	ldi	r30, 0x6D	; 109
    1656:	f1 e0       	ldi	r31, 0x01	; 1
    1658:	84 91       	lpm	r24, Z
    uint8_t bit = digitalPinToBitMask(SS);
    165a:	e9 e5       	ldi	r30, 0x59	; 89
    165c:	f1 e0       	ldi	r31, 0x01	; 1
    165e:	94 91       	lpm	r25, Z
    volatile uint8_t *reg = portModeRegister(port);
    1660:	e8 2f       	mov	r30, r24
    1662:	f0 e0       	ldi	r31, 0x00	; 0
    1664:	ee 0f       	add	r30, r30
    1666:	ff 1f       	adc	r31, r31
    1668:	ef 57       	subi	r30, 0x7F	; 127
    166a:	fe 4f       	sbci	r31, 0xFE	; 254
    166c:	a5 91       	lpm	r26, Z+
    166e:	b4 91       	lpm	r27, Z

    // if the SS pin is not already configured as an output
    // then set it high (to enable the internal pull-up resistor)
    if(!(*reg & bit)){
    1670:	ec 91       	ld	r30, X
    1672:	e9 23       	and	r30, r25
    1674:	21 f4       	brne	.+8      	; 0x167e <_ZN8SPIClass5beginEv+0x38>
      digitalWrite(SS, HIGH);
    1676:	61 e0       	ldi	r22, 0x01	; 1
    1678:	8a e0       	ldi	r24, 0x0A	; 10
    167a:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <digitalWrite>
    }

    // When the SS pin is set as OUTPUT, it can be used as
    // a general purpose output port (it doesn't influence
    // SPI operations).
    pinMode(SS, OUTPUT);
    167e:	61 e0       	ldi	r22, 0x01	; 1
    1680:	8a e0       	ldi	r24, 0x0A	; 10
    1682:	0e 94 b6 18 	call	0x316c	; 0x316c <pinMode>

    // Warning: if the SS pin ever becomes a LOW INPUT then SPI
    // automatically switches to Slave, so the data direction of
    // the SS pin MUST be kept as OUTPUT.
    SPCR |= _BV(MSTR);
    1686:	8c b5       	in	r24, 0x2c	; 44
    1688:	80 61       	ori	r24, 0x10	; 16
    168a:	8c bd       	out	0x2c, r24	; 44
    SPCR |= _BV(SPE);
    168c:	8c b5       	in	r24, 0x2c	; 44
    168e:	80 64       	ori	r24, 0x40	; 64
    1690:	8c bd       	out	0x2c, r24	; 44
    // MISO pin automatically overrides to INPUT.
    // By doing this AFTER enabling SPI, we avoid accidentally
    // clocking in a single bit since the lines go directly
    // from "input" to SPI control.
    // http://code.google.com/p/arduino/issues/detail?id=888
    pinMode(SCK, OUTPUT);
    1692:	61 e0       	ldi	r22, 0x01	; 1
    1694:	8d e0       	ldi	r24, 0x0D	; 13
    1696:	0e 94 b6 18 	call	0x316c	; 0x316c <pinMode>
    pinMode(MOSI, OUTPUT);
    169a:	61 e0       	ldi	r22, 0x01	; 1
    169c:	8b e0       	ldi	r24, 0x0B	; 11
    169e:	0e 94 b6 18 	call	0x316c	; 0x316c <pinMode>
  }
  initialized++; // reference count
    16a2:	80 91 2b 06 	lds	r24, 0x062B	; 0x80062b <_ZN8SPIClass11initializedE>
    16a6:	8f 5f       	subi	r24, 0xFF	; 255
    16a8:	80 93 2b 06 	sts	0x062B, r24	; 0x80062b <_ZN8SPIClass11initializedE>
  SREG = sreg;
    16ac:	cf bf       	out	0x3f, r28	; 63
}
    16ae:	cf 91       	pop	r28
    16b0:	08 95       	ret

000016b2 <_ZN15USBDeviceConfig15ConfigureDeviceEhhb>:
                pUsb->ctrlReq(bAddress, epInfo[PS3_CONTROL_PIPE].epAddr, bmREQ_HID_IN, HID_REQUEST_GET_REPORT, 0x10, 0x03, 0x00, 49, 49, buf, NULL);

                for(uint8_t j = 0; j < 49; j++)
                        data[49 * i + j] = buf[j];
        }
}
    16b2:	80 e0       	ldi	r24, 0x00	; 0
    16b4:	08 95       	ret

000016b6 <_ZN15USBDeviceConfig12ResetHubPortEh>:
    16b6:	08 95       	ret

000016b8 <_ZN15USBDeviceConfig10DEVCLASSOKEh>:
    16b8:	80 e0       	ldi	r24, 0x00	; 0
    16ba:	08 95       	ret

000016bc <_ZN15USBDeviceConfig13DEVSUBCLASSOKEh>:
    16bc:	81 e0       	ldi	r24, 0x01	; 1
    16be:	08 95       	ret

000016c0 <_ZN6PS3USB10GetAddressEv>:
    16c0:	fc 01       	movw	r30, r24
    16c2:	87 81       	ldd	r24, Z+7	; 0x07
    16c4:	08 95       	ret

000016c6 <_ZN6PS3USB7isReadyEv>:
    16c6:	fc 01       	movw	r30, r24
    16c8:	83 89       	ldd	r24, Z+19	; 0x13
    16ca:	08 95       	ret

000016cc <_ZN6PS3USB8VIDPIDOKEjj>:
    16cc:	6c 34       	cpi	r22, 0x4C	; 76
    16ce:	75 40       	sbci	r23, 0x05	; 5
    16d0:	61 f4       	brne	.+24     	; 0x16ea <_ZN6PS3USB8VIDPIDOKEjj+0x1e>
    16d2:	48 36       	cpi	r20, 0x68	; 104
    16d4:	92 e0       	ldi	r25, 0x02	; 2
    16d6:	59 07       	cpc	r21, r25
    16d8:	51 f0       	breq	.+20     	; 0x16ee <_ZN6PS3USB8VIDPIDOKEjj+0x22>
    16da:	4f 32       	cpi	r20, 0x2F	; 47
    16dc:	84 e0       	ldi	r24, 0x04	; 4
    16de:	58 07       	cpc	r21, r24
    16e0:	31 f0       	breq	.+12     	; 0x16ee <_ZN6PS3USB8VIDPIDOKEjj+0x22>
    16e2:	81 e0       	ldi	r24, 0x01	; 1
    16e4:	45 3d       	cpi	r20, 0xD5	; 213
    16e6:	53 40       	sbci	r21, 0x03	; 3
    16e8:	19 f0       	breq	.+6      	; 0x16f0 <_ZN6PS3USB8VIDPIDOKEjj+0x24>
    16ea:	80 e0       	ldi	r24, 0x00	; 0
    16ec:	08 95       	ret
    16ee:	81 e0       	ldi	r24, 0x01	; 1
    16f0:	08 95       	ret

000016f2 <_ZN6PS3USB7ReleaseEv>:
    16f2:	cf 93       	push	r28
    16f4:	df 93       	push	r29
    16f6:	ec 01       	movw	r28, r24
    16f8:	1a 82       	std	Y+2, r1	; 0x02
    16fa:	1b 82       	std	Y+3, r1	; 0x03
    16fc:	1c 82       	std	Y+4, r1	; 0x04
    16fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1700:	9e 81       	ldd	r25, Y+6	; 0x06
    1702:	dc 01       	movw	r26, r24
    1704:	ed 91       	ld	r30, X+
    1706:	fc 91       	ld	r31, X
    1708:	04 80       	ldd	r0, Z+4	; 0x04
    170a:	f5 81       	ldd	r31, Z+5	; 0x05
    170c:	e0 2d       	mov	r30, r0
    170e:	6f 81       	ldd	r22, Y+7	; 0x07
    1710:	09 95       	icall
    1712:	1f 82       	std	Y+7, r1	; 0x07
    1714:	1b 8a       	std	Y+19, r1	; 0x13
    1716:	80 e0       	ldi	r24, 0x00	; 0
    1718:	df 91       	pop	r29
    171a:	cf 91       	pop	r28
    171c:	08 95       	ret

0000171e <_ZN6PS3USBC1EP3USBhhhhhh>:
    171e:	af 92       	push	r10
    1720:	cf 92       	push	r12
    1722:	ef 92       	push	r14
    1724:	0f 93       	push	r16
    1726:	cf 93       	push	r28
    1728:	df 93       	push	r29
    172a:	fc 01       	movw	r30, r24
    172c:	88 e2       	ldi	r24, 0x28	; 40
    172e:	94 e0       	ldi	r25, 0x04	; 4
    1730:	91 83       	std	Z+1, r25	; 0x01
    1732:	80 83       	st	Z, r24
    1734:	76 83       	std	Z+6, r23	; 0x06
    1736:	65 83       	std	Z+5, r22	; 0x05
    1738:	17 82       	std	Z+7, r1	; 0x07
    173a:	13 8a       	std	Z+19, r1	; 0x13
    173c:	10 86       	std	Z+8, r1	; 0x08
    173e:	88 e0       	ldi	r24, 0x08	; 8
    1740:	81 87       	std	Z+9, r24	; 0x09
    1742:	8c e3       	ldi	r24, 0x3C	; 60
    1744:	82 87       	std	Z+10, r24	; 0x0a
    1746:	13 86       	std	Z+11, r1	; 0x0b
    1748:	14 86       	std	Z+12, r1	; 0x0c
    174a:	84 e0       	ldi	r24, 0x04	; 4
    174c:	85 87       	std	Z+13, r24	; 0x0d
    174e:	16 86       	std	Z+14, r1	; 0x0e
    1750:	17 86       	std	Z+15, r1	; 0x0f
    1752:	80 8b       	std	Z+16, r24	; 0x10
    1754:	61 15       	cp	r22, r1
    1756:	71 05       	cpc	r23, r1
    1758:	b1 f0       	breq	.+44     	; 0x1786 <_ZN6PS3USBC1EP3USBhhhhhh+0x68>
    175a:	db 01       	movw	r26, r22
    175c:	aa 5a       	subi	r26, 0xAA	; 170
    175e:	bf 4f       	sbci	r27, 0xFF	; 255
    1760:	80 e0       	ldi	r24, 0x00	; 0
    1762:	90 e0       	ldi	r25, 0x00	; 0
    1764:	cd 91       	ld	r28, X+
    1766:	dd 91       	ld	r29, X+
    1768:	cd 2b       	or	r28, r29
    176a:	49 f4       	brne	.+18     	; 0x177e <_ZN6PS3USBC1EP3USBhhhhhh+0x60>
    176c:	8b 96       	adiw	r24, 0x2b	; 43
    176e:	88 0f       	add	r24, r24
    1770:	99 1f       	adc	r25, r25
    1772:	db 01       	movw	r26, r22
    1774:	a8 0f       	add	r26, r24
    1776:	b9 1f       	adc	r27, r25
    1778:	ed 93       	st	X+, r30
    177a:	fc 93       	st	X, r31
    177c:	04 c0       	rjmp	.+8      	; 0x1786 <_ZN6PS3USBC1EP3USBhhhhhh+0x68>
    177e:	01 96       	adiw	r24, 0x01	; 1
    1780:	80 31       	cpi	r24, 0x10	; 16
    1782:	91 05       	cpc	r25, r1
    1784:	79 f7       	brne	.-34     	; 0x1764 <_ZN6PS3USBC1EP3USBhhhhhh+0x46>
    1786:	41 a7       	std	Z+41, r20	; 0x29
    1788:	20 a7       	std	Z+40, r18	; 0x28
    178a:	07 a3       	std	Z+39, r16	; 0x27
    178c:	e6 a2       	std	Z+38, r14	; 0x26
    178e:	c5 a2       	std	Z+37, r12	; 0x25
    1790:	a4 a2       	std	Z+36, r10	; 0x24
    1792:	df 91       	pop	r29
    1794:	cf 91       	pop	r28
    1796:	0f 91       	pop	r16
    1798:	ef 90       	pop	r14
    179a:	cf 90       	pop	r12
    179c:	af 90       	pop	r10
    179e:	08 95       	ret

000017a0 <_ZN6PS3USB10readReportEv>:
    17a0:	fc 01       	movw	r30, r24
    17a2:	86 a5       	ldd	r24, Z+46	; 0x2e
    17a4:	44 a5       	ldd	r20, Z+44	; 0x2c
    17a6:	55 a5       	ldd	r21, Z+45	; 0x2d
    17a8:	60 e0       	ldi	r22, 0x00	; 0
    17aa:	70 e0       	ldi	r23, 0x00	; 0
    17ac:	68 2b       	or	r22, r24
    17ae:	40 8f       	std	Z+24, r20	; 0x18
    17b0:	51 8f       	std	Z+25, r21	; 0x19
    17b2:	62 8f       	std	Z+26, r22	; 0x1a
    17b4:	73 8f       	std	Z+27, r23	; 0x1b
    17b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    17b8:	95 8d       	ldd	r25, Z+29	; 0x1d
    17ba:	a6 8d       	ldd	r26, Z+30	; 0x1e
    17bc:	b7 8d       	ldd	r27, Z+31	; 0x1f
    17be:	48 17       	cp	r20, r24
    17c0:	59 07       	cpc	r21, r25
    17c2:	6a 07       	cpc	r22, r26
    17c4:	7b 07       	cpc	r23, r27
    17c6:	81 f0       	breq	.+32     	; 0x17e8 <_ZN6PS3USB10readReportEv+0x48>
    17c8:	80 95       	com	r24
    17ca:	90 95       	com	r25
    17cc:	a0 95       	com	r26
    17ce:	b0 95       	com	r27
    17d0:	84 23       	and	r24, r20
    17d2:	95 23       	and	r25, r21
    17d4:	a6 23       	and	r26, r22
    17d6:	b7 23       	and	r27, r23
    17d8:	80 a3       	std	Z+32, r24	; 0x20
    17da:	91 a3       	std	Z+33, r25	; 0x21
    17dc:	a2 a3       	std	Z+34, r26	; 0x22
    17de:	b3 a3       	std	Z+35, r27	; 0x23
    17e0:	44 8f       	std	Z+28, r20	; 0x1c
    17e2:	55 8f       	std	Z+29, r21	; 0x1d
    17e4:	66 8f       	std	Z+30, r22	; 0x1e
    17e6:	77 8f       	std	Z+31, r23	; 0x1f
    17e8:	08 95       	ret

000017ea <_ZN6PS3USB14getButtonPressE10ButtonEnum>:
    17ea:	24 e0       	ldi	r18, 0x04	; 4
    17ec:	62 9f       	mul	r22, r18
    17ee:	f0 01       	movw	r30, r0
    17f0:	11 24       	eor	r1, r1
    17f2:	ec 54       	subi	r30, 0x4C	; 76
    17f4:	ff 4f       	sbci	r31, 0xFF	; 255
    17f6:	45 91       	lpm	r20, Z+
    17f8:	55 91       	lpm	r21, Z+
    17fa:	65 91       	lpm	r22, Z+
    17fc:	74 91       	lpm	r23, Z
    17fe:	fc 01       	movw	r30, r24
    1800:	80 8d       	ldd	r24, Z+24	; 0x18
    1802:	91 8d       	ldd	r25, Z+25	; 0x19
    1804:	a2 8d       	ldd	r26, Z+26	; 0x1a
    1806:	b3 8d       	ldd	r27, Z+27	; 0x1b
    1808:	48 23       	and	r20, r24
    180a:	59 23       	and	r21, r25
    180c:	6a 23       	and	r22, r26
    180e:	7b 23       	and	r23, r27
    1810:	81 e0       	ldi	r24, 0x01	; 1
    1812:	45 2b       	or	r20, r21
    1814:	46 2b       	or	r20, r22
    1816:	47 2b       	or	r20, r23
    1818:	09 f4       	brne	.+2      	; 0x181c <_ZN6PS3USB14getButtonPressE10ButtonEnum+0x32>
    181a:	80 e0       	ldi	r24, 0x00	; 0
    181c:	08 95       	ret

0000181e <_ZN6PS3USB12getAnalogHatE13AnalogHatEnum>:
    181e:	86 0f       	add	r24, r22
    1820:	91 1d       	adc	r25, r1
    1822:	fc 01       	movw	r30, r24
    1824:	80 a9       	ldd	r24, Z+48	; 0x30
    1826:	08 95       	ret

00001828 <_ZN6PS3USB11PS3_CommandEPhj>:
    1828:	8f 92       	push	r8
    182a:	9f 92       	push	r9
    182c:	af 92       	push	r10
    182e:	bf 92       	push	r11
    1830:	cf 92       	push	r12
    1832:	ef 92       	push	r14
    1834:	0f 93       	push	r16
    1836:	fc 01       	movw	r30, r24
    1838:	1f 92       	push	r1
    183a:	1f 92       	push	r1
    183c:	7f 93       	push	r23
    183e:	6f 93       	push	r22
    1840:	5f 93       	push	r21
    1842:	4f 93       	push	r20
    1844:	4a 01       	movw	r8, r20
    1846:	a1 2c       	mov	r10, r1
    1848:	b1 2c       	mov	r11, r1
    184a:	82 e0       	ldi	r24, 0x02	; 2
    184c:	c8 2e       	mov	r12, r24
    184e:	ee 24       	eor	r14, r14
    1850:	e3 94       	inc	r14
    1852:	09 e0       	ldi	r16, 0x09	; 9
    1854:	21 e2       	ldi	r18, 0x21	; 33
    1856:	40 85       	ldd	r20, Z+8	; 0x08
    1858:	67 81       	ldd	r22, Z+7	; 0x07
    185a:	85 81       	ldd	r24, Z+5	; 0x05
    185c:	96 81       	ldd	r25, Z+6	; 0x06
    185e:	0e 94 bc 14 	call	0x2978	; 0x2978 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser>
    1862:	0f 90       	pop	r0
    1864:	0f 90       	pop	r0
    1866:	0f 90       	pop	r0
    1868:	0f 90       	pop	r0
    186a:	0f 90       	pop	r0
    186c:	0f 90       	pop	r0
    186e:	0f 91       	pop	r16
    1870:	ef 90       	pop	r14
    1872:	cf 90       	pop	r12
    1874:	bf 90       	pop	r11
    1876:	af 90       	pop	r10
    1878:	9f 90       	pop	r9
    187a:	8f 90       	pop	r8
    187c:	08 95       	ret

0000187e <_ZN6PS3USB9setBdaddrEPh>:
    187e:	6f 92       	push	r6
    1880:	7f 92       	push	r7
    1882:	8f 92       	push	r8
    1884:	9f 92       	push	r9
    1886:	af 92       	push	r10
    1888:	bf 92       	push	r11
    188a:	cf 92       	push	r12
    188c:	ef 92       	push	r14
    188e:	0f 93       	push	r16
    1890:	cf 93       	push	r28
    1892:	df 93       	push	r29
    1894:	cd b7       	in	r28, 0x3d	; 61
    1896:	de b7       	in	r29, 0x3e	; 62
    1898:	28 97       	sbiw	r28, 0x08	; 8
    189a:	0f b6       	in	r0, 0x3f	; 63
    189c:	f8 94       	cli
    189e:	de bf       	out	0x3e, r29	; 62
    18a0:	0f be       	out	0x3f, r0	; 63
    18a2:	cd bf       	out	0x3d, r28	; 61
    18a4:	3c 01       	movw	r6, r24
    18a6:	81 e0       	ldi	r24, 0x01	; 1
    18a8:	89 83       	std	Y+1, r24	; 0x01
    18aa:	1a 82       	std	Y+2, r1	; 0x02
    18ac:	db 01       	movw	r26, r22
    18ae:	16 96       	adiw	r26, 0x06	; 6
    18b0:	ce 01       	movw	r24, r28
    18b2:	03 96       	adiw	r24, 0x03	; 3
    18b4:	2e 91       	ld	r18, -X
    18b6:	fc 01       	movw	r30, r24
    18b8:	21 93       	st	Z+, r18
    18ba:	cf 01       	movw	r24, r30
    18bc:	a6 17       	cp	r26, r22
    18be:	b7 07       	cpc	r27, r23
    18c0:	c9 f7       	brne	.-14     	; 0x18b4 <_ZN6PS3USB9setBdaddrEPh+0x36>
    18c2:	1f 92       	push	r1
    18c4:	1f 92       	push	r1
    18c6:	ce 01       	movw	r24, r28
    18c8:	01 96       	adiw	r24, 0x01	; 1
    18ca:	9f 93       	push	r25
    18cc:	8f 93       	push	r24
    18ce:	1f 92       	push	r1
    18d0:	88 e0       	ldi	r24, 0x08	; 8
    18d2:	8f 93       	push	r24
    18d4:	88 e0       	ldi	r24, 0x08	; 8
    18d6:	88 2e       	mov	r8, r24
    18d8:	91 2c       	mov	r9, r1
    18da:	a1 2c       	mov	r10, r1
    18dc:	b1 2c       	mov	r11, r1
    18de:	93 e0       	ldi	r25, 0x03	; 3
    18e0:	c9 2e       	mov	r12, r25
    18e2:	25 ef       	ldi	r18, 0xF5	; 245
    18e4:	e2 2e       	mov	r14, r18
    18e6:	09 e0       	ldi	r16, 0x09	; 9
    18e8:	21 e2       	ldi	r18, 0x21	; 33
    18ea:	f3 01       	movw	r30, r6
    18ec:	40 85       	ldd	r20, Z+8	; 0x08
    18ee:	67 81       	ldd	r22, Z+7	; 0x07
    18f0:	85 81       	ldd	r24, Z+5	; 0x05
    18f2:	96 81       	ldd	r25, Z+6	; 0x06
    18f4:	0e 94 bc 14 	call	0x2978	; 0x2978 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser>
    18f8:	0f 90       	pop	r0
    18fa:	0f 90       	pop	r0
    18fc:	0f 90       	pop	r0
    18fe:	0f 90       	pop	r0
    1900:	0f 90       	pop	r0
    1902:	0f 90       	pop	r0
    1904:	28 96       	adiw	r28, 0x08	; 8
    1906:	0f b6       	in	r0, 0x3f	; 63
    1908:	f8 94       	cli
    190a:	de bf       	out	0x3e, r29	; 62
    190c:	0f be       	out	0x3f, r0	; 63
    190e:	cd bf       	out	0x3d, r28	; 61
    1910:	df 91       	pop	r29
    1912:	cf 91       	pop	r28
    1914:	0f 91       	pop	r16
    1916:	ef 90       	pop	r14
    1918:	cf 90       	pop	r12
    191a:	bf 90       	pop	r11
    191c:	af 90       	pop	r10
    191e:	9f 90       	pop	r9
    1920:	8f 90       	pop	r8
    1922:	7f 90       	pop	r7
    1924:	6f 90       	pop	r6
    1926:	08 95       	ret

00001928 <_ZN6PS3USB14enable_sixaxisEv>:
    1928:	8f 92       	push	r8
    192a:	9f 92       	push	r9
    192c:	af 92       	push	r10
    192e:	bf 92       	push	r11
    1930:	cf 92       	push	r12
    1932:	ef 92       	push	r14
    1934:	0f 93       	push	r16
    1936:	cf 93       	push	r28
    1938:	df 93       	push	r29
    193a:	00 d0       	rcall	.+0      	; 0x193c <_ZN6PS3USB14enable_sixaxisEv+0x14>
    193c:	00 d0       	rcall	.+0      	; 0x193e <_ZN6PS3USB14enable_sixaxisEv+0x16>
    193e:	cd b7       	in	r28, 0x3d	; 61
    1940:	de b7       	in	r29, 0x3e	; 62
    1942:	fc 01       	movw	r30, r24
    1944:	82 e4       	ldi	r24, 0x42	; 66
    1946:	89 83       	std	Y+1, r24	; 0x01
    1948:	8c e0       	ldi	r24, 0x0C	; 12
    194a:	8a 83       	std	Y+2, r24	; 0x02
    194c:	1b 82       	std	Y+3, r1	; 0x03
    194e:	1c 82       	std	Y+4, r1	; 0x04
    1950:	1f 92       	push	r1
    1952:	1f 92       	push	r1
    1954:	ce 01       	movw	r24, r28
    1956:	01 96       	adiw	r24, 0x01	; 1
    1958:	9f 93       	push	r25
    195a:	8f 93       	push	r24
    195c:	1f 92       	push	r1
    195e:	84 e0       	ldi	r24, 0x04	; 4
    1960:	8f 93       	push	r24
    1962:	84 e0       	ldi	r24, 0x04	; 4
    1964:	88 2e       	mov	r8, r24
    1966:	91 2c       	mov	r9, r1
    1968:	a1 2c       	mov	r10, r1
    196a:	b1 2c       	mov	r11, r1
    196c:	93 e0       	ldi	r25, 0x03	; 3
    196e:	c9 2e       	mov	r12, r25
    1970:	24 ef       	ldi	r18, 0xF4	; 244
    1972:	e2 2e       	mov	r14, r18
    1974:	09 e0       	ldi	r16, 0x09	; 9
    1976:	21 e2       	ldi	r18, 0x21	; 33
    1978:	40 85       	ldd	r20, Z+8	; 0x08
    197a:	67 81       	ldd	r22, Z+7	; 0x07
    197c:	85 81       	ldd	r24, Z+5	; 0x05
    197e:	96 81       	ldd	r25, Z+6	; 0x06
    1980:	0e 94 bc 14 	call	0x2978	; 0x2978 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser>
    1984:	0f 90       	pop	r0
    1986:	0f 90       	pop	r0
    1988:	0f 90       	pop	r0
    198a:	0f 90       	pop	r0
    198c:	0f 90       	pop	r0
    198e:	0f 90       	pop	r0
    1990:	0f 90       	pop	r0
    1992:	0f 90       	pop	r0
    1994:	0f 90       	pop	r0
    1996:	0f 90       	pop	r0
    1998:	df 91       	pop	r29
    199a:	cf 91       	pop	r28
    199c:	0f 91       	pop	r16
    199e:	ef 90       	pop	r14
    19a0:	cf 90       	pop	r12
    19a2:	bf 90       	pop	r11
    19a4:	af 90       	pop	r10
    19a6:	9f 90       	pop	r9
    19a8:	8f 90       	pop	r8
    19aa:	08 95       	ret

000019ac <_ZN6PS3USB12Move_CommandEPhj>:
    19ac:	0f 93       	push	r16
    19ae:	1f 93       	push	r17
    19b0:	fc 01       	movw	r30, r24
    19b2:	9a 01       	movw	r18, r20
    19b4:	8b 01       	movw	r16, r22
    19b6:	43 85       	ldd	r20, Z+11	; 0x0b
    19b8:	67 81       	ldd	r22, Z+7	; 0x07
    19ba:	85 81       	ldd	r24, Z+5	; 0x05
    19bc:	96 81       	ldd	r25, Z+6	; 0x06
    19be:	0e 94 9e 13 	call	0x273c	; 0x273c <_ZN3USB11outTransferEhhjPh>
    19c2:	1f 91       	pop	r17
    19c4:	0f 91       	pop	r16
    19c6:	08 95       	ret

000019c8 <_ZN6PS3USB4PollEv>:
    19c8:	cf 92       	push	r12
    19ca:	df 92       	push	r13
    19cc:	ef 92       	push	r14
    19ce:	0f 93       	push	r16
    19d0:	1f 93       	push	r17
    19d2:	cf 93       	push	r28
    19d4:	df 93       	push	r29
    19d6:	00 d0       	rcall	.+0      	; 0x19d8 <_ZN6PS3USB4PollEv+0x10>
    19d8:	cd b7       	in	r28, 0x3d	; 61
    19da:	de b7       	in	r29, 0x3e	; 62
    19dc:	fc 01       	movw	r30, r24
    19de:	23 89       	ldd	r18, Z+19	; 0x13
    19e0:	22 23       	and	r18, r18
    19e2:	09 f4       	brne	.+2      	; 0x19e6 <_ZN6PS3USB4PollEv+0x1e>
    19e4:	53 c0       	rjmp	.+166    	; 0x1a8c <_ZN6PS3USB4PollEv+0xc4>
    19e6:	6c 01       	movw	r12, r24
    19e8:	82 81       	ldd	r24, Z+2	; 0x02
    19ea:	81 11       	cpse	r24, r1
    19ec:	03 c0       	rjmp	.+6      	; 0x19f4 <_ZN6PS3USB4PollEv+0x2c>
    19ee:	84 81       	ldd	r24, Z+4	; 0x04
    19f0:	88 23       	and	r24, r24
    19f2:	41 f1       	breq	.+80     	; 0x1a44 <_ZN6PS3USB4PollEv+0x7c>
    19f4:	80 e4       	ldi	r24, 0x40	; 64
    19f6:	90 e0       	ldi	r25, 0x00	; 0
    19f8:	9a 83       	std	Y+2, r25	; 0x02
    19fa:	89 83       	std	Y+1, r24	; 0x01
    19fc:	e1 2c       	mov	r14, r1
    19fe:	86 01       	movw	r16, r12
    1a00:	06 5d       	subi	r16, 0xD6	; 214
    1a02:	1f 4f       	sbci	r17, 0xFF	; 255
    1a04:	9e 01       	movw	r18, r28
    1a06:	2f 5f       	subi	r18, 0xFF	; 255
    1a08:	3f 4f       	sbci	r19, 0xFF	; 255
    1a0a:	f6 01       	movw	r30, r12
    1a0c:	46 85       	ldd	r20, Z+14	; 0x0e
    1a0e:	67 81       	ldd	r22, Z+7	; 0x07
    1a10:	85 81       	ldd	r24, Z+5	; 0x05
    1a12:	96 81       	ldd	r25, Z+6	; 0x06
    1a14:	0e 94 56 17 	call	0x2eac	; 0x2eac <_ZN3USB10inTransferEhhPjPhh>
    1a18:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    1a1c:	f6 01       	movw	r30, r12
    1a1e:	04 89       	ldd	r16, Z+20	; 0x14
    1a20:	15 89       	ldd	r17, Z+21	; 0x15
    1a22:	26 89       	ldd	r18, Z+22	; 0x16
    1a24:	37 89       	ldd	r19, Z+23	; 0x17
    1a26:	dc 01       	movw	r26, r24
    1a28:	cb 01       	movw	r24, r22
    1a2a:	80 1b       	sub	r24, r16
    1a2c:	91 0b       	sbc	r25, r17
    1a2e:	a2 0b       	sbc	r26, r18
    1a30:	b3 0b       	sbc	r27, r19
    1a32:	85 36       	cpi	r24, 0x65	; 101
    1a34:	91 05       	cpc	r25, r1
    1a36:	a1 05       	cpc	r26, r1
    1a38:	b1 05       	cpc	r27, r1
    1a3a:	44 f1       	brlt	.+80     	; 0x1a8c <_ZN6PS3USB4PollEv+0xc4>
    1a3c:	c6 01       	movw	r24, r12
    1a3e:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <_ZN6PS3USB10readReportEv>
    1a42:	24 c0       	rjmp	.+72     	; 0x1a8c <_ZN6PS3USB4PollEv+0xc4>
    1a44:	83 81       	ldd	r24, Z+3	; 0x03
    1a46:	88 23       	and	r24, r24
    1a48:	09 f1       	breq	.+66     	; 0x1a8c <_ZN6PS3USB4PollEv+0xc4>
    1a4a:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    1a4e:	f6 01       	movw	r30, r12
    1a50:	04 89       	ldd	r16, Z+20	; 0x14
    1a52:	15 89       	ldd	r17, Z+21	; 0x15
    1a54:	26 89       	ldd	r18, Z+22	; 0x16
    1a56:	37 89       	ldd	r19, Z+23	; 0x17
    1a58:	dc 01       	movw	r26, r24
    1a5a:	cb 01       	movw	r24, r22
    1a5c:	80 1b       	sub	r24, r16
    1a5e:	91 0b       	sbc	r25, r17
    1a60:	a2 0b       	sbc	r26, r18
    1a62:	b3 0b       	sbc	r27, r19
    1a64:	81 3a       	cpi	r24, 0xA1	; 161
    1a66:	9f 40       	sbci	r25, 0x0F	; 15
    1a68:	a1 05       	cpc	r26, r1
    1a6a:	b1 05       	cpc	r27, r1
    1a6c:	7c f0       	brlt	.+30     	; 0x1a8c <_ZN6PS3USB4PollEv+0xc4>
    1a6e:	b6 01       	movw	r22, r12
    1a70:	66 59       	subi	r22, 0x96	; 150
    1a72:	7f 4f       	sbci	r23, 0xFF	; 255
    1a74:	47 e0       	ldi	r20, 0x07	; 7
    1a76:	50 e0       	ldi	r21, 0x00	; 0
    1a78:	c6 01       	movw	r24, r12
    1a7a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <_ZN6PS3USB12Move_CommandEPhj>
    1a7e:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    1a82:	f6 01       	movw	r30, r12
    1a84:	64 8b       	std	Z+20, r22	; 0x14
    1a86:	75 8b       	std	Z+21, r23	; 0x15
    1a88:	86 8b       	std	Z+22, r24	; 0x16
    1a8a:	97 8b       	std	Z+23, r25	; 0x17
    1a8c:	80 e0       	ldi	r24, 0x00	; 0
    1a8e:	0f 90       	pop	r0
    1a90:	0f 90       	pop	r0
    1a92:	df 91       	pop	r29
    1a94:	cf 91       	pop	r28
    1a96:	1f 91       	pop	r17
    1a98:	0f 91       	pop	r16
    1a9a:	ef 90       	pop	r14
    1a9c:	df 90       	pop	r13
    1a9e:	cf 90       	pop	r12
    1aa0:	08 95       	ret

00001aa2 <_ZN6PS3USB11moveSetBulbEhhh>:
    1aa2:	fc 01       	movw	r30, r24
    1aa4:	e4 59       	subi	r30, 0x94	; 148
    1aa6:	ff 4f       	sbci	r31, 0xFF	; 255
    1aa8:	60 83       	st	Z, r22
    1aaa:	31 96       	adiw	r30, 0x01	; 1
    1aac:	40 83       	st	Z, r20
    1aae:	31 96       	adiw	r30, 0x01	; 1
    1ab0:	20 83       	st	Z, r18
    1ab2:	bc 01       	movw	r22, r24
    1ab4:	66 59       	subi	r22, 0x96	; 150
    1ab6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ab8:	47 e0       	ldi	r20, 0x07	; 7
    1aba:	50 e0       	ldi	r21, 0x00	; 0
    1abc:	0c 94 d6 0c 	jmp	0x19ac	; 0x19ac <_ZN6PS3USB12Move_CommandEPhj>

00001ac0 <_ZN6PS3USB11moveSetBulbE10ColorsEnum>:
    1ac0:	cf 92       	push	r12
    1ac2:	df 92       	push	r13
    1ac4:	ef 92       	push	r14
    1ac6:	ff 92       	push	r15
    1ac8:	0f 93       	push	r16
    1aca:	1f 93       	push	r17
    1acc:	e4 2f       	mov	r30, r20
    1ace:	04 2f       	mov	r16, r20
    1ad0:	15 2f       	mov	r17, r21
    1ad2:	9b 01       	movw	r18, r22
    1ad4:	77 27       	eor	r23, r23
    1ad6:	37 fd       	sbrc	r19, 7
    1ad8:	7a 95       	dec	r23
    1ada:	63 2f       	mov	r22, r19
    1adc:	52 2f       	mov	r21, r18
    1ade:	41 2f       	mov	r20, r17
    1ae0:	69 01       	movw	r12, r18
    1ae2:	ff 24       	eor	r15, r15
    1ae4:	d7 fc       	sbrc	r13, 7
    1ae6:	f0 94       	com	r15
    1ae8:	ef 2c       	mov	r14, r15
    1aea:	2e 2f       	mov	r18, r30
    1aec:	6c 2d       	mov	r22, r12
    1aee:	1f 91       	pop	r17
    1af0:	0f 91       	pop	r16
    1af2:	ff 90       	pop	r15
    1af4:	ef 90       	pop	r14
    1af6:	df 90       	pop	r13
    1af8:	cf 90       	pop	r12
    1afa:	0c 94 51 0d 	jmp	0x1aa2	; 0x1aa2 <_ZN6PS3USB11moveSetBulbEhhh>

00001afe <_ZN6PS3USB13setMoveBdaddrEPh>:
    1afe:	8f 92       	push	r8
    1b00:	9f 92       	push	r9
    1b02:	af 92       	push	r10
    1b04:	bf 92       	push	r11
    1b06:	cf 92       	push	r12
    1b08:	ef 92       	push	r14
    1b0a:	0f 93       	push	r16
    1b0c:	1f 93       	push	r17
    1b0e:	cf 93       	push	r28
    1b10:	df 93       	push	r29
    1b12:	cd b7       	in	r28, 0x3d	; 61
    1b14:	de b7       	in	r29, 0x3e	; 62
    1b16:	2b 97       	sbiw	r28, 0x0b	; 11
    1b18:	0f b6       	in	r0, 0x3f	; 63
    1b1a:	f8 94       	cli
    1b1c:	de bf       	out	0x3e, r29	; 62
    1b1e:	0f be       	out	0x3f, r0	; 63
    1b20:	cd bf       	out	0x3d, r28	; 61
    1b22:	dc 01       	movw	r26, r24
    1b24:	85 e0       	ldi	r24, 0x05	; 5
    1b26:	89 83       	std	Y+1, r24	; 0x01
    1b28:	80 e1       	ldi	r24, 0x10	; 16
    1b2a:	88 87       	std	Y+8, r24	; 0x08
    1b2c:	81 e0       	ldi	r24, 0x01	; 1
    1b2e:	89 87       	std	Y+9, r24	; 0x09
    1b30:	82 e0       	ldi	r24, 0x02	; 2
    1b32:	8a 87       	std	Y+10, r24	; 0x0a
    1b34:	82 e1       	ldi	r24, 0x12	; 18
    1b36:	8b 87       	std	Y+11, r24	; 0x0b
    1b38:	8b 01       	movw	r16, r22
    1b3a:	ce 01       	movw	r24, r28
    1b3c:	02 96       	adiw	r24, 0x02	; 2
    1b3e:	9e 01       	movw	r18, r28
    1b40:	28 5f       	subi	r18, 0xF8	; 248
    1b42:	3f 4f       	sbci	r19, 0xFF	; 255
    1b44:	f8 01       	movw	r30, r16
    1b46:	41 91       	ld	r20, Z+
    1b48:	8f 01       	movw	r16, r30
    1b4a:	fc 01       	movw	r30, r24
    1b4c:	41 93       	st	Z+, r20
    1b4e:	cf 01       	movw	r24, r30
    1b50:	e2 17       	cp	r30, r18
    1b52:	f3 07       	cpc	r31, r19
    1b54:	b9 f7       	brne	.-18     	; 0x1b44 <_ZN6PS3USB13setMoveBdaddrEPh+0x46>
    1b56:	1f 92       	push	r1
    1b58:	1f 92       	push	r1
    1b5a:	ce 01       	movw	r24, r28
    1b5c:	01 96       	adiw	r24, 0x01	; 1
    1b5e:	9f 93       	push	r25
    1b60:	8f 93       	push	r24
    1b62:	1f 92       	push	r1
    1b64:	8b e0       	ldi	r24, 0x0B	; 11
    1b66:	8f 93       	push	r24
    1b68:	8b e0       	ldi	r24, 0x0B	; 11
    1b6a:	88 2e       	mov	r8, r24
    1b6c:	91 2c       	mov	r9, r1
    1b6e:	a1 2c       	mov	r10, r1
    1b70:	b1 2c       	mov	r11, r1
    1b72:	93 e0       	ldi	r25, 0x03	; 3
    1b74:	c9 2e       	mov	r12, r25
    1b76:	25 e0       	ldi	r18, 0x05	; 5
    1b78:	e2 2e       	mov	r14, r18
    1b7a:	09 e0       	ldi	r16, 0x09	; 9
    1b7c:	21 e2       	ldi	r18, 0x21	; 33
    1b7e:	18 96       	adiw	r26, 0x08	; 8
    1b80:	4c 91       	ld	r20, X
    1b82:	18 97       	sbiw	r26, 0x08	; 8
    1b84:	17 96       	adiw	r26, 0x07	; 7
    1b86:	6c 91       	ld	r22, X
    1b88:	17 97       	sbiw	r26, 0x07	; 7
    1b8a:	15 96       	adiw	r26, 0x05	; 5
    1b8c:	8d 91       	ld	r24, X+
    1b8e:	9c 91       	ld	r25, X
    1b90:	16 97       	sbiw	r26, 0x06	; 6
    1b92:	0e 94 bc 14 	call	0x2978	; 0x2978 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser>
    1b96:	0f 90       	pop	r0
    1b98:	0f 90       	pop	r0
    1b9a:	0f 90       	pop	r0
    1b9c:	0f 90       	pop	r0
    1b9e:	0f 90       	pop	r0
    1ba0:	0f 90       	pop	r0
    1ba2:	2b 96       	adiw	r28, 0x0b	; 11
    1ba4:	0f b6       	in	r0, 0x3f	; 63
    1ba6:	f8 94       	cli
    1ba8:	de bf       	out	0x3e, r29	; 62
    1baa:	0f be       	out	0x3f, r0	; 63
    1bac:	cd bf       	out	0x3d, r28	; 61
    1bae:	df 91       	pop	r29
    1bb0:	cf 91       	pop	r28
    1bb2:	1f 91       	pop	r17
    1bb4:	0f 91       	pop	r16
    1bb6:	ef 90       	pop	r14
    1bb8:	cf 90       	pop	r12
    1bba:	bf 90       	pop	r11
    1bbc:	af 90       	pop	r10
    1bbe:	9f 90       	pop	r9
    1bc0:	8f 90       	pop	r8
    1bc2:	08 95       	ret

00001bc4 <_ZN6PS3USB6onInitEv>:

void PS3USB::onInit() {
        if(pFuncOnInit)
    1bc4:	dc 01       	movw	r26, r24
    1bc6:	51 96       	adiw	r26, 0x11	; 17
    1bc8:	ed 91       	ld	r30, X+
    1bca:	fc 91       	ld	r31, X
    1bcc:	52 97       	sbiw	r26, 0x12	; 18
    1bce:	30 97       	sbiw	r30, 0x00	; 0
    1bd0:	09 f0       	breq	.+2      	; 0x1bd4 <_ZN6PS3USB6onInitEv+0x10>
                pFuncOnInit(); // Call the user function
    1bd2:	09 94       	ijmp
        else {
                if(PS3MoveConnected)
    1bd4:	fc 01       	movw	r30, r24
    1bd6:	23 81       	ldd	r18, Z+3	; 0x03
    1bd8:	22 23       	and	r18, r18
    1bda:	31 f0       	breq	.+12     	; 0x1be8 <_ZN6PS3USB6onInitEv+0x24>
                        moveSetBulb(Red);
    1bdc:	40 e0       	ldi	r20, 0x00	; 0
    1bde:	50 e0       	ldi	r21, 0x00	; 0
    1be0:	6f ef       	ldi	r22, 0xFF	; 255
    1be2:	70 e0       	ldi	r23, 0x00	; 0
    1be4:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <_ZN6PS3USB11moveSetBulbE10ColorsEnum>

void PS3USB::setLedOn(LEDEnum a) {
        if(a == OFF)
                setLedRaw(0);
        else {
                writeBuf[9] |= (uint8_t)((pgm_read_byte(&PS3_LEDS[(uint8_t)a]) & 0x0f) << 1);
    1be8:	e1 e0       	ldi	r30, 0x01	; 1
    1bea:	f1 e0       	ldi	r31, 0x01	; 1
    1bec:	e4 91       	lpm	r30, Z
    1bee:	dc 01       	movw	r26, r24
    1bf0:	ad 58       	subi	r26, 0x8D	; 141
    1bf2:	bf 4f       	sbci	r27, 0xFF	; 255
    1bf4:	ef 70       	andi	r30, 0x0F	; 15
    1bf6:	ee 0f       	add	r30, r30
    1bf8:	2c 91       	ld	r18, X
    1bfa:	e2 2b       	or	r30, r18
    1bfc:	ec 93       	st	X, r30
                PS3_Command(writeBuf, PS3_REPORT_BUFFER_SIZE);
    1bfe:	bc 01       	movw	r22, r24
    1c00:	66 59       	subi	r22, 0x96	; 150
    1c02:	7f 4f       	sbci	r23, 0xFF	; 255
    1c04:	40 e3       	ldi	r20, 0x30	; 48
    1c06:	50 e0       	ldi	r21, 0x00	; 0
    1c08:	0c 94 14 0c 	jmp	0x1828	; 0x1828 <_ZN6PS3USB11PS3_CommandEPhj>

00001c0c <_ZN6PS3USB4InitEhhb>:
        my_bdaddr[2] = btadr2;
        my_bdaddr[1] = btadr1;
        my_bdaddr[0] = btadr0;
}

uint8_t PS3USB::Init(uint8_t parent, uint8_t port, bool lowspeed) {
    1c0c:	2f 92       	push	r2
    1c0e:	3f 92       	push	r3
    1c10:	4f 92       	push	r4
    1c12:	5f 92       	push	r5
    1c14:	6f 92       	push	r6
    1c16:	7f 92       	push	r7
    1c18:	8f 92       	push	r8
    1c1a:	9f 92       	push	r9
    1c1c:	af 92       	push	r10
    1c1e:	bf 92       	push	r11
    1c20:	cf 92       	push	r12
    1c22:	df 92       	push	r13
    1c24:	ef 92       	push	r14
    1c26:	ff 92       	push	r15
    1c28:	0f 93       	push	r16
    1c2a:	1f 93       	push	r17
    1c2c:	cf 93       	push	r28
    1c2e:	df 93       	push	r29
    1c30:	cd b7       	in	r28, 0x3d	; 61
    1c32:	de b7       	in	r29, 0x3e	; 62
    1c34:	62 97       	sbiw	r28, 0x12	; 18
    1c36:	0f b6       	in	r0, 0x3f	; 63
    1c38:	f8 94       	cli
    1c3a:	de bf       	out	0x3e, r29	; 62
    1c3c:	0f be       	out	0x3f, r0	; 63
    1c3e:	cd bf       	out	0x3d, r28	; 61
        AddressPool &addrPool = pUsb->GetAddressPool();
#ifdef EXTRADEBUG
        Notify(PSTR("\r\nPS3USB Init"), 0x80);
#endif
        // check if address has already been assigned to an instance
        if(bAddress) {
    1c40:	dc 01       	movw	r26, r24
    1c42:	17 96       	adiw	r26, 0x07	; 7
    1c44:	5c 90       	ld	r5, X
    1c46:	51 10       	cpse	r5, r1
    1c48:	39 c1       	rjmp	.+626    	; 0x1ebc <_ZN6PS3USB4InitEhhb+0x2b0>
    1c4a:	22 2e       	mov	r2, r18
    1c4c:	34 2e       	mov	r3, r20
    1c4e:	46 2e       	mov	r4, r22
    1c50:	7c 01       	movw	r14, r24
        EpInfo *oldep_ptr = NULL;
        uint16_t PID;
        uint16_t VID;

        // get memory address of USB device address pool
        AddressPool &addrPool = pUsb->GetAddressPool();
    1c52:	fc 01       	movw	r30, r24
    1c54:	c5 80       	ldd	r12, Z+5	; 0x05
    1c56:	d6 80       	ldd	r13, Z+6	; 0x06
#endif
                return USB_ERROR_CLASS_INSTANCE_ALREADY_IN_USE;
        }

        // Get pointer to pseudo device with address 0 assigned
        p = addrPool.GetUsbDevicePtr(0);
    1c58:	d6 01       	movw	r26, r12
    1c5a:	ed 91       	ld	r30, X+
    1c5c:	fc 91       	ld	r31, X
    1c5e:	01 90       	ld	r0, Z+
    1c60:	f0 81       	ld	r31, Z
    1c62:	e0 2d       	mov	r30, r0
    1c64:	60 e0       	ldi	r22, 0x00	; 0
    1c66:	c6 01       	movw	r24, r12
    1c68:	09 95       	icall
    1c6a:	5c 01       	movw	r10, r24

        if(!p) {
    1c6c:	00 97       	sbiw	r24, 0x00	; 0
    1c6e:	19 f4       	brne	.+6      	; 0x1c76 <_ZN6PS3USB4InitEhhb+0x6a>
#ifdef DEBUG_USB_HOST
                Notify(PSTR("\r\nAddress not found"), 0x80);
#endif
                return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
    1c70:	46 ed       	ldi	r20, 0xD6	; 214
    1c72:	54 2e       	mov	r5, r20
    1c74:	2b c1       	rjmp	.+598    	; 0x1ecc <_ZN6PS3USB4InitEhhb+0x2c0>
        }

        if(!p->epinfo) {
    1c76:	fc 01       	movw	r30, r24
    1c78:	60 80       	ld	r6, Z
    1c7a:	71 80       	ldd	r7, Z+1	; 0x01
    1c7c:	61 14       	cp	r6, r1
    1c7e:	71 04       	cpc	r7, r1
    1c80:	09 f4       	brne	.+2      	; 0x1c84 <_ZN6PS3USB4InitEhhb+0x78>
    1c82:	1f c1       	rjmp	.+574    	; 0x1ec2 <_ZN6PS3USB4InitEhhb+0x2b6>

        // Save old pointer to EP_RECORD of address 0
        oldep_ptr = p->epinfo;

        // Temporary assign new pointer to epInfo to p->epinfo in order to avoid toggle inconsistence
        p->epinfo = epInfo;
    1c84:	47 01       	movw	r8, r14
    1c86:	f8 e0       	ldi	r31, 0x08	; 8
    1c88:	8f 0e       	add	r8, r31
    1c8a:	91 1c       	adc	r9, r1
    1c8c:	dc 01       	movw	r26, r24
    1c8e:	11 96       	adiw	r26, 0x01	; 1
    1c90:	9c 92       	st	X, r9
    1c92:	8e 92       	st	-X, r8

        p->lowspeed = lowspeed;
    1c94:	14 96       	adiw	r26, 0x04	; 4
    1c96:	2c 92       	st	X, r2

        // Get device descriptor
        rcode = pUsb->getDevDescr(0, 0, sizeof (USB_DEVICE_DESCRIPTOR), (uint8_t*)buf); // Get device descriptor - addr, ep, nbytes, data
    1c98:	8e 01       	movw	r16, r28
    1c9a:	0f 5f       	subi	r16, 0xFF	; 255
    1c9c:	1f 4f       	sbci	r17, 0xFF	; 255
    1c9e:	22 e1       	ldi	r18, 0x12	; 18
    1ca0:	30 e0       	ldi	r19, 0x00	; 0
    1ca2:	40 e0       	ldi	r20, 0x00	; 0
    1ca4:	60 e0       	ldi	r22, 0x00	; 0
    1ca6:	f7 01       	movw	r30, r14
    1ca8:	85 81       	ldd	r24, Z+5	; 0x05
    1caa:	96 81       	ldd	r25, Z+6	; 0x06
    1cac:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <_ZN3USB11getDevDescrEhhjPh>
    1cb0:	18 2f       	mov	r17, r24
        // Restore p->epinfo
        p->epinfo = oldep_ptr;
    1cb2:	d5 01       	movw	r26, r10
    1cb4:	6d 92       	st	X+, r6
    1cb6:	7c 92       	st	X, r7

        if(rcode)
    1cb8:	81 11       	cpse	r24, r1
    1cba:	f6 c0       	rjmp	.+492    	; 0x1ea8 <_ZN6PS3USB4InitEhhb+0x29c>
                goto FailGetDevDescr;

        VID = udd->idVendor;
        PID = udd->idProduct;

        if(VID != PS3_VID || (PID != PS3_PID && PID != PS3NAVIGATION_PID && PID != PS3MOVE_PID))
    1cbc:	89 85       	ldd	r24, Y+9	; 0x09
    1cbe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cc0:	8c 34       	cpi	r24, 0x4C	; 76
    1cc2:	95 40       	sbci	r25, 0x05	; 5
    1cc4:	09 f0       	breq	.+2      	; 0x1cc8 <_ZN6PS3USB4InitEhhb+0xbc>
    1cc6:	ef c0       	rjmp	.+478    	; 0x1ea6 <_ZN6PS3USB4InitEhhb+0x29a>

        if(rcode)
                goto FailGetDevDescr;

        VID = udd->idVendor;
        PID = udd->idProduct;
    1cc8:	6b 84       	ldd	r6, Y+11	; 0x0b
    1cca:	7c 84       	ldd	r7, Y+12	; 0x0c

        if(VID != PS3_VID || (PID != PS3_PID && PID != PS3NAVIGATION_PID && PID != PS3MOVE_PID))
    1ccc:	e8 e6       	ldi	r30, 0x68	; 104
    1cce:	6e 16       	cp	r6, r30
    1cd0:	e2 e0       	ldi	r30, 0x02	; 2
    1cd2:	7e 06       	cpc	r7, r30
    1cd4:	59 f0       	breq	.+22     	; 0x1cec <_ZN6PS3USB4InitEhhb+0xe0>
    1cd6:	ff e2       	ldi	r31, 0x2F	; 47
    1cd8:	6f 16       	cp	r6, r31
    1cda:	f4 e0       	ldi	r31, 0x04	; 4
    1cdc:	7f 06       	cpc	r7, r31
    1cde:	31 f0       	breq	.+12     	; 0x1cec <_ZN6PS3USB4InitEhhb+0xe0>
    1ce0:	25 ed       	ldi	r18, 0xD5	; 213
    1ce2:	62 16       	cp	r6, r18
    1ce4:	23 e0       	ldi	r18, 0x03	; 3
    1ce6:	72 06       	cpc	r7, r18
    1ce8:	09 f0       	breq	.+2      	; 0x1cec <_ZN6PS3USB4InitEhhb+0xe0>
    1cea:	dd c0       	rjmp	.+442    	; 0x1ea6 <_ZN6PS3USB4InitEhhb+0x29a>
                goto FailUnknownDevice;

        // Allocate new address according to device class
        bAddress = addrPool.AllocAddress(parent, false, port);
    1cec:	d6 01       	movw	r26, r12
    1cee:	ed 91       	ld	r30, X+
    1cf0:	fc 91       	ld	r31, X
    1cf2:	02 80       	ldd	r0, Z+2	; 0x02
    1cf4:	f3 81       	ldd	r31, Z+3	; 0x03
    1cf6:	e0 2d       	mov	r30, r0
    1cf8:	23 2d       	mov	r18, r3
    1cfa:	40 e0       	ldi	r20, 0x00	; 0
    1cfc:	64 2d       	mov	r22, r4
    1cfe:	c6 01       	movw	r24, r12
    1d00:	09 95       	icall
    1d02:	f7 01       	movw	r30, r14
    1d04:	87 83       	std	Z+7, r24	; 0x07

        if(!bAddress)
    1d06:	88 23       	and	r24, r24
    1d08:	09 f4       	brne	.+2      	; 0x1d0c <_ZN6PS3USB4InitEhhb+0x100>
    1d0a:	de c0       	rjmp	.+444    	; 0x1ec8 <_ZN6PS3USB4InitEhhb+0x2bc>
                return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;

        // Extract Max Packet Size from device descriptor
        epInfo[0].maxPktSize = udd->bMaxPacketSize0;
    1d0c:	98 85       	ldd	r25, Y+8	; 0x08
    1d0e:	91 87       	std	Z+9, r25	; 0x09

        // Assign new address to the device
        rcode = pUsb->setAddr(0, 0, bAddress);
    1d10:	28 2f       	mov	r18, r24
    1d12:	40 e0       	ldi	r20, 0x00	; 0
    1d14:	60 e0       	ldi	r22, 0x00	; 0
    1d16:	85 81       	ldd	r24, Z+5	; 0x05
    1d18:	96 81       	ldd	r25, Z+6	; 0x06
    1d1a:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <_ZN3USB7setAddrEhhh>
    1d1e:	18 2f       	mov	r17, r24
    1d20:	d6 01       	movw	r26, r12
    1d22:	ed 91       	ld	r30, X+
    1d24:	fc 91       	ld	r31, X
        if(rcode) {
                p->lowspeed = false;
    1d26:	d5 01       	movw	r26, r10
    1d28:	14 96       	adiw	r26, 0x04	; 4
    1d2a:	1c 92       	st	X, r1
        // Extract Max Packet Size from device descriptor
        epInfo[0].maxPktSize = udd->bMaxPacketSize0;

        // Assign new address to the device
        rcode = pUsb->setAddr(0, 0, bAddress);
        if(rcode) {
    1d2c:	88 23       	and	r24, r24
    1d2e:	59 f0       	breq	.+22     	; 0x1d46 <_ZN6PS3USB4InitEhhb+0x13a>
                p->lowspeed = false;
                addrPool.FreeAddress(bAddress);
    1d30:	04 80       	ldd	r0, Z+4	; 0x04
    1d32:	f5 81       	ldd	r31, Z+5	; 0x05
    1d34:	e0 2d       	mov	r30, r0
    1d36:	d7 01       	movw	r26, r14
    1d38:	17 96       	adiw	r26, 0x07	; 7
    1d3a:	6c 91       	ld	r22, X
    1d3c:	c6 01       	movw	r24, r12
    1d3e:	09 95       	icall
                bAddress = 0;
    1d40:	f7 01       	movw	r30, r14
    1d42:	17 82       	std	Z+7, r1	; 0x07
    1d44:	b9 c0       	rjmp	.+370    	; 0x1eb8 <_ZN6PS3USB4InitEhhb+0x2ac>
        //delay(300); // Spec says you should wait at least 200ms

        p->lowspeed = false;

        //get pointer to assigned address record
        p = addrPool.GetUsbDevicePtr(bAddress);
    1d46:	01 90       	ld	r0, Z+
    1d48:	f0 81       	ld	r31, Z
    1d4a:	e0 2d       	mov	r30, r0
    1d4c:	d7 01       	movw	r26, r14
    1d4e:	17 96       	adiw	r26, 0x07	; 7
    1d50:	6c 91       	ld	r22, X
    1d52:	c6 01       	movw	r24, r12
    1d54:	09 95       	icall
        if(!p)
    1d56:	00 97       	sbiw	r24, 0x00	; 0
    1d58:	09 f4       	brne	.+2      	; 0x1d5c <_ZN6PS3USB4InitEhhb+0x150>
    1d5a:	8a cf       	rjmp	.-236    	; 0x1c70 <_ZN6PS3USB4InitEhhb+0x64>
                return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;

        p->lowspeed = lowspeed;
    1d5c:	fc 01       	movw	r30, r24
    1d5e:	24 82       	std	Z+4, r2	; 0x04

        // Assign epInfo to epinfo pointer - only EP0 is known
        rcode = pUsb->setEpInfoEntry(bAddress, 1, epInfo);
    1d60:	94 01       	movw	r18, r8
    1d62:	41 e0       	ldi	r20, 0x01	; 1
    1d64:	d7 01       	movw	r26, r14
    1d66:	17 96       	adiw	r26, 0x07	; 7
    1d68:	6c 91       	ld	r22, X
    1d6a:	17 97       	sbiw	r26, 0x07	; 7
    1d6c:	15 96       	adiw	r26, 0x05	; 5
    1d6e:	8d 91       	ld	r24, X+
    1d70:	9c 91       	ld	r25, X
    1d72:	16 97       	sbiw	r26, 0x06	; 6
    1d74:	0e 94 c2 10 	call	0x2184	; 0x2184 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>
    1d78:	18 2f       	mov	r17, r24
        if(rcode)
    1d7a:	81 11       	cpse	r24, r1
    1d7c:	95 c0       	rjmp	.+298    	; 0x1ea8 <_ZN6PS3USB4InitEhhb+0x29c>
        /* The application will work in reduced host mode, so we can save program and data
           memory space. After verifying the PID and VID we will use known values for the
           configuration values for device, interface, endpoints and HID for the PS3 Controllers */

        /* Initialize data structures for endpoints of device */
        epInfo[ PS3_OUTPUT_PIPE ].epAddr = 0x02; // PS3 output endpoint
    1d7e:	32 e0       	ldi	r19, 0x02	; 2
    1d80:	b3 2e       	mov	r11, r19
    1d82:	f7 01       	movw	r30, r14
    1d84:	b3 86       	std	Z+11, r11	; 0x0b
        epInfo[ PS3_OUTPUT_PIPE ].epAttribs = USB_TRANSFER_TYPE_INTERRUPT;
        epInfo[ PS3_OUTPUT_PIPE ].bmNakPower = USB_NAK_NOWAIT; // Only poll once for interrupt endpoints
        epInfo[ PS3_OUTPUT_PIPE ].maxPktSize = EP_MAXPKTSIZE;
    1d86:	90 e4       	ldi	r25, 0x40	; 64
    1d88:	94 87       	std	Z+12, r25	; 0x0c
        epInfo[ PS3_OUTPUT_PIPE ].bmSndToggle = 0;
        epInfo[ PS3_OUTPUT_PIPE ].bmRcvToggle = 0;
    1d8a:	84 e0       	ldi	r24, 0x04	; 4
    1d8c:	85 87       	std	Z+13, r24	; 0x0d
        epInfo[ PS3_INPUT_PIPE ].epAddr = 0x01; // PS3 report endpoint
    1d8e:	01 e0       	ldi	r16, 0x01	; 1
    1d90:	06 87       	std	Z+14, r16	; 0x0e
        epInfo[ PS3_INPUT_PIPE ].epAttribs = USB_TRANSFER_TYPE_INTERRUPT;
        epInfo[ PS3_INPUT_PIPE ].bmNakPower = USB_NAK_NOWAIT; // Only poll once for interrupt endpoints
        epInfo[ PS3_INPUT_PIPE ].maxPktSize = EP_MAXPKTSIZE;
    1d92:	97 87       	std	Z+15, r25	; 0x0f
        epInfo[ PS3_INPUT_PIPE ].bmSndToggle = 0;
        epInfo[ PS3_INPUT_PIPE ].bmRcvToggle = 0;
    1d94:	80 8b       	std	Z+16, r24	; 0x10

        rcode = pUsb->setEpInfoEntry(bAddress, 3, epInfo);
    1d96:	94 01       	movw	r18, r8
    1d98:	43 e0       	ldi	r20, 0x03	; 3
    1d9a:	67 81       	ldd	r22, Z+7	; 0x07
    1d9c:	85 81       	ldd	r24, Z+5	; 0x05
    1d9e:	96 81       	ldd	r25, Z+6	; 0x06
    1da0:	0e 94 c2 10 	call	0x2184	; 0x2184 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>
    1da4:	18 2f       	mov	r17, r24
        if(rcode)
    1da6:	81 11       	cpse	r24, r1
    1da8:	7f c0       	rjmp	.+254    	; 0x1ea8 <_ZN6PS3USB4InitEhhb+0x29c>
                goto FailSetDevTblEntry;

        delay(200); //Give time for address change
    1daa:	68 ec       	ldi	r22, 0xC8	; 200
    1dac:	70 e0       	ldi	r23, 0x00	; 0
    1dae:	80 e0       	ldi	r24, 0x00	; 0
    1db0:	90 e0       	ldi	r25, 0x00	; 0
    1db2:	0e 94 de 06 	call	0xdbc	; 0xdbc <delay>

        rcode = pUsb->setConf(bAddress, epInfo[ PS3_CONTROL_PIPE ].epAddr, 1);
    1db6:	21 e0       	ldi	r18, 0x01	; 1
    1db8:	d7 01       	movw	r26, r14
    1dba:	18 96       	adiw	r26, 0x08	; 8
    1dbc:	4c 91       	ld	r20, X
    1dbe:	18 97       	sbiw	r26, 0x08	; 8
    1dc0:	17 96       	adiw	r26, 0x07	; 7
    1dc2:	6c 91       	ld	r22, X
    1dc4:	17 97       	sbiw	r26, 0x07	; 7
    1dc6:	15 96       	adiw	r26, 0x05	; 5
    1dc8:	8d 91       	ld	r24, X+
    1dca:	9c 91       	ld	r25, X
    1dcc:	16 97       	sbiw	r26, 0x06	; 6
    1dce:	0e 94 31 17 	call	0x2e62	; 0x2e62 <_ZN3USB7setConfEhhh>
    1dd2:	18 2f       	mov	r17, r24
        if(rcode)
    1dd4:	81 11       	cpse	r24, r1
    1dd6:	68 c0       	rjmp	.+208    	; 0x1ea8 <_ZN6PS3USB4InitEhhb+0x29c>
    1dd8:	f7 01       	movw	r30, r14
    1dda:	e6 59       	subi	r30, 0x96	; 150
    1ddc:	ff 4f       	sbci	r31, 0xFF	; 255
    1dde:	6f 01       	movw	r12, r30
                goto FailSetConfDescr;

        if(PID == PS3_PID || PID == PS3NAVIGATION_PID) {
    1de0:	f8 e6       	ldi	r31, 0x68	; 104
    1de2:	6f 16       	cp	r6, r31
    1de4:	f2 e0       	ldi	r31, 0x02	; 2
    1de6:	7f 06       	cpc	r7, r31
    1de8:	41 f0       	breq	.+16     	; 0x1dfa <_ZN6PS3USB4InitEhhb+0x1ee>
    1dea:	2f e2       	ldi	r18, 0x2F	; 47
    1dec:	62 16       	cp	r6, r18
    1dee:	24 e0       	ldi	r18, 0x04	; 4
    1df0:	72 06       	cpc	r7, r18
    1df2:	19 f5       	brne	.+70     	; 0x1e3a <_ZN6PS3USB4InitEhhb+0x22e>
                        PS3Connected = true;
                } else { // must be a navigation controller
#ifdef DEBUG_USB_HOST
                        Notify(PSTR("\r\nNavigation Controller Connected"), 0x80);
#endif
                        PS3NavigationConnected = true;
    1df4:	f7 01       	movw	r30, r14
    1df6:	04 83       	std	Z+4, r16	; 0x04
    1df8:	03 c0       	rjmp	.+6      	; 0x1e00 <_ZN6PS3USB4InitEhhb+0x1f4>
        if(PID == PS3_PID || PID == PS3NAVIGATION_PID) {
                if(PID == PS3_PID) {
#ifdef DEBUG_USB_HOST
                        Notify(PSTR("\r\nDualshock 3 Controller Connected"), 0x80);
#endif
                        PS3Connected = true;
    1dfa:	d7 01       	movw	r26, r14
    1dfc:	12 96       	adiw	r26, 0x02	; 2
    1dfe:	0c 93       	st	X, r16
#ifdef DEBUG_USB_HOST
                        Notify(PSTR("\r\nNavigation Controller Connected"), 0x80);
#endif
                        PS3NavigationConnected = true;
                }
                enable_sixaxis(); // The PS3 controller needs a special command before it starts sending data
    1e00:	c7 01       	movw	r24, r14
    1e02:	0e 94 94 0c 	call	0x1928	; 0x1928 <_ZN6PS3USB14enable_sixaxisEv>
    1e06:	eb e0       	ldi	r30, 0x0B	; 11
    1e08:	f1 e0       	ldi	r31, 0x01	; 1
    1e0a:	d6 01       	movw	r26, r12
    1e0c:	c7 01       	movw	r24, r14
    1e0e:	86 56       	subi	r24, 0x66	; 102
    1e10:	9f 4f       	sbci	r25, 0xFF	; 255

                // Needed for PS3 Dualshock and Navigation commands to work
                for(uint8_t i = 0; i < PS3_REPORT_BUFFER_SIZE; i++)
                        writeBuf[i] = pgm_read_byte(&PS3_REPORT_BUFFER[i]);
    1e12:	24 91       	lpm	r18, Z
    1e14:	2d 93       	st	X+, r18
    1e16:	31 96       	adiw	r30, 0x01	; 1
                        PS3NavigationConnected = true;
                }
                enable_sixaxis(); // The PS3 controller needs a special command before it starts sending data

                // Needed for PS3 Dualshock and Navigation commands to work
                for(uint8_t i = 0; i < PS3_REPORT_BUFFER_SIZE; i++)
    1e18:	8a 17       	cp	r24, r26
    1e1a:	9b 07       	cpc	r25, r27
    1e1c:	d1 f7       	brne	.-12     	; 0x1e12 <_ZN6PS3USB4InitEhhb+0x206>
                        writeBuf[i] = pgm_read_byte(&PS3_REPORT_BUFFER[i]);

                for(uint8_t i = 6; i < 10; i++)
                        readBuf[i] = 0x7F; // Set the analog joystick values to center position
    1e1e:	8f e7       	ldi	r24, 0x7F	; 127
    1e20:	d7 01       	movw	r26, r14
    1e22:	d0 96       	adiw	r26, 0x30	; 48
    1e24:	8c 93       	st	X, r24
    1e26:	d0 97       	sbiw	r26, 0x30	; 48
    1e28:	d1 96       	adiw	r26, 0x31	; 49
    1e2a:	8c 93       	st	X, r24
    1e2c:	d1 97       	sbiw	r26, 0x31	; 49
    1e2e:	d2 96       	adiw	r26, 0x32	; 50
    1e30:	8c 93       	st	X, r24
    1e32:	d2 97       	sbiw	r26, 0x32	; 50
    1e34:	d3 96       	adiw	r26, 0x33	; 51
    1e36:	8c 93       	st	X, r24
    1e38:	04 c0       	rjmp	.+8      	; 0x1e42 <_ZN6PS3USB4InitEhhb+0x236>
        } else { // must be a Motion controller
#ifdef DEBUG_USB_HOST
                Notify(PSTR("\r\nMotion Controller Connected"), 0x80);
#endif
                PS3MoveConnected = true;
    1e3a:	f7 01       	movw	r30, r14
    1e3c:	03 83       	std	Z+3, r16	; 0x03
                writeBuf[0] = 0x02; // Set report ID, this is needed for Move commands to work
    1e3e:	d6 01       	movw	r26, r12
    1e40:	bc 92       	st	X, r11
        }
        if(my_bdaddr[0] != 0x00 || my_bdaddr[1] != 0x00 || my_bdaddr[2] != 0x00 || my_bdaddr[3] != 0x00 || my_bdaddr[4] != 0x00 || my_bdaddr[5] != 0x00) {
    1e42:	f7 01       	movw	r30, r14
    1e44:	84 a1       	ldd	r24, Z+36	; 0x24
    1e46:	81 11       	cpse	r24, r1
    1e48:	0f c0       	rjmp	.+30     	; 0x1e68 <_ZN6PS3USB4InitEhhb+0x25c>
    1e4a:	85 a1       	ldd	r24, Z+37	; 0x25
    1e4c:	81 11       	cpse	r24, r1
    1e4e:	0c c0       	rjmp	.+24     	; 0x1e68 <_ZN6PS3USB4InitEhhb+0x25c>
    1e50:	86 a1       	ldd	r24, Z+38	; 0x26
    1e52:	81 11       	cpse	r24, r1
    1e54:	09 c0       	rjmp	.+18     	; 0x1e68 <_ZN6PS3USB4InitEhhb+0x25c>
    1e56:	87 a1       	ldd	r24, Z+39	; 0x27
    1e58:	81 11       	cpse	r24, r1
    1e5a:	06 c0       	rjmp	.+12     	; 0x1e68 <_ZN6PS3USB4InitEhhb+0x25c>
    1e5c:	80 a5       	ldd	r24, Z+40	; 0x28
    1e5e:	81 11       	cpse	r24, r1
    1e60:	03 c0       	rjmp	.+6      	; 0x1e68 <_ZN6PS3USB4InitEhhb+0x25c>
    1e62:	81 a5       	ldd	r24, Z+41	; 0x29
    1e64:	88 23       	and	r24, r24
    1e66:	79 f0       	breq	.+30     	; 0x1e86 <_ZN6PS3USB4InitEhhb+0x27a>
                if(PS3MoveConnected)
    1e68:	d7 01       	movw	r26, r14
    1e6a:	13 96       	adiw	r26, 0x03	; 3
    1e6c:	8c 91       	ld	r24, X
    1e6e:	b7 01       	movw	r22, r14
    1e70:	6c 5d       	subi	r22, 0xDC	; 220
    1e72:	7f 4f       	sbci	r23, 0xFF	; 255
    1e74:	88 23       	and	r24, r24
    1e76:	21 f0       	breq	.+8      	; 0x1e80 <_ZN6PS3USB4InitEhhb+0x274>
                        setMoveBdaddr(my_bdaddr); // Set internal Bluetooth address
    1e78:	c7 01       	movw	r24, r14
    1e7a:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <_ZN6PS3USB13setMoveBdaddrEPh>
    1e7e:	03 c0       	rjmp	.+6      	; 0x1e86 <_ZN6PS3USB4InitEhhb+0x27a>
                else
                        setBdaddr(my_bdaddr); // Set internal Bluetooth address
    1e80:	c7 01       	movw	r24, r14
    1e82:	0e 94 3f 0c 	call	0x187e	; 0x187e <_ZN6PS3USB9setBdaddrEPh>
                        Notify(PSTR(":"), 0x80);
                }
                D_PrintHex<uint8_t > (my_bdaddr[0], 0x80);
#endif
        }
        onInit();
    1e86:	c7 01       	movw	r24, r14
    1e88:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <_ZN6PS3USB6onInitEv>

        bPollEnable = true;
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	f7 01       	movw	r30, r14
    1e90:	83 8b       	std	Z+19, r24	; 0x13
        Notify(PSTR("\r\n"), 0x80);
        timer = (uint32_t)millis();
    1e92:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    1e96:	d7 01       	movw	r26, r14
    1e98:	54 96       	adiw	r26, 0x14	; 20
    1e9a:	6d 93       	st	X+, r22
    1e9c:	7d 93       	st	X+, r23
    1e9e:	8d 93       	st	X+, r24
    1ea0:	9c 93       	st	X, r25
    1ea2:	57 97       	sbiw	r26, 0x17	; 23
        return 0; // Successful configuration
    1ea4:	13 c0       	rjmp	.+38     	; 0x1ecc <_ZN6PS3USB4InitEhhb+0x2c0>

FailUnknownDevice:
#ifdef DEBUG_USB_HOST
        NotifyFailUnknownDevice(VID, PID);
#endif
        rcode = USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED;
    1ea6:	11 ed       	ldi	r17, 0xD1	; 209
Fail:
#ifdef DEBUG_USB_HOST
        Notify(PSTR("\r\nPS3 Init Failed, error code: "), 0x80);
        NotifyFail(rcode);
#endif
        Release();
    1ea8:	d7 01       	movw	r26, r14
    1eaa:	ed 91       	ld	r30, X+
    1eac:	fc 91       	ld	r31, X
    1eae:	04 80       	ldd	r0, Z+4	; 0x04
    1eb0:	f5 81       	ldd	r31, Z+5	; 0x05
    1eb2:	e0 2d       	mov	r30, r0
    1eb4:	c7 01       	movw	r24, r14
    1eb6:	09 95       	icall
        return rcode;
    1eb8:	51 2e       	mov	r5, r17
    1eba:	08 c0       	rjmp	.+16     	; 0x1ecc <_ZN6PS3USB4InitEhhb+0x2c0>
        // check if address has already been assigned to an instance
        if(bAddress) {
#ifdef DEBUG_USB_HOST
                Notify(PSTR("\r\nAddress in use"), 0x80);
#endif
                return USB_ERROR_CLASS_INSTANCE_ALREADY_IN_USE;
    1ebc:	29 ed       	ldi	r18, 0xD9	; 217
    1ebe:	52 2e       	mov	r5, r18
    1ec0:	05 c0       	rjmp	.+10     	; 0x1ecc <_ZN6PS3USB4InitEhhb+0x2c0>

        if(!p->epinfo) {
#ifdef DEBUG_USB_HOST
                Notify(PSTR("\r\nepinfo is null"), 0x80);
#endif
                return USB_ERROR_EPINFO_IS_NULL;
    1ec2:	97 ed       	ldi	r25, 0xD7	; 215
    1ec4:	59 2e       	mov	r5, r25
    1ec6:	02 c0       	rjmp	.+4      	; 0x1ecc <_ZN6PS3USB4InitEhhb+0x2c0>

        // Allocate new address according to device class
        bAddress = addrPool.AllocAddress(parent, false, port);

        if(!bAddress)
                return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;
    1ec8:	84 ed       	ldi	r24, 0xD4	; 212
    1eca:	58 2e       	mov	r5, r24
        Notify(PSTR("\r\nPS3 Init Failed, error code: "), 0x80);
        NotifyFail(rcode);
#endif
        Release();
        return rcode;
}
    1ecc:	85 2d       	mov	r24, r5
    1ece:	62 96       	adiw	r28, 0x12	; 18
    1ed0:	0f b6       	in	r0, 0x3f	; 63
    1ed2:	f8 94       	cli
    1ed4:	de bf       	out	0x3e, r29	; 62
    1ed6:	0f be       	out	0x3f, r0	; 63
    1ed8:	cd bf       	out	0x3d, r28	; 61
    1eda:	df 91       	pop	r29
    1edc:	cf 91       	pop	r28
    1ede:	1f 91       	pop	r17
    1ee0:	0f 91       	pop	r16
    1ee2:	ff 90       	pop	r15
    1ee4:	ef 90       	pop	r14
    1ee6:	df 90       	pop	r13
    1ee8:	cf 90       	pop	r12
    1eea:	bf 90       	pop	r11
    1eec:	af 90       	pop	r10
    1eee:	9f 90       	pop	r9
    1ef0:	8f 90       	pop	r8
    1ef2:	7f 90       	pop	r7
    1ef4:	6f 90       	pop	r6
    1ef6:	5f 90       	pop	r5
    1ef8:	4f 90       	pop	r4
    1efa:	3f 90       	pop	r3
    1efc:	2f 90       	pop	r2
    1efe:	08 95       	ret

00001f00 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh>:

//get string descriptor

uint8_t USB::getStrDescr(uint8_t addr, uint8_t ep, uint16_t ns, uint8_t index, uint16_t langid, uint8_t* dataptr) {
        return ( ctrlReq(addr, ep, bmREQ_GET_DESCR, USB_REQUEST_GET_DESCRIPTOR, index, USB_DESCRIPTOR_STRING, langid, ns, ns, dataptr, NULL));
}
    1f00:	cf 93       	push	r28
    1f02:	df 93       	push	r29
    1f04:	fc 01       	movw	r30, r24
    1f06:	86 2f       	mov	r24, r22
    1f08:	80 78       	andi	r24, 0x80	; 128
    1f0a:	a9 f4       	brne	.+42     	; 0x1f36 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x36>
    1f0c:	28 30       	cpi	r18, 0x08	; 8
    1f0e:	08 f0       	brcs	.+2      	; 0x1f12 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x12>
    1f10:	4d c0       	rjmp	.+154    	; 0x1fac <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0xac>
    1f12:	44 23       	and	r20, r20
    1f14:	21 f0       	breq	.+8      	; 0x1f1e <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x1e>
    1f16:	95 81       	ldd	r25, Z+5	; 0x05
    1f18:	97 30       	cpi	r25, 0x07	; 7
    1f1a:	09 f4       	brne	.+2      	; 0x1f1e <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x1e>
    1f1c:	47 c0       	rjmp	.+142    	; 0x1fac <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0xac>
    1f1e:	ef 01       	movw	r28, r30
    1f20:	a1 e0       	ldi	r26, 0x01	; 1
    1f22:	b0 e0       	ldi	r27, 0x00	; 0
    1f24:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f26:	99 23       	and	r25, r25
    1f28:	41 f0       	breq	.+16     	; 0x1f3a <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x3a>
    1f2a:	11 96       	adiw	r26, 0x01	; 1
    1f2c:	25 96       	adiw	r28, 0x05	; 5
    1f2e:	a0 31       	cpi	r26, 0x10	; 16
    1f30:	b1 05       	cpc	r27, r1
    1f32:	c1 f7       	brne	.-16     	; 0x1f24 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x24>
    1f34:	3b c0       	rjmp	.+118    	; 0x1fac <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0xac>
    1f36:	80 e0       	ldi	r24, 0x00	; 0
    1f38:	39 c0       	rjmp	.+114    	; 0x1fac <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0xac>
    1f3a:	61 11       	cpse	r22, r1
    1f3c:	1c c0       	rjmp	.+56     	; 0x1f76 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x76>
    1f3e:	85 e0       	ldi	r24, 0x05	; 5
    1f40:	8a 9f       	mul	r24, r26
    1f42:	e0 01       	movw	r28, r0
    1f44:	8b 9f       	mul	r24, r27
    1f46:	d0 0d       	add	r29, r0
    1f48:	11 24       	eor	r1, r1
    1f4a:	ce 0f       	add	r28, r30
    1f4c:	df 1f       	adc	r29, r31
    1f4e:	44 23       	and	r20, r20
    1f50:	31 f0       	breq	.+12     	; 0x1f5e <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x5e>
    1f52:	81 e4       	ldi	r24, 0x41	; 65
    1f54:	88 87       	std	Y+8, r24	; 0x08
    1f56:	85 81       	ldd	r24, Z+5	; 0x05
    1f58:	8f 5f       	subi	r24, 0xFF	; 255
    1f5a:	85 83       	std	Z+5, r24	; 0x05
    1f5c:	02 c0       	rjmp	.+4      	; 0x1f62 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x62>
    1f5e:	81 e0       	ldi	r24, 0x01	; 1
    1f60:	88 87       	std	Y+8, r24	; 0x08
    1f62:	25 e0       	ldi	r18, 0x05	; 5
    1f64:	2a 9f       	mul	r18, r26
    1f66:	c0 01       	movw	r24, r0
    1f68:	2b 9f       	mul	r18, r27
    1f6a:	90 0d       	add	r25, r0
    1f6c:	11 24       	eor	r1, r1
    1f6e:	e8 0f       	add	r30, r24
    1f70:	f9 1f       	adc	r31, r25
    1f72:	80 85       	ldd	r24, Z+8	; 0x08
    1f74:	1b c0       	rjmp	.+54     	; 0x1fac <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0xac>
    1f76:	67 70       	andi	r22, 0x07	; 7
    1f78:	66 0f       	add	r22, r22
    1f7a:	66 0f       	add	r22, r22
    1f7c:	66 0f       	add	r22, r22
    1f7e:	44 23       	and	r20, r20
    1f80:	41 f0       	breq	.+16     	; 0x1f92 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x92>
    1f82:	60 64       	ori	r22, 0x40	; 64
    1f84:	85 81       	ldd	r24, Z+5	; 0x05
    1f86:	8f 5f       	subi	r24, 0xFF	; 255
    1f88:	85 83       	std	Z+5, r24	; 0x05
    1f8a:	87 70       	andi	r24, 0x07	; 7
    1f8c:	68 7f       	andi	r22, 0xF8	; 248
    1f8e:	68 2b       	or	r22, r24
    1f90:	03 c0       	rjmp	.+6      	; 0x1f98 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x98>
    1f92:	27 70       	andi	r18, 0x07	; 7
    1f94:	68 7b       	andi	r22, 0xB8	; 184
    1f96:	62 2b       	or	r22, r18
    1f98:	25 e0       	ldi	r18, 0x05	; 5
    1f9a:	2a 9f       	mul	r18, r26
    1f9c:	c0 01       	movw	r24, r0
    1f9e:	2b 9f       	mul	r18, r27
    1fa0:	90 0d       	add	r25, r0
    1fa2:	11 24       	eor	r1, r1
    1fa4:	e8 0f       	add	r30, r24
    1fa6:	f9 1f       	adc	r31, r25
    1fa8:	60 87       	std	Z+8, r22	; 0x08
    1faa:	86 2f       	mov	r24, r22
    1fac:	df 91       	pop	r29
    1fae:	cf 91       	pop	r28
    1fb0:	08 95       	ret

00001fb2 <_ZN8SPIClass8transferEPvj.part.0>:
    1fb2:	fc 01       	movw	r30, r24
    1fb4:	20 81       	ld	r18, Z
    1fb6:	2e bd       	out	0x2e, r18	; 46
    1fb8:	9b 01       	movw	r18, r22
    1fba:	21 50       	subi	r18, 0x01	; 1
    1fbc:	31 09       	sbc	r19, r1
    1fbe:	41 f0       	breq	.+16     	; 0x1fd0 <_ZN8SPIClass8transferEPvj.part.0+0x1e>
    1fc0:	51 81       	ldd	r21, Z+1	; 0x01
    1fc2:	0d b4       	in	r0, 0x2d	; 45
    1fc4:	07 fe       	sbrs	r0, 7
    1fc6:	fd cf       	rjmp	.-6      	; 0x1fc2 <_ZN8SPIClass8transferEPvj.part.0+0x10>
    1fc8:	4e b5       	in	r20, 0x2e	; 46
    1fca:	5e bd       	out	0x2e, r21	; 46
    1fcc:	41 93       	st	Z+, r20
    1fce:	f5 cf       	rjmp	.-22     	; 0x1fba <_ZN8SPIClass8transferEPvj.part.0+0x8>
    1fd0:	61 50       	subi	r22, 0x01	; 1
    1fd2:	71 09       	sbc	r23, r1
    1fd4:	fc 01       	movw	r30, r24
    1fd6:	e6 0f       	add	r30, r22
    1fd8:	f7 1f       	adc	r31, r23
    1fda:	0d b4       	in	r0, 0x2d	; 45
    1fdc:	07 fe       	sbrs	r0, 7
    1fde:	fd cf       	rjmp	.-6      	; 0x1fda <_ZN8SPIClass8transferEPvj.part.0+0x28>
    1fe0:	8e b5       	in	r24, 0x2e	; 46
    1fe2:	80 83       	st	Z, r24
    1fe4:	08 95       	ret

00001fe6 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>:
    1fe6:	61 11       	cpse	r22, r1
    1fe8:	02 c0       	rjmp	.+4      	; 0x1fee <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh+0x8>
    1fea:	06 96       	adiw	r24, 0x06	; 6
    1fec:	08 95       	ret
    1fee:	fc 01       	movw	r30, r24
    1ff0:	21 e0       	ldi	r18, 0x01	; 1
    1ff2:	35 85       	ldd	r19, Z+13	; 0x0d
    1ff4:	63 17       	cp	r22, r19
    1ff6:	39 f0       	breq	.+14     	; 0x2006 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh+0x20>
    1ff8:	2f 5f       	subi	r18, 0xFF	; 255
    1ffa:	35 96       	adiw	r30, 0x05	; 5
    1ffc:	20 31       	cpi	r18, 0x10	; 16
    1ffe:	c9 f7       	brne	.-14     	; 0x1ff2 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh+0xc>
    2000:	80 e0       	ldi	r24, 0x00	; 0
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	08 95       	ret
    2006:	06 96       	adiw	r24, 0x06	; 6
    2008:	35 e0       	ldi	r19, 0x05	; 5
    200a:	23 9f       	mul	r18, r19
    200c:	80 0d       	add	r24, r0
    200e:	91 1d       	adc	r25, r1
    2010:	11 24       	eor	r1, r1
    2012:	08 95       	ret

00002014 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh.part.10.constprop.13>:
    2014:	df 92       	push	r13
    2016:	ef 92       	push	r14
    2018:	ff 92       	push	r15
    201a:	0f 93       	push	r16
    201c:	1f 93       	push	r17
    201e:	cf 93       	push	r28
    2020:	df 93       	push	r29
    2022:	ec 01       	movw	r28, r24
    2024:	e6 2e       	mov	r14, r22
    2026:	f1 2c       	mov	r15, r1
    2028:	85 e0       	ldi	r24, 0x05	; 5
    202a:	68 9f       	mul	r22, r24
    202c:	b0 01       	movw	r22, r0
    202e:	11 24       	eor	r1, r1
    2030:	fe 01       	movw	r30, r28
    2032:	e6 0f       	add	r30, r22
    2034:	f7 1f       	adc	r31, r23
    2036:	80 85       	ldd	r24, Z+8	; 0x08
    2038:	18 2f       	mov	r17, r24
    203a:	17 70       	andi	r17, 0x07	; 7
    203c:	86 ff       	sbrs	r24, 6
    203e:	17 c0       	rjmp	.+46     	; 0x206e <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh.part.10.constprop.13+0x5a>
    2040:	01 e0       	ldi	r16, 0x01	; 1
    2042:	85 e0       	ldi	r24, 0x05	; 5
    2044:	d8 2e       	mov	r13, r24
    2046:	fe 01       	movw	r30, r28
    2048:	d0 9e       	mul	r13, r16
    204a:	e0 0d       	add	r30, r0
    204c:	f1 1d       	adc	r31, r1
    204e:	11 24       	eor	r1, r1
    2050:	80 85       	ldd	r24, Z+8	; 0x08
    2052:	86 95       	lsr	r24
    2054:	86 95       	lsr	r24
    2056:	86 95       	lsr	r24
    2058:	87 70       	andi	r24, 0x07	; 7
    205a:	18 17       	cp	r17, r24
    205c:	f9 f0       	breq	.+62     	; 0x209c <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh.part.10.constprop.13+0x88>
    205e:	0f 5f       	subi	r16, 0xFF	; 255
    2060:	00 31       	cpi	r16, 0x10	; 16
    2062:	89 f7       	brne	.-30     	; 0x2046 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh.part.10.constprop.13+0x32>
    2064:	8d 81       	ldd	r24, Y+5	; 0x05
    2066:	81 13       	cpse	r24, r17
    2068:	02 c0       	rjmp	.+4      	; 0x206e <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh.part.10.constprop.13+0x5a>
    206a:	11 50       	subi	r17, 0x01	; 1
    206c:	1d 83       	std	Y+5, r17	; 0x05
    206e:	85 e0       	ldi	r24, 0x05	; 5
    2070:	8e 9d       	mul	r24, r14
    2072:	f0 01       	movw	r30, r0
    2074:	8f 9d       	mul	r24, r15
    2076:	f0 0d       	add	r31, r0
    2078:	11 24       	eor	r1, r1
    207a:	ec 0f       	add	r30, r28
    207c:	fd 1f       	adc	r31, r29
    207e:	10 86       	std	Z+8, r1	; 0x08
    2080:	81 e0       	ldi	r24, 0x01	; 1
    2082:	81 87       	std	Z+9, r24	; 0x09
    2084:	12 86       	std	Z+10, r1	; 0x0a
    2086:	22 96       	adiw	r28, 0x02	; 2
    2088:	d7 83       	std	Z+7, r29	; 0x07
    208a:	c6 83       	std	Z+6, r28	; 0x06
    208c:	df 91       	pop	r29
    208e:	cf 91       	pop	r28
    2090:	1f 91       	pop	r17
    2092:	0f 91       	pop	r16
    2094:	ff 90       	pop	r15
    2096:	ef 90       	pop	r14
    2098:	df 90       	pop	r13
    209a:	08 95       	ret
    209c:	60 2f       	mov	r22, r16
    209e:	ce 01       	movw	r24, r28
    20a0:	0e 94 0a 10 	call	0x2014	; 0x2014 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh.part.10.constprop.13>
    20a4:	d0 cf       	rjmp	.-96     	; 0x2046 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh.part.10.constprop.13+0x32>

000020a6 <_ZN15AddressPoolImplILh16EE11FreeAddressEh>:
    20a6:	fc 01       	movw	r30, r24
    20a8:	61 34       	cpi	r22, 0x41	; 65
    20aa:	99 f4       	brne	.+38     	; 0x20d2 <_ZN15AddressPoolImplILh16EE11FreeAddressEh+0x2c>
    20ac:	9c 01       	movw	r18, r24
    20ae:	25 5b       	subi	r18, 0xB5	; 181
    20b0:	3f 4f       	sbci	r19, 0xFF	; 255
    20b2:	61 e0       	ldi	r22, 0x01	; 1
    20b4:	ac 01       	movw	r20, r24
    20b6:	4e 5f       	subi	r20, 0xFE	; 254
    20b8:	5f 4f       	sbci	r21, 0xFF	; 255
    20ba:	15 86       	std	Z+13, r1	; 0x0d
    20bc:	66 87       	std	Z+14, r22	; 0x0e
    20be:	17 86       	std	Z+15, r1	; 0x0f
    20c0:	54 87       	std	Z+12, r21	; 0x0c
    20c2:	43 87       	std	Z+11, r20	; 0x0b
    20c4:	35 96       	adiw	r30, 0x05	; 5
    20c6:	e2 17       	cp	r30, r18
    20c8:	f3 07       	cpc	r31, r19
    20ca:	b9 f7       	brne	.-18     	; 0x20ba <_ZN15AddressPoolImplILh16EE11FreeAddressEh+0x14>
    20cc:	fc 01       	movw	r30, r24
    20ce:	15 82       	std	Z+5, r1	; 0x05
    20d0:	08 95       	ret
    20d2:	21 e0       	ldi	r18, 0x01	; 1
    20d4:	35 85       	ldd	r19, Z+13	; 0x0d
    20d6:	63 17       	cp	r22, r19
    20d8:	29 f0       	breq	.+10     	; 0x20e4 <_ZN15AddressPoolImplILh16EE11FreeAddressEh+0x3e>
    20da:	2f 5f       	subi	r18, 0xFF	; 255
    20dc:	35 96       	adiw	r30, 0x05	; 5
    20de:	20 31       	cpi	r18, 0x10	; 16
    20e0:	c9 f7       	brne	.-14     	; 0x20d4 <_ZN15AddressPoolImplILh16EE11FreeAddressEh+0x2e>
    20e2:	08 95       	ret
    20e4:	62 2f       	mov	r22, r18
    20e6:	0c 94 0a 10 	jmp	0x2014	; 0x2014 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh.part.10.constprop.13>

000020ea <_ZN3USBC1Ev>:
    20ea:	fc 01       	movw	r30, r24
    20ec:	80 e4       	ldi	r24, 0x40	; 64
    20ee:	94 e0       	ldi	r25, 0x04	; 4
    20f0:	91 83       	std	Z+1, r25	; 0x01
    20f2:	80 83       	st	Z, r24
    20f4:	15 82       	std	Z+5, r1	; 0x05
    20f6:	10 86       	std	Z+8, r1	; 0x08
    20f8:	81 e0       	ldi	r24, 0x01	; 1
    20fa:	81 87       	std	Z+9, r24	; 0x09
    20fc:	12 86       	std	Z+10, r1	; 0x0a
    20fe:	cf 01       	movw	r24, r30
    2100:	02 96       	adiw	r24, 0x02	; 2
    2102:	97 83       	std	Z+7, r25	; 0x07
    2104:	86 83       	std	Z+6, r24	; 0x06
    2106:	12 82       	std	Z+2, r1	; 0x02
    2108:	28 e0       	ldi	r18, 0x08	; 8
    210a:	23 83       	std	Z+3, r18	; 0x03
    210c:	2c e3       	ldi	r18, 0x3C	; 60
    210e:	24 83       	std	Z+4, r18	; 0x04
    2110:	df 01       	movw	r26, r30
    2112:	9f 01       	movw	r18, r30
    2114:	25 5b       	subi	r18, 0xB5	; 181
    2116:	3f 4f       	sbci	r19, 0xFF	; 255
    2118:	41 e0       	ldi	r20, 0x01	; 1
    211a:	1d 96       	adiw	r26, 0x0d	; 13
    211c:	1c 92       	st	X, r1
    211e:	1d 97       	sbiw	r26, 0x0d	; 13
    2120:	1e 96       	adiw	r26, 0x0e	; 14
    2122:	4c 93       	st	X, r20
    2124:	1e 97       	sbiw	r26, 0x0e	; 14
    2126:	1f 96       	adiw	r26, 0x0f	; 15
    2128:	1c 92       	st	X, r1
    212a:	1f 97       	sbiw	r26, 0x0f	; 15
    212c:	1c 96       	adiw	r26, 0x0c	; 12
    212e:	9c 93       	st	X, r25
    2130:	8e 93       	st	-X, r24
    2132:	1b 97       	sbiw	r26, 0x0b	; 11
    2134:	15 96       	adiw	r26, 0x05	; 5
    2136:	a2 17       	cp	r26, r18
    2138:	b3 07       	cpc	r27, r19
    213a:	79 f7       	brne	.-34     	; 0x211a <_ZN3USBC1Ev+0x30>
    213c:	ea 58       	subi	r30, 0x8A	; 138
    213e:	ff 4f       	sbci	r31, 0xFF	; 255
    2140:	10 82       	st	Z, r1
    2142:	81 e1       	ldi	r24, 0x11	; 17
    2144:	80 93 31 06 	sts	0x0631, r24	; 0x800631 <_ZL14usb_task_state>
    2148:	08 95       	ret

0000214a <_ZN3USB14getEpInfoEntryEhh>:
    214a:	cf 93       	push	r28
    214c:	c4 2f       	mov	r28, r20
    214e:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>
    2152:	00 97       	sbiw	r24, 0x00	; 0
    2154:	89 f0       	breq	.+34     	; 0x2178 <_ZN3USB14getEpInfoEntryEhh+0x2e>
    2156:	dc 01       	movw	r26, r24
    2158:	ed 91       	ld	r30, X+
    215a:	fc 91       	ld	r31, X
    215c:	11 97       	sbiw	r26, 0x01	; 1
    215e:	30 97       	sbiw	r30, 0x00	; 0
    2160:	59 f0       	breq	.+22     	; 0x2178 <_ZN3USB14getEpInfoEntryEhh+0x2e>
    2162:	13 96       	adiw	r26, 0x03	; 3
    2164:	9c 91       	ld	r25, X
    2166:	80 e0       	ldi	r24, 0x00	; 0
    2168:	89 17       	cp	r24, r25
    216a:	31 f0       	breq	.+12     	; 0x2178 <_ZN3USB14getEpInfoEntryEhh+0x2e>
    216c:	20 81       	ld	r18, Z
    216e:	2c 17       	cp	r18, r28
    2170:	31 f0       	breq	.+12     	; 0x217e <_ZN3USB14getEpInfoEntryEhh+0x34>
    2172:	33 96       	adiw	r30, 0x03	; 3
    2174:	8f 5f       	subi	r24, 0xFF	; 255
    2176:	f8 cf       	rjmp	.-16     	; 0x2168 <_ZN3USB14getEpInfoEntryEhh+0x1e>
    2178:	80 e0       	ldi	r24, 0x00	; 0
    217a:	90 e0       	ldi	r25, 0x00	; 0
    217c:	01 c0       	rjmp	.+2      	; 0x2180 <_ZN3USB14getEpInfoEntryEhh+0x36>
    217e:	cf 01       	movw	r24, r30
    2180:	cf 91       	pop	r28
    2182:	08 95       	ret

00002184 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>:
    2184:	0f 93       	push	r16
    2186:	1f 93       	push	r17
    2188:	cf 93       	push	r28
    218a:	df 93       	push	r29
    218c:	21 15       	cp	r18, r1
    218e:	31 05       	cpc	r19, r1
    2190:	71 f0       	breq	.+28     	; 0x21ae <_ZN3USB14setEpInfoEntryEhhP6EpInfo+0x2a>
    2192:	e9 01       	movw	r28, r18
    2194:	04 2f       	mov	r16, r20
    2196:	16 2f       	mov	r17, r22
    2198:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>
    219c:	fc 01       	movw	r30, r24
    219e:	89 2b       	or	r24, r25
    21a0:	41 f0       	breq	.+16     	; 0x21b2 <_ZN3USB14setEpInfoEntryEhhP6EpInfo+0x2e>
    21a2:	12 83       	std	Z+2, r17	; 0x02
    21a4:	d1 83       	std	Z+1, r29	; 0x01
    21a6:	c0 83       	st	Z, r28
    21a8:	03 83       	std	Z+3, r16	; 0x03
    21aa:	80 e0       	ldi	r24, 0x00	; 0
    21ac:	03 c0       	rjmp	.+6      	; 0x21b4 <_ZN3USB14setEpInfoEntryEhhP6EpInfo+0x30>
    21ae:	88 ed       	ldi	r24, 0xD8	; 216
    21b0:	01 c0       	rjmp	.+2      	; 0x21b4 <_ZN3USB14setEpInfoEntryEhhP6EpInfo+0x30>
    21b2:	86 ed       	ldi	r24, 0xD6	; 214
    21b4:	df 91       	pop	r29
    21b6:	cf 91       	pop	r28
    21b8:	1f 91       	pop	r17
    21ba:	0f 91       	pop	r16
    21bc:	08 95       	ret

000021be <_ZN4TPinI5PortbLh2EE5ClearEv>:
    21be:	2a 98       	cbi	0x05, 2	; 5
    21c0:	08 95       	ret

000021c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>:
    21c2:	cf 93       	push	r28
    21c4:	c8 2f       	mov	r28, r24
    21c6:	80 e5       	ldi	r24, 0x50	; 80
    21c8:	91 e0       	ldi	r25, 0x01	; 1
    21ca:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
    21ce:	0e 94 df 10 	call	0x21be	; 0x21be <_ZN4TPinI5PortbLh2EE5ClearEv>
    21d2:	8c 2f       	mov	r24, r28
    21d4:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    21d8:	80 e0       	ldi	r24, 0x00	; 0
    21da:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    21de:	c8 2f       	mov	r28, r24
    21e0:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <_ZN4TPinI5PortbLh2EE3SetEv>
    21e4:	0e 94 67 07 	call	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>
    21e8:	8c 2f       	mov	r24, r28
    21ea:	cf 91       	pop	r28
    21ec:	08 95       	ret

000021ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>:
    21ee:	0f 93       	push	r16
    21f0:	1f 93       	push	r17
    21f2:	cf 93       	push	r28
    21f4:	df 93       	push	r29
    21f6:	00 d0       	rcall	.+0      	; 0x21f8 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6+0xa>
    21f8:	cd b7       	in	r28, 0x3d	; 61
    21fa:	de b7       	in	r29, 0x3e	; 62
    21fc:	18 2f       	mov	r17, r24
    21fe:	06 2f       	mov	r16, r22
    2200:	80 e5       	ldi	r24, 0x50	; 80
    2202:	91 e0       	ldi	r25, 0x01	; 1
    2204:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
    2208:	0e 94 df 10 	call	0x21be	; 0x21be <_ZN4TPinI5PortbLh2EE5ClearEv>
    220c:	12 60       	ori	r17, 0x02	; 2
    220e:	19 83       	std	Y+1, r17	; 0x01
    2210:	0a 83       	std	Y+2, r16	; 0x02
    2212:	62 e0       	ldi	r22, 0x02	; 2
    2214:	70 e0       	ldi	r23, 0x00	; 0
    2216:	ce 01       	movw	r24, r28
    2218:	01 96       	adiw	r24, 0x01	; 1
    221a:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <_ZN8SPIClass8transferEPvj.part.0>
    221e:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <_ZN4TPinI5PortbLh2EE3SetEv>
    2222:	0e 94 67 07 	call	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>
    2226:	0f 90       	pop	r0
    2228:	0f 90       	pop	r0
    222a:	df 91       	pop	r29
    222c:	cf 91       	pop	r28
    222e:	1f 91       	pop	r17
    2230:	0f 91       	pop	r16
    2232:	08 95       	ret

00002234 <_ZN3USB10SetAddressEhhPP6EpInfoPj>:
    2234:	8f 92       	push	r8
    2236:	9f 92       	push	r9
    2238:	af 92       	push	r10
    223a:	bf 92       	push	r11
    223c:	cf 92       	push	r12
    223e:	df 92       	push	r13
    2240:	ef 92       	push	r14
    2242:	ff 92       	push	r15
    2244:	0f 93       	push	r16
    2246:	1f 93       	push	r17
    2248:	cf 93       	push	r28
    224a:	df 93       	push	r29
    224c:	ec 01       	movw	r28, r24
    224e:	d6 2e       	mov	r13, r22
    2250:	c4 2e       	mov	r12, r20
    2252:	59 01       	movw	r10, r18
    2254:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>
    2258:	7c 01       	movw	r14, r24
    225a:	00 97       	sbiw	r24, 0x00	; 0
    225c:	09 f4       	brne	.+2      	; 0x2260 <_ZN3USB10SetAddressEhhPP6EpInfoPj+0x2c>
    225e:	45 c0       	rjmp	.+138    	; 0x22ea <_ZN3USB10SetAddressEhhPP6EpInfoPj+0xb6>
    2260:	fc 01       	movw	r30, r24
    2262:	80 81       	ld	r24, Z
    2264:	91 81       	ldd	r25, Z+1	; 0x01
    2266:	89 2b       	or	r24, r25
    2268:	09 f4       	brne	.+2      	; 0x226c <_ZN3USB10SetAddressEhhPP6EpInfoPj+0x38>
    226a:	41 c0       	rjmp	.+130    	; 0x22ee <_ZN3USB10SetAddressEhhPP6EpInfoPj+0xba>
    226c:	4c 2d       	mov	r20, r12
    226e:	6d 2d       	mov	r22, r13
    2270:	ce 01       	movw	r24, r28
    2272:	0e 94 a5 10 	call	0x214a	; 0x214a <_ZN3USB14getEpInfoEntryEhh>
    2276:	f5 01       	movw	r30, r10
    2278:	91 83       	std	Z+1, r25	; 0x01
    227a:	80 83       	st	Z, r24
    227c:	00 97       	sbiw	r24, 0x00	; 0
    227e:	c9 f1       	breq	.+114    	; 0x22f2 <_ZN3USB10SetAddressEhhPP6EpInfoPj+0xbe>
    2280:	fc 01       	movw	r30, r24
    2282:	82 81       	ldd	r24, Z+2	; 0x02
    2284:	86 95       	lsr	r24
    2286:	86 95       	lsr	r24
    2288:	90 e0       	ldi	r25, 0x00	; 0
    228a:	80 31       	cpi	r24, 0x10	; 16
    228c:	91 05       	cpc	r25, r1
    228e:	14 f0       	brlt	.+4      	; 0x2294 <_ZN3USB10SetAddressEhhPP6EpInfoPj+0x60>
    2290:	8f e0       	ldi	r24, 0x0F	; 15
    2292:	90 e0       	ldi	r25, 0x00	; 0
    2294:	41 e0       	ldi	r20, 0x01	; 1
    2296:	50 e0       	ldi	r21, 0x00	; 0
    2298:	60 e0       	ldi	r22, 0x00	; 0
    229a:	70 e0       	ldi	r23, 0x00	; 0
    229c:	4a 01       	movw	r8, r20
    229e:	5b 01       	movw	r10, r22
    22a0:	04 c0       	rjmp	.+8      	; 0x22aa <_ZN3USB10SetAddressEhhPP6EpInfoPj+0x76>
    22a2:	88 0c       	add	r8, r8
    22a4:	99 1c       	adc	r9, r9
    22a6:	aa 1c       	adc	r10, r10
    22a8:	bb 1c       	adc	r11, r11
    22aa:	8a 95       	dec	r24
    22ac:	d2 f7       	brpl	.-12     	; 0x22a2 <_ZN3USB10SetAddressEhhPP6EpInfoPj+0x6e>
    22ae:	d5 01       	movw	r26, r10
    22b0:	c4 01       	movw	r24, r8
    22b2:	01 97       	sbiw	r24, 0x01	; 1
    22b4:	f8 01       	movw	r30, r16
    22b6:	91 83       	std	Z+1, r25	; 0x01
    22b8:	80 83       	st	Z, r24
    22ba:	6d 2d       	mov	r22, r13
    22bc:	80 ee       	ldi	r24, 0xE0	; 224
    22be:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    22c2:	88 ed       	ldi	r24, 0xD8	; 216
    22c4:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    22c8:	f7 01       	movw	r30, r14
    22ca:	94 81       	ldd	r25, Z+4	; 0x04
    22cc:	99 23       	and	r25, r25
    22ce:	31 f0       	breq	.+12     	; 0x22dc <_ZN3USB10SetAddressEhhPP6EpInfoPj+0xa8>
    22d0:	ca 58       	subi	r28, 0x8A	; 138
    22d2:	df 4f       	sbci	r29, 0xFF	; 255
    22d4:	68 81       	ld	r22, Y
    22d6:	62 60       	ori	r22, 0x02	; 2
    22d8:	68 2b       	or	r22, r24
    22da:	02 c0       	rjmp	.+4      	; 0x22e0 <_ZN3USB10SetAddressEhhPP6EpInfoPj+0xac>
    22dc:	68 2f       	mov	r22, r24
    22de:	69 7f       	andi	r22, 0xF9	; 249
    22e0:	88 ed       	ldi	r24, 0xD8	; 216
    22e2:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    22e6:	80 e0       	ldi	r24, 0x00	; 0
    22e8:	05 c0       	rjmp	.+10     	; 0x22f4 <_ZN3USB10SetAddressEhhPP6EpInfoPj+0xc0>
    22ea:	86 ed       	ldi	r24, 0xD6	; 214
    22ec:	03 c0       	rjmp	.+6      	; 0x22f4 <_ZN3USB10SetAddressEhhPP6EpInfoPj+0xc0>
    22ee:	87 ed       	ldi	r24, 0xD7	; 215
    22f0:	01 c0       	rjmp	.+2      	; 0x22f4 <_ZN3USB10SetAddressEhhPP6EpInfoPj+0xc0>
    22f2:	8b ed       	ldi	r24, 0xDB	; 219
    22f4:	df 91       	pop	r29
    22f6:	cf 91       	pop	r28
    22f8:	1f 91       	pop	r17
    22fa:	0f 91       	pop	r16
    22fc:	ff 90       	pop	r15
    22fe:	ef 90       	pop	r14
    2300:	df 90       	pop	r13
    2302:	cf 90       	pop	r12
    2304:	bf 90       	pop	r11
    2306:	af 90       	pop	r10
    2308:	9f 90       	pop	r9
    230a:	8f 90       	pop	r8
    230c:	08 95       	ret

0000230e <_ZN3USB11dispatchPktEhhj>:
    230e:	8f 92       	push	r8
    2310:	9f 92       	push	r9
    2312:	af 92       	push	r10
    2314:	bf 92       	push	r11
    2316:	cf 92       	push	r12
    2318:	df 92       	push	r13
    231a:	ef 92       	push	r14
    231c:	ff 92       	push	r15
    231e:	0f 93       	push	r16
    2320:	1f 93       	push	r17
    2322:	cf 93       	push	r28
    2324:	df 93       	push	r29
    2326:	86 2e       	mov	r8, r22
    2328:	94 2e       	mov	r9, r20
    232a:	59 01       	movw	r10, r18
    232c:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    2330:	6b 01       	movw	r12, r22
    2332:	7c 01       	movw	r14, r24
    2334:	28 e8       	ldi	r18, 0x88	; 136
    2336:	c2 0e       	add	r12, r18
    2338:	23 e1       	ldi	r18, 0x13	; 19
    233a:	d2 1e       	adc	r13, r18
    233c:	e1 1c       	adc	r14, r1
    233e:	f1 1c       	adc	r15, r1
    2340:	00 e0       	ldi	r16, 0x00	; 0
    2342:	10 e0       	ldi	r17, 0x00	; 0
    2344:	d0 e0       	ldi	r29, 0x00	; 0
    2346:	c0 e0       	ldi	r28, 0x00	; 0
    2348:	98 28       	or	r9, r8
    234a:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    234e:	dc 01       	movw	r26, r24
    2350:	cb 01       	movw	r24, r22
    2352:	8c 19       	sub	r24, r12
    2354:	9d 09       	sbc	r25, r13
    2356:	ae 09       	sbc	r26, r14
    2358:	bf 09       	sbc	r27, r15
    235a:	b7 ff       	sbrs	r27, 7
    235c:	2d c0       	rjmp	.+90     	; 0x23b8 <_ZN3USB11dispatchPktEhhj+0xaa>
    235e:	69 2d       	mov	r22, r9
    2360:	80 ef       	ldi	r24, 0xF0	; 240
    2362:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    2366:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    236a:	dc 01       	movw	r26, r24
    236c:	cb 01       	movw	r24, r22
    236e:	8c 19       	sub	r24, r12
    2370:	9d 09       	sbc	r25, r13
    2372:	ae 09       	sbc	r26, r14
    2374:	bf 09       	sbc	r27, r15
    2376:	b7 ff       	sbrs	r27, 7
    2378:	09 c0       	rjmp	.+18     	; 0x238c <_ZN3USB11dispatchPktEhhj+0x7e>
    237a:	88 ec       	ldi	r24, 0xC8	; 200
    237c:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    2380:	87 ff       	sbrs	r24, 7
    2382:	f1 cf       	rjmp	.-30     	; 0x2366 <_ZN3USB11dispatchPktEhhj+0x58>
    2384:	60 e8       	ldi	r22, 0x80	; 128
    2386:	88 ec       	ldi	r24, 0xC8	; 200
    2388:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    238c:	88 ef       	ldi	r24, 0xF8	; 248
    238e:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    2392:	c8 2f       	mov	r28, r24
    2394:	cf 70       	andi	r28, 0x0F	; 15
    2396:	c4 30       	cpi	r28, 0x04	; 4
    2398:	19 f0       	breq	.+6      	; 0x23a0 <_ZN3USB11dispatchPktEhhj+0x92>
    239a:	ce 30       	cpi	r28, 0x0E	; 14
    239c:	51 f0       	breq	.+20     	; 0x23b2 <_ZN3USB11dispatchPktEhhj+0xa4>
    239e:	0c c0       	rjmp	.+24     	; 0x23b8 <_ZN3USB11dispatchPktEhhj+0xaa>
    23a0:	0f 5f       	subi	r16, 0xFF	; 255
    23a2:	1f 4f       	sbci	r17, 0xFF	; 255
    23a4:	a1 14       	cp	r10, r1
    23a6:	b1 04       	cpc	r11, r1
    23a8:	81 f2       	breq	.-96     	; 0x234a <_ZN3USB11dispatchPktEhhj+0x3c>
    23aa:	0a 15       	cp	r16, r10
    23ac:	1b 05       	cpc	r17, r11
    23ae:	69 f6       	brne	.-102    	; 0x234a <_ZN3USB11dispatchPktEhhj+0x3c>
    23b0:	03 c0       	rjmp	.+6      	; 0x23b8 <_ZN3USB11dispatchPktEhhj+0xaa>
    23b2:	df 5f       	subi	r29, 0xFF	; 255
    23b4:	d3 30       	cpi	r29, 0x03	; 3
    23b6:	49 f6       	brne	.-110    	; 0x234a <_ZN3USB11dispatchPktEhhj+0x3c>
    23b8:	8c 2f       	mov	r24, r28
    23ba:	df 91       	pop	r29
    23bc:	cf 91       	pop	r28
    23be:	1f 91       	pop	r17
    23c0:	0f 91       	pop	r16
    23c2:	ff 90       	pop	r15
    23c4:	ef 90       	pop	r14
    23c6:	df 90       	pop	r13
    23c8:	cf 90       	pop	r12
    23ca:	bf 90       	pop	r11
    23cc:	af 90       	pop	r10
    23ce:	9f 90       	pop	r9
    23d0:	8f 90       	pop	r8
    23d2:	08 95       	ret

000023d4 <_ZN3USB13AttemptConfigEhhhb>:
    23d4:	9f 92       	push	r9
    23d6:	af 92       	push	r10
    23d8:	bf 92       	push	r11
    23da:	cf 92       	push	r12
    23dc:	df 92       	push	r13
    23de:	ef 92       	push	r14
    23e0:	ff 92       	push	r15
    23e2:	0f 93       	push	r16
    23e4:	1f 93       	push	r17
    23e6:	cf 93       	push	r28
    23e8:	df 93       	push	r29
    23ea:	7c 01       	movw	r14, r24
    23ec:	d4 2f       	mov	r29, r20
    23ee:	12 2f       	mov	r17, r18
    23f0:	90 2e       	mov	r9, r16
    23f2:	00 e0       	ldi	r16, 0x00	; 0
    23f4:	6c 01       	movw	r12, r24
    23f6:	c6 0e       	add	r12, r22
    23f8:	d1 1c       	adc	r13, r1
    23fa:	c6 0e       	add	r12, r22
    23fc:	d1 1c       	adc	r13, r1
    23fe:	86 e5       	ldi	r24, 0x56	; 86
    2400:	c8 0e       	add	r12, r24
    2402:	d1 1c       	adc	r13, r1
    2404:	a4 2e       	mov	r10, r20
    2406:	b1 2c       	mov	r11, r1
    2408:	ab e2       	ldi	r26, 0x2B	; 43
    240a:	aa 0e       	add	r10, r26
    240c:	b1 1c       	adc	r11, r1
    240e:	aa 0c       	add	r10, r10
    2410:	bb 1c       	adc	r11, r11
    2412:	ae 0c       	add	r10, r14
    2414:	bf 1c       	adc	r11, r15
    2416:	f6 01       	movw	r30, r12
    2418:	80 81       	ld	r24, Z
    241a:	91 81       	ldd	r25, Z+1	; 0x01
    241c:	dc 01       	movw	r26, r24
    241e:	ed 91       	ld	r30, X+
    2420:	fc 91       	ld	r31, X
    2422:	02 80       	ldd	r0, Z+2	; 0x02
    2424:	f3 81       	ldd	r31, Z+3	; 0x03
    2426:	e0 2d       	mov	r30, r0
    2428:	29 2d       	mov	r18, r9
    242a:	41 2f       	mov	r20, r17
    242c:	6d 2f       	mov	r22, r29
    242e:	09 95       	icall
    2430:	80 3e       	cpi	r24, 0xE0	; 224
    2432:	c9 f4       	brne	.+50     	; 0x2466 <_ZN3USB13AttemptConfigEhhhb+0x92>
    2434:	d1 11       	cpse	r29, r1
    2436:	0b c0       	rjmp	.+22     	; 0x244e <_ZN3USB13AttemptConfigEhhhb+0x7a>
    2438:	61 e0       	ldi	r22, 0x01	; 1
    243a:	88 ee       	ldi	r24, 0xE8	; 232
    243c:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    2440:	66 e6       	ldi	r22, 0x66	; 102
    2442:	70 e0       	ldi	r23, 0x00	; 0
    2444:	80 e0       	ldi	r24, 0x00	; 0
    2446:	90 e0       	ldi	r25, 0x00	; 0
    2448:	0e 94 de 06 	call	0xdbc	; 0xdbc <delay>
    244c:	14 c0       	rjmp	.+40     	; 0x2476 <_ZN3USB13AttemptConfigEhhhb+0xa2>
    244e:	f5 01       	movw	r30, r10
    2450:	80 81       	ld	r24, Z
    2452:	91 81       	ldd	r25, Z+1	; 0x01
    2454:	dc 01       	movw	r26, r24
    2456:	ed 91       	ld	r30, X+
    2458:	fc 91       	ld	r31, X
    245a:	02 84       	ldd	r0, Z+10	; 0x0a
    245c:	f3 85       	ldd	r31, Z+11	; 0x0b
    245e:	e0 2d       	mov	r30, r0
    2460:	61 2f       	mov	r22, r17
    2462:	09 95       	icall
    2464:	08 c0       	rjmp	.+16     	; 0x2476 <_ZN3USB13AttemptConfigEhhhb+0xa2>
    2466:	8d 30       	cpi	r24, 0x0D	; 13
    2468:	21 f4       	brne	.+8      	; 0x2472 <_ZN3USB13AttemptConfigEhhhb+0x9e>
    246a:	03 30       	cpi	r16, 0x03	; 3
    246c:	08 f0       	brcs	.+2      	; 0x2470 <_ZN3USB13AttemptConfigEhhhb+0x9c>
    246e:	3f c0       	rjmp	.+126    	; 0x24ee <_ZN3USB13AttemptConfigEhhhb+0x11a>
    2470:	14 c0       	rjmp	.+40     	; 0x249a <_ZN3USB13AttemptConfigEhhhb+0xc6>
    2472:	81 11       	cpse	r24, r1
    2474:	3f c0       	rjmp	.+126    	; 0x24f4 <_ZN3USB13AttemptConfigEhhhb+0x120>
    2476:	f6 01       	movw	r30, r12
    2478:	80 81       	ld	r24, Z
    247a:	91 81       	ldd	r25, Z+1	; 0x01
    247c:	dc 01       	movw	r26, r24
    247e:	ed 91       	ld	r30, X+
    2480:	fc 91       	ld	r31, X
    2482:	01 90       	ld	r0, Z+
    2484:	f0 81       	ld	r31, Z
    2486:	e0 2d       	mov	r30, r0
    2488:	29 2d       	mov	r18, r9
    248a:	41 2f       	mov	r20, r17
    248c:	6d 2f       	mov	r22, r29
    248e:	09 95       	icall
    2490:	c8 2f       	mov	r28, r24
    2492:	8d 30       	cpi	r24, 0x0D	; 13
    2494:	51 f4       	brne	.+20     	; 0x24aa <_ZN3USB13AttemptConfigEhhhb+0xd6>
    2496:	03 30       	cpi	r16, 0x03	; 3
    2498:	50 f4       	brcc	.+20     	; 0x24ae <_ZN3USB13AttemptConfigEhhhb+0xda>
    249a:	64 e6       	ldi	r22, 0x64	; 100
    249c:	70 e0       	ldi	r23, 0x00	; 0
    249e:	80 e0       	ldi	r24, 0x00	; 0
    24a0:	90 e0       	ldi	r25, 0x00	; 0
    24a2:	0e 94 de 06 	call	0xdbc	; 0xdbc <delay>
    24a6:	0f 5f       	subi	r16, 0xFF	; 255
    24a8:	b6 cf       	rjmp	.-148    	; 0x2416 <_ZN3USB13AttemptConfigEhhhb+0x42>
    24aa:	88 23       	and	r24, r24
    24ac:	11 f1       	breq	.+68     	; 0x24f2 <_ZN3USB13AttemptConfigEhhhb+0x11e>
    24ae:	d1 11       	cpse	r29, r1
    24b0:	0b c0       	rjmp	.+22     	; 0x24c8 <_ZN3USB13AttemptConfigEhhhb+0xf4>
    24b2:	61 e0       	ldi	r22, 0x01	; 1
    24b4:	88 ee       	ldi	r24, 0xE8	; 232
    24b6:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    24ba:	66 e6       	ldi	r22, 0x66	; 102
    24bc:	70 e0       	ldi	r23, 0x00	; 0
    24be:	80 e0       	ldi	r24, 0x00	; 0
    24c0:	90 e0       	ldi	r25, 0x00	; 0
    24c2:	0e 94 de 06 	call	0xdbc	; 0xdbc <delay>
    24c6:	11 c0       	rjmp	.+34     	; 0x24ea <_ZN3USB13AttemptConfigEhhhb+0x116>
    24c8:	ed 2f       	mov	r30, r29
    24ca:	f0 e0       	ldi	r31, 0x00	; 0
    24cc:	bb 96       	adiw	r30, 0x2b	; 43
    24ce:	ee 0f       	add	r30, r30
    24d0:	ff 1f       	adc	r31, r31
    24d2:	ee 0d       	add	r30, r14
    24d4:	ff 1d       	adc	r31, r15
    24d6:	80 81       	ld	r24, Z
    24d8:	91 81       	ldd	r25, Z+1	; 0x01
    24da:	dc 01       	movw	r26, r24
    24dc:	ed 91       	ld	r30, X+
    24de:	fc 91       	ld	r31, X
    24e0:	02 84       	ldd	r0, Z+10	; 0x0a
    24e2:	f3 85       	ldd	r31, Z+11	; 0x0b
    24e4:	e0 2d       	mov	r30, r0
    24e6:	61 2f       	mov	r22, r17
    24e8:	09 95       	icall
    24ea:	8c 2f       	mov	r24, r28
    24ec:	03 c0       	rjmp	.+6      	; 0x24f4 <_ZN3USB13AttemptConfigEhhhb+0x120>
    24ee:	8d e0       	ldi	r24, 0x0D	; 13
    24f0:	01 c0       	rjmp	.+2      	; 0x24f4 <_ZN3USB13AttemptConfigEhhhb+0x120>
    24f2:	80 e0       	ldi	r24, 0x00	; 0
    24f4:	df 91       	pop	r29
    24f6:	cf 91       	pop	r28
    24f8:	1f 91       	pop	r17
    24fa:	0f 91       	pop	r16
    24fc:	ff 90       	pop	r15
    24fe:	ef 90       	pop	r14
    2500:	df 90       	pop	r13
    2502:	cf 90       	pop	r12
    2504:	bf 90       	pop	r11
    2506:	af 90       	pop	r10
    2508:	9f 90       	pop	r9
    250a:	08 95       	ret

0000250c <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE7bytesWrEhhPh.isra.7>:
    250c:	0f 93       	push	r16
    250e:	1f 93       	push	r17
    2510:	cf 93       	push	r28
    2512:	df 93       	push	r29
    2514:	c8 2f       	mov	r28, r24
    2516:	d6 2f       	mov	r29, r22
    2518:	8a 01       	movw	r16, r20
    251a:	80 e5       	ldi	r24, 0x50	; 80
    251c:	91 e0       	ldi	r25, 0x01	; 1
    251e:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
    2522:	0e 94 df 10 	call	0x21be	; 0x21be <_ZN4TPinI5PortbLh2EE5ClearEv>
    2526:	8c 2f       	mov	r24, r28
    2528:	82 60       	ori	r24, 0x02	; 2
    252a:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    252e:	cd 2f       	mov	r28, r29
    2530:	d0 e0       	ldi	r29, 0x00	; 0
    2532:	20 97       	sbiw	r28, 0x00	; 0
    2534:	21 f0       	breq	.+8      	; 0x253e <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE7bytesWrEhhPh.isra.7+0x32>
    2536:	be 01       	movw	r22, r28
    2538:	c8 01       	movw	r24, r16
    253a:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <_ZN8SPIClass8transferEPvj.part.0>
    253e:	c0 0f       	add	r28, r16
    2540:	d1 1f       	adc	r29, r17
    2542:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <_ZN4TPinI5PortbLh2EE3SetEv>
    2546:	0e 94 67 07 	call	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>
    254a:	ce 01       	movw	r24, r28
    254c:	df 91       	pop	r29
    254e:	cf 91       	pop	r28
    2550:	1f 91       	pop	r17
    2552:	0f 91       	pop	r16
    2554:	08 95       	ret

00002556 <_ZN3USB11OutTransferEP6EpInfojjPh>:
    2556:	2f 92       	push	r2
    2558:	3f 92       	push	r3
    255a:	4f 92       	push	r4
    255c:	5f 92       	push	r5
    255e:	6f 92       	push	r6
    2560:	7f 92       	push	r7
    2562:	8f 92       	push	r8
    2564:	9f 92       	push	r9
    2566:	af 92       	push	r10
    2568:	bf 92       	push	r11
    256a:	cf 92       	push	r12
    256c:	df 92       	push	r13
    256e:	ef 92       	push	r14
    2570:	ff 92       	push	r15
    2572:	0f 93       	push	r16
    2574:	1f 93       	push	r17
    2576:	cf 93       	push	r28
    2578:	df 93       	push	r29
    257a:	00 d0       	rcall	.+0      	; 0x257c <_ZN3USB11OutTransferEP6EpInfojjPh+0x26>
    257c:	00 d0       	rcall	.+0      	; 0x257e <_ZN3USB11OutTransferEP6EpInfojjPh+0x28>
    257e:	1f 92       	push	r1
    2580:	cd b7       	in	r28, 0x3d	; 61
    2582:	de b7       	in	r29, 0x3e	; 62
    2584:	7d 83       	std	Y+5, r23	; 0x05
    2586:	6c 83       	std	Y+4, r22	; 0x04
    2588:	4a 01       	movw	r8, r20
    258a:	69 01       	movw	r12, r18
    258c:	fb 01       	movw	r30, r22
    258e:	f1 80       	ldd	r15, Z+1	; 0x01
    2590:	8f ef       	ldi	r24, 0xFF	; 255
    2592:	8f 0d       	add	r24, r15
    2594:	80 34       	cpi	r24, 0x40	; 64
    2596:	08 f0       	brcs	.+2      	; 0x259a <_ZN3USB11OutTransferEP6EpInfojjPh+0x44>
    2598:	74 c0       	rjmp	.+232    	; 0x2682 <_ZN3USB11OutTransferEP6EpInfojjPh+0x12c>
    259a:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    259e:	2b 01       	movw	r4, r22
    25a0:	3c 01       	movw	r6, r24
    25a2:	f8 e8       	ldi	r31, 0x88	; 136
    25a4:	4f 0e       	add	r4, r31
    25a6:	f3 e1       	ldi	r31, 0x13	; 19
    25a8:	5f 1e       	adc	r5, r31
    25aa:	61 1c       	adc	r6, r1
    25ac:	71 1c       	adc	r7, r1
    25ae:	ec 81       	ldd	r30, Y+4	; 0x04
    25b0:	fd 81       	ldd	r31, Y+5	; 0x05
    25b2:	82 81       	ldd	r24, Z+2	; 0x02
    25b4:	80 fd       	sbrc	r24, 0
    25b6:	02 c0       	rjmp	.+4      	; 0x25bc <_ZN3USB11OutTransferEP6EpInfojjPh+0x66>
    25b8:	60 e4       	ldi	r22, 0x40	; 64
    25ba:	01 c0       	rjmp	.+2      	; 0x25be <_ZN3USB11OutTransferEP6EpInfojjPh+0x68>
    25bc:	60 e8       	ldi	r22, 0x80	; 128
    25be:	88 ee       	ldi	r24, 0xE8	; 232
    25c0:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    25c4:	31 2c       	mov	r3, r1
    25c6:	8f 2d       	mov	r24, r15
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	9a 83       	std	Y+2, r25	; 0x02
    25cc:	89 83       	std	Y+1, r24	; 0x01
    25ce:	c1 14       	cp	r12, r1
    25d0:	d1 04       	cpc	r13, r1
    25d2:	09 f4       	brne	.+2      	; 0x25d6 <_ZN3USB11OutTransferEP6EpInfojjPh+0x80>
    25d4:	48 c0       	rjmp	.+144    	; 0x2666 <_ZN3USB11OutTransferEP6EpInfojjPh+0x110>
    25d6:	e9 80       	ldd	r14, Y+1	; 0x01
    25d8:	fa 80       	ldd	r15, Y+2	; 0x02
    25da:	ce 14       	cp	r12, r14
    25dc:	df 04       	cpc	r13, r15
    25de:	08 f4       	brcc	.+2      	; 0x25e2 <_ZN3USB11OutTransferEP6EpInfojjPh+0x8c>
    25e0:	76 01       	movw	r14, r12
    25e2:	eb 82       	std	Y+3, r14	; 0x03
    25e4:	a8 01       	movw	r20, r16
    25e6:	6e 2d       	mov	r22, r14
    25e8:	80 e1       	ldi	r24, 0x10	; 16
    25ea:	0e 94 86 12 	call	0x250c	; 0x250c <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE7bytesWrEhhPh.isra.7>
    25ee:	6e 2d       	mov	r22, r14
    25f0:	88 e3       	ldi	r24, 0x38	; 56
    25f2:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    25f6:	ec 81       	ldd	r30, Y+4	; 0x04
    25f8:	fd 81       	ldd	r31, Y+5	; 0x05
    25fa:	60 81       	ld	r22, Z
    25fc:	60 62       	ori	r22, 0x20	; 32
    25fe:	80 ef       	ldi	r24, 0xF0	; 240
    2600:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    2604:	88 ec       	ldi	r24, 0xC8	; 200
    2606:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    260a:	87 ff       	sbrs	r24, 7
    260c:	fb cf       	rjmp	.-10     	; 0x2604 <_ZN3USB11OutTransferEP6EpInfojjPh+0xae>
    260e:	60 e8       	ldi	r22, 0x80	; 128
    2610:	88 ec       	ldi	r24, 0xC8	; 200
    2612:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    2616:	88 ef       	ldi	r24, 0xF8	; 248
    2618:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    261c:	8f 70       	andi	r24, 0x0F	; 15
    261e:	38 2e       	mov	r3, r24
    2620:	a1 2c       	mov	r10, r1
    2622:	b1 2c       	mov	r11, r1
    2624:	21 2c       	mov	r2, r1
    2626:	33 20       	and	r3, r3
    2628:	09 f4       	brne	.+2      	; 0x262c <_ZN3USB11OutTransferEP6EpInfojjPh+0xd6>
    262a:	6b c0       	rjmp	.+214    	; 0x2702 <_ZN3USB11OutTransferEP6EpInfojjPh+0x1ac>
    262c:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    2630:	dc 01       	movw	r26, r24
    2632:	cb 01       	movw	r24, r22
    2634:	84 19       	sub	r24, r4
    2636:	95 09       	sbc	r25, r5
    2638:	a6 09       	sbc	r26, r6
    263a:	b7 09       	sbc	r27, r7
    263c:	b7 ff       	sbrs	r27, 7
    263e:	61 c0       	rjmp	.+194    	; 0x2702 <_ZN3USB11OutTransferEP6EpInfojjPh+0x1ac>
    2640:	f6 e0       	ldi	r31, 0x06	; 6
    2642:	3f 16       	cp	r3, r31
    2644:	01 f1       	breq	.+64     	; 0x2686 <_ZN3USB11OutTransferEP6EpInfojjPh+0x130>
    2646:	2e e0       	ldi	r18, 0x0E	; 14
    2648:	32 16       	cp	r3, r18
    264a:	09 f4       	brne	.+2      	; 0x264e <_ZN3USB11OutTransferEP6EpInfojjPh+0xf8>
    264c:	55 c0       	rjmp	.+170    	; 0x26f8 <_ZN3USB11OutTransferEP6EpInfojjPh+0x1a2>
    264e:	84 e0       	ldi	r24, 0x04	; 4
    2650:	38 12       	cpse	r3, r24
    2652:	09 c0       	rjmp	.+18     	; 0x2666 <_ZN3USB11OutTransferEP6EpInfojjPh+0x110>
    2654:	ff ef       	ldi	r31, 0xFF	; 255
    2656:	af 1a       	sub	r10, r31
    2658:	bf 0a       	sbc	r11, r31
    265a:	81 14       	cp	r8, r1
    265c:	91 04       	cpc	r9, r1
    265e:	49 f1       	breq	.+82     	; 0x26b2 <_ZN3USB11OutTransferEP6EpInfojjPh+0x15c>
    2660:	a8 14       	cp	r10, r8
    2662:	b9 04       	cpc	r11, r9
    2664:	31 f5       	brne	.+76     	; 0x26b2 <_ZN3USB11OutTransferEP6EpInfojjPh+0x15c>
    2666:	88 ef       	ldi	r24, 0xF8	; 248
    2668:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    266c:	85 fb       	bst	r24, 5
    266e:	88 27       	eor	r24, r24
    2670:	80 f9       	bld	r24, 0
    2672:	ec 81       	ldd	r30, Y+4	; 0x04
    2674:	fd 81       	ldd	r31, Y+5	; 0x05
    2676:	92 81       	ldd	r25, Z+2	; 0x02
    2678:	80 fb       	bst	r24, 0
    267a:	90 f9       	bld	r25, 0
    267c:	92 83       	std	Z+2, r25	; 0x02
    267e:	83 2d       	mov	r24, r3
    2680:	45 c0       	rjmp	.+138    	; 0x270c <_ZN3USB11OutTransferEP6EpInfojjPh+0x1b6>
    2682:	8a ed       	ldi	r24, 0xDA	; 218
    2684:	43 c0       	rjmp	.+134    	; 0x270c <_ZN3USB11OutTransferEP6EpInfojjPh+0x1b6>
    2686:	88 ef       	ldi	r24, 0xF8	; 248
    2688:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    268c:	85 fb       	bst	r24, 5
    268e:	88 27       	eor	r24, r24
    2690:	80 f9       	bld	r24, 0
    2692:	91 e0       	ldi	r25, 0x01	; 1
    2694:	89 27       	eor	r24, r25
    2696:	ec 81       	ldd	r30, Y+4	; 0x04
    2698:	fd 81       	ldd	r31, Y+5	; 0x05
    269a:	92 81       	ldd	r25, Z+2	; 0x02
    269c:	80 fb       	bst	r24, 0
    269e:	90 f9       	bld	r25, 0
    26a0:	92 83       	std	Z+2, r25	; 0x02
    26a2:	90 fd       	sbrc	r25, 0
    26a4:	02 c0       	rjmp	.+4      	; 0x26aa <_ZN3USB11OutTransferEP6EpInfojjPh+0x154>
    26a6:	60 e4       	ldi	r22, 0x40	; 64
    26a8:	01 c0       	rjmp	.+2      	; 0x26ac <_ZN3USB11OutTransferEP6EpInfojjPh+0x156>
    26aa:	60 e8       	ldi	r22, 0x80	; 128
    26ac:	88 ee       	ldi	r24, 0xE8	; 232
    26ae:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    26b2:	60 e0       	ldi	r22, 0x00	; 0
    26b4:	88 e3       	ldi	r24, 0x38	; 56
    26b6:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    26ba:	f8 01       	movw	r30, r16
    26bc:	60 81       	ld	r22, Z
    26be:	80 e1       	ldi	r24, 0x10	; 16
    26c0:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    26c4:	6b 81       	ldd	r22, Y+3	; 0x03
    26c6:	88 e3       	ldi	r24, 0x38	; 56
    26c8:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    26cc:	ec 81       	ldd	r30, Y+4	; 0x04
    26ce:	fd 81       	ldd	r31, Y+5	; 0x05
    26d0:	60 81       	ld	r22, Z
    26d2:	60 62       	ori	r22, 0x20	; 32
    26d4:	80 ef       	ldi	r24, 0xF0	; 240
    26d6:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    26da:	88 ec       	ldi	r24, 0xC8	; 200
    26dc:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    26e0:	87 ff       	sbrs	r24, 7
    26e2:	fb cf       	rjmp	.-10     	; 0x26da <_ZN3USB11OutTransferEP6EpInfojjPh+0x184>
    26e4:	60 e8       	ldi	r22, 0x80	; 128
    26e6:	88 ec       	ldi	r24, 0xC8	; 200
    26e8:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    26ec:	88 ef       	ldi	r24, 0xF8	; 248
    26ee:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    26f2:	8f 70       	andi	r24, 0x0F	; 15
    26f4:	38 2e       	mov	r3, r24
    26f6:	97 cf       	rjmp	.-210    	; 0x2626 <_ZN3USB11OutTransferEP6EpInfojjPh+0xd0>
    26f8:	23 94       	inc	r2
    26fa:	23 e0       	ldi	r18, 0x03	; 3
    26fc:	22 12       	cpse	r2, r18
    26fe:	d9 cf       	rjmp	.-78     	; 0x26b2 <_ZN3USB11OutTransferEP6EpInfojjPh+0x15c>
    2700:	b2 cf       	rjmp	.-156    	; 0x2666 <_ZN3USB11OutTransferEP6EpInfojjPh+0x110>
    2702:	ce 18       	sub	r12, r14
    2704:	df 08       	sbc	r13, r15
    2706:	0e 0d       	add	r16, r14
    2708:	1f 1d       	adc	r17, r15
    270a:	61 cf       	rjmp	.-318    	; 0x25ce <_ZN3USB11OutTransferEP6EpInfojjPh+0x78>
    270c:	0f 90       	pop	r0
    270e:	0f 90       	pop	r0
    2710:	0f 90       	pop	r0
    2712:	0f 90       	pop	r0
    2714:	0f 90       	pop	r0
    2716:	df 91       	pop	r29
    2718:	cf 91       	pop	r28
    271a:	1f 91       	pop	r17
    271c:	0f 91       	pop	r16
    271e:	ff 90       	pop	r15
    2720:	ef 90       	pop	r14
    2722:	df 90       	pop	r13
    2724:	cf 90       	pop	r12
    2726:	bf 90       	pop	r11
    2728:	af 90       	pop	r10
    272a:	9f 90       	pop	r9
    272c:	8f 90       	pop	r8
    272e:	7f 90       	pop	r7
    2730:	6f 90       	pop	r6
    2732:	5f 90       	pop	r5
    2734:	4f 90       	pop	r4
    2736:	3f 90       	pop	r3
    2738:	2f 90       	pop	r2
    273a:	08 95       	ret

0000273c <_ZN3USB11outTransferEhhjPh>:
    273c:	af 92       	push	r10
    273e:	bf 92       	push	r11
    2740:	cf 92       	push	r12
    2742:	df 92       	push	r13
    2744:	ef 92       	push	r14
    2746:	ff 92       	push	r15
    2748:	0f 93       	push	r16
    274a:	1f 93       	push	r17
    274c:	cf 93       	push	r28
    274e:	df 93       	push	r29
    2750:	00 d0       	rcall	.+0      	; 0x2752 <_ZN3USB11outTransferEhhjPh+0x16>
    2752:	00 d0       	rcall	.+0      	; 0x2754 <_ZN3USB11outTransferEhhjPh+0x18>
    2754:	cd b7       	in	r28, 0x3d	; 61
    2756:	de b7       	in	r29, 0x3e	; 62
    2758:	7c 01       	movw	r14, r24
    275a:	69 01       	movw	r12, r18
    275c:	58 01       	movw	r10, r16
    275e:	1c 82       	std	Y+4, r1	; 0x04
    2760:	1b 82       	std	Y+3, r1	; 0x03
    2762:	1a 82       	std	Y+2, r1	; 0x02
    2764:	19 82       	std	Y+1, r1	; 0x01
    2766:	8e 01       	movw	r16, r28
    2768:	0f 5f       	subi	r16, 0xFF	; 255
    276a:	1f 4f       	sbci	r17, 0xFF	; 255
    276c:	9e 01       	movw	r18, r28
    276e:	2d 5f       	subi	r18, 0xFD	; 253
    2770:	3f 4f       	sbci	r19, 0xFF	; 255
    2772:	0e 94 1a 11 	call	0x2234	; 0x2234 <_ZN3USB10SetAddressEhhPP6EpInfoPj>
    2776:	81 11       	cpse	r24, r1
    2778:	09 c0       	rjmp	.+18     	; 0x278c <_ZN3USB11outTransferEhhjPh+0x50>
    277a:	49 81       	ldd	r20, Y+1	; 0x01
    277c:	5a 81       	ldd	r21, Y+2	; 0x02
    277e:	6b 81       	ldd	r22, Y+3	; 0x03
    2780:	7c 81       	ldd	r23, Y+4	; 0x04
    2782:	85 01       	movw	r16, r10
    2784:	96 01       	movw	r18, r12
    2786:	c7 01       	movw	r24, r14
    2788:	0e 94 ab 12 	call	0x2556	; 0x2556 <_ZN3USB11OutTransferEP6EpInfojjPh>
    278c:	0f 90       	pop	r0
    278e:	0f 90       	pop	r0
    2790:	0f 90       	pop	r0
    2792:	0f 90       	pop	r0
    2794:	df 91       	pop	r29
    2796:	cf 91       	pop	r28
    2798:	1f 91       	pop	r17
    279a:	0f 91       	pop	r16
    279c:	ff 90       	pop	r15
    279e:	ef 90       	pop	r14
    27a0:	df 90       	pop	r13
    27a2:	cf 90       	pop	r12
    27a4:	bf 90       	pop	r11
    27a6:	af 90       	pop	r10
    27a8:	08 95       	ret

000027aa <_ZN3USB10InTransferEP6EpInfojPjPhh>:
    27aa:	2f 92       	push	r2
    27ac:	3f 92       	push	r3
    27ae:	4f 92       	push	r4
    27b0:	5f 92       	push	r5
    27b2:	6f 92       	push	r6
    27b4:	7f 92       	push	r7
    27b6:	8f 92       	push	r8
    27b8:	9f 92       	push	r9
    27ba:	af 92       	push	r10
    27bc:	bf 92       	push	r11
    27be:	cf 92       	push	r12
    27c0:	df 92       	push	r13
    27c2:	ef 92       	push	r14
    27c4:	ff 92       	push	r15
    27c6:	0f 93       	push	r16
    27c8:	1f 93       	push	r17
    27ca:	cf 93       	push	r28
    27cc:	df 93       	push	r29
    27ce:	cd b7       	in	r28, 0x3d	; 61
    27d0:	de b7       	in	r29, 0x3e	; 62
    27d2:	29 97       	sbiw	r28, 0x09	; 9
    27d4:	0f b6       	in	r0, 0x3f	; 63
    27d6:	f8 94       	cli
    27d8:	de bf       	out	0x3e, r29	; 62
    27da:	0f be       	out	0x3f, r0	; 63
    27dc:	cd bf       	out	0x3d, r28	; 61
    27de:	1c 01       	movw	r2, r24
    27e0:	6b 01       	movw	r12, r22
    27e2:	5b 83       	std	Y+3, r21	; 0x03
    27e4:	4a 83       	std	Y+2, r20	; 0x02
    27e6:	59 01       	movw	r10, r18
    27e8:	d9 01       	movw	r26, r18
    27ea:	6d 90       	ld	r6, X+
    27ec:	7c 90       	ld	r7, X
    27ee:	11 97       	sbiw	r26, 0x01	; 1
    27f0:	fb 01       	movw	r30, r22
    27f2:	f1 81       	ldd	r31, Z+1	; 0x01
    27f4:	f9 83       	std	Y+1, r31	; 0x01
    27f6:	1d 92       	st	X+, r1
    27f8:	1c 92       	st	X, r1
    27fa:	db 01       	movw	r26, r22
    27fc:	12 96       	adiw	r26, 0x02	; 2
    27fe:	8c 91       	ld	r24, X
    2800:	81 fd       	sbrc	r24, 1
    2802:	02 c0       	rjmp	.+4      	; 0x2808 <_ZN3USB10InTransferEP6EpInfojPjPhh+0x5e>
    2804:	60 e1       	ldi	r22, 0x10	; 16
    2806:	01 c0       	rjmp	.+2      	; 0x280a <_ZN3USB10InTransferEP6EpInfojPjPhh+0x60>
    2808:	60 e2       	ldi	r22, 0x20	; 32
    280a:	88 ee       	ldi	r24, 0xE8	; 232
    280c:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    2810:	8e 2d       	mov	r24, r14
    2812:	90 e0       	ldi	r25, 0x00	; 0
    2814:	a0 e0       	ldi	r26, 0x00	; 0
    2816:	b0 e0       	ldi	r27, 0x00	; 0
    2818:	8c 83       	std	Y+4, r24	; 0x04
    281a:	9d 83       	std	Y+5, r25	; 0x05
    281c:	ae 83       	std	Y+6, r26	; 0x06
    281e:	bf 83       	std	Y+7, r27	; 0x07
    2820:	46 2c       	mov	r4, r6
    2822:	2a 81       	ldd	r18, Y+2	; 0x02
    2824:	3b 81       	ldd	r19, Y+3	; 0x03
    2826:	d6 01       	movw	r26, r12
    2828:	4c 91       	ld	r20, X
    282a:	60 e0       	ldi	r22, 0x00	; 0
    282c:	c1 01       	movw	r24, r2
    282e:	0e 94 87 11 	call	0x230e	; 0x230e <_ZN3USB11dispatchPktEhhj>
    2832:	f8 2e       	mov	r15, r24
    2834:	b6 e0       	ldi	r27, 0x06	; 6
    2836:	8b 13       	cpse	r24, r27
    2838:	15 c0       	rjmp	.+42     	; 0x2864 <_ZN3USB10InTransferEP6EpInfojPjPhh+0xba>
    283a:	88 ef       	ldi	r24, 0xF8	; 248
    283c:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    2840:	82 95       	swap	r24
    2842:	81 70       	andi	r24, 0x01	; 1
    2844:	91 e0       	ldi	r25, 0x01	; 1
    2846:	89 27       	eor	r24, r25
    2848:	f6 01       	movw	r30, r12
    284a:	92 81       	ldd	r25, Z+2	; 0x02
    284c:	80 fb       	bst	r24, 0
    284e:	91 f9       	bld	r25, 1
    2850:	92 83       	std	Z+2, r25	; 0x02
    2852:	91 fd       	sbrc	r25, 1
    2854:	02 c0       	rjmp	.+4      	; 0x285a <_ZN3USB10InTransferEP6EpInfojPjPhh+0xb0>
    2856:	60 e1       	ldi	r22, 0x10	; 16
    2858:	01 c0       	rjmp	.+2      	; 0x285c <_ZN3USB10InTransferEP6EpInfojPjPhh+0xb2>
    285a:	60 e2       	ldi	r22, 0x20	; 32
    285c:	88 ee       	ldi	r24, 0xE8	; 232
    285e:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    2862:	df cf       	rjmp	.-66     	; 0x2822 <_ZN3USB10InTransferEP6EpInfojPjPhh+0x78>
    2864:	81 11       	cpse	r24, r1
    2866:	6e c0       	rjmp	.+220    	; 0x2944 <_ZN3USB10InTransferEP6EpInfojPjPhh+0x19a>
    2868:	88 ec       	ldi	r24, 0xC8	; 200
    286a:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    286e:	82 ff       	sbrs	r24, 2
    2870:	67 c0       	rjmp	.+206    	; 0x2940 <_ZN3USB10InTransferEP6EpInfojPjPhh+0x196>
    2872:	80 e3       	ldi	r24, 0x30	; 48
    2874:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    2878:	58 2e       	mov	r5, r24
    287a:	90 e0       	ldi	r25, 0x00	; 0
    287c:	68 16       	cp	r6, r24
    287e:	79 06       	cpc	r7, r25
    2880:	08 f4       	brcc	.+2      	; 0x2884 <_ZN3USB10InTransferEP6EpInfojPjPhh+0xda>
    2882:	54 2c       	mov	r5, r4
    2884:	d5 01       	movw	r26, r10
    2886:	8d 91       	ld	r24, X+
    2888:	9c 91       	ld	r25, X
    288a:	f3 01       	movw	r30, r6
    288c:	e8 1b       	sub	r30, r24
    288e:	f9 0b       	sbc	r31, r25
    2890:	f9 87       	std	Y+9, r31	; 0x09
    2892:	e8 87       	std	Y+8, r30	; 0x08
    2894:	f7 ff       	sbrs	r31, 7
    2896:	02 c0       	rjmp	.+4      	; 0x289c <_ZN3USB10InTransferEP6EpInfojPjPhh+0xf2>
    2898:	19 86       	std	Y+9, r1	; 0x09
    289a:	18 86       	std	Y+8, r1	; 0x08
    289c:	85 2c       	mov	r8, r5
    289e:	91 2c       	mov	r9, r1
    28a0:	28 85       	ldd	r18, Y+8	; 0x08
    28a2:	39 85       	ldd	r19, Y+9	; 0x09
    28a4:	82 16       	cp	r8, r18
    28a6:	93 06       	cpc	r9, r19
    28a8:	14 f4       	brge	.+4      	; 0x28ae <_ZN3USB10InTransferEP6EpInfojPjPhh+0x104>
    28aa:	99 86       	std	Y+9, r9	; 0x09
    28ac:	88 86       	std	Y+8, r8	; 0x08
    28ae:	80 e5       	ldi	r24, 0x50	; 80
    28b0:	91 e0       	ldi	r25, 0x01	; 1
    28b2:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN8SPIClass16beginTransactionE11SPISettings>
    28b6:	0e 94 df 10 	call	0x21be	; 0x21be <_ZN4TPinI5PortbLh2EE5ClearEv>
    28ba:	88 e0       	ldi	r24, 0x08	; 8
    28bc:	0e 94 60 07 	call	0xec0	; 0xec0 <_ZN8SPIClass8transferEh>
    28c0:	48 85       	ldd	r20, Y+8	; 0x08
    28c2:	59 85       	ldd	r21, Y+9	; 0x09
    28c4:	60 e0       	ldi	r22, 0x00	; 0
    28c6:	70 e0       	ldi	r23, 0x00	; 0
    28c8:	c8 01       	movw	r24, r16
    28ca:	0e 94 76 1a 	call	0x34ec	; 0x34ec <memset>
    28ce:	88 85       	ldd	r24, Y+8	; 0x08
    28d0:	99 85       	ldd	r25, Y+9	; 0x09
    28d2:	00 97       	sbiw	r24, 0x00	; 0
    28d4:	21 f0       	breq	.+8      	; 0x28de <_ZN3USB10InTransferEP6EpInfojPjPhh+0x134>
    28d6:	bc 01       	movw	r22, r24
    28d8:	c8 01       	movw	r24, r16
    28da:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <_ZN8SPIClass8transferEPvj.part.0>
    28de:	a8 85       	ldd	r26, Y+8	; 0x08
    28e0:	b9 85       	ldd	r27, Y+9	; 0x09
    28e2:	0a 0f       	add	r16, r26
    28e4:	1b 1f       	adc	r17, r27
    28e6:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <_ZN4TPinI5PortbLh2EE3SetEv>
    28ea:	0e 94 67 07 	call	0xece	; 0xece <_ZN8SPIClass14endTransactionEv>
    28ee:	64 e0       	ldi	r22, 0x04	; 4
    28f0:	88 ec       	ldi	r24, 0xC8	; 200
    28f2:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
    28f6:	f5 01       	movw	r30, r10
    28f8:	80 81       	ld	r24, Z
    28fa:	91 81       	ldd	r25, Z+1	; 0x01
    28fc:	88 0e       	add	r8, r24
    28fe:	99 1e       	adc	r9, r25
    2900:	91 82       	std	Z+1, r9	; 0x01
    2902:	80 82       	st	Z, r8
    2904:	f9 81       	ldd	r31, Y+1	; 0x01
    2906:	5f 16       	cp	r5, r31
    2908:	18 f0       	brcs	.+6      	; 0x2910 <_ZN3USB10InTransferEP6EpInfojPjPhh+0x166>
    290a:	86 14       	cp	r8, r6
    290c:	97 04       	cpc	r9, r7
    290e:	70 f0       	brcs	.+28     	; 0x292c <_ZN3USB10InTransferEP6EpInfojPjPhh+0x182>
    2910:	88 ef       	ldi	r24, 0xF8	; 248
    2912:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    2916:	82 95       	swap	r24
    2918:	81 70       	andi	r24, 0x01	; 1
    291a:	d6 01       	movw	r26, r12
    291c:	12 96       	adiw	r26, 0x02	; 2
    291e:	9c 91       	ld	r25, X
    2920:	12 97       	sbiw	r26, 0x02	; 2
    2922:	80 fb       	bst	r24, 0
    2924:	91 f9       	bld	r25, 1
    2926:	12 96       	adiw	r26, 0x02	; 2
    2928:	9c 93       	st	X, r25
    292a:	0c c0       	rjmp	.+24     	; 0x2944 <_ZN3USB10InTransferEP6EpInfojPjPhh+0x19a>
    292c:	ee 20       	and	r14, r14
    292e:	09 f4       	brne	.+2      	; 0x2932 <_ZN3USB10InTransferEP6EpInfojPjPhh+0x188>
    2930:	78 cf       	rjmp	.-272    	; 0x2822 <_ZN3USB10InTransferEP6EpInfojPjPhh+0x78>
    2932:	6c 81       	ldd	r22, Y+4	; 0x04
    2934:	7d 81       	ldd	r23, Y+5	; 0x05
    2936:	8e 81       	ldd	r24, Y+6	; 0x06
    2938:	9f 81       	ldd	r25, Y+7	; 0x07
    293a:	0e 94 de 06 	call	0xdbc	; 0xdbc <delay>
    293e:	71 cf       	rjmp	.-286    	; 0x2822 <_ZN3USB10InTransferEP6EpInfojPjPhh+0x78>
    2940:	80 ef       	ldi	r24, 0xF0	; 240
    2942:	f8 2e       	mov	r15, r24
    2944:	8f 2d       	mov	r24, r15
    2946:	29 96       	adiw	r28, 0x09	; 9
    2948:	0f b6       	in	r0, 0x3f	; 63
    294a:	f8 94       	cli
    294c:	de bf       	out	0x3e, r29	; 62
    294e:	0f be       	out	0x3f, r0	; 63
    2950:	cd bf       	out	0x3d, r28	; 61
    2952:	df 91       	pop	r29
    2954:	cf 91       	pop	r28
    2956:	1f 91       	pop	r17
    2958:	0f 91       	pop	r16
    295a:	ff 90       	pop	r15
    295c:	ef 90       	pop	r14
    295e:	df 90       	pop	r13
    2960:	cf 90       	pop	r12
    2962:	bf 90       	pop	r11
    2964:	af 90       	pop	r10
    2966:	9f 90       	pop	r9
    2968:	8f 90       	pop	r8
    296a:	7f 90       	pop	r7
    296c:	6f 90       	pop	r6
    296e:	5f 90       	pop	r5
    2970:	4f 90       	pop	r4
    2972:	3f 90       	pop	r3
    2974:	2f 90       	pop	r2
    2976:	08 95       	ret

00002978 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser>:
    2978:	2f 92       	push	r2
    297a:	3f 92       	push	r3
    297c:	4f 92       	push	r4
    297e:	5f 92       	push	r5
    2980:	6f 92       	push	r6
    2982:	7f 92       	push	r7
    2984:	8f 92       	push	r8
    2986:	9f 92       	push	r9
    2988:	af 92       	push	r10
    298a:	bf 92       	push	r11
    298c:	cf 92       	push	r12
    298e:	df 92       	push	r13
    2990:	ef 92       	push	r14
    2992:	ff 92       	push	r15
    2994:	0f 93       	push	r16
    2996:	1f 93       	push	r17
    2998:	cf 93       	push	r28
    299a:	df 93       	push	r29
    299c:	cd b7       	in	r28, 0x3d	; 61
    299e:	de b7       	in	r29, 0x3e	; 62
    29a0:	61 97       	sbiw	r28, 0x11	; 17
    29a2:	0f b6       	in	r0, 0x3f	; 63
    29a4:	f8 94       	cli
    29a6:	de bf       	out	0x3e, r29	; 62
    29a8:	0f be       	out	0x3f, r0	; 63
    29aa:	cd bf       	out	0x3d, r28	; 61
    29ac:	3c 01       	movw	r6, r24
    29ae:	f4 2e       	mov	r15, r20
    29b0:	32 2e       	mov	r3, r18
    29b2:	20 2e       	mov	r2, r16
    29b4:	c9 8a       	std	Y+17, r12	; 0x11
    29b6:	4e a0       	ldd	r4, Y+38	; 0x26
    29b8:	5f a0       	ldd	r5, Y+39	; 0x27
    29ba:	c8 a4       	ldd	r12, Y+40	; 0x28
    29bc:	d9 a4       	ldd	r13, Y+41	; 0x29
    29be:	18 8a       	std	Y+16, r1	; 0x10
    29c0:	1f 86       	std	Y+15, r1	; 0x0f
    29c2:	1e 86       	std	Y+14, r1	; 0x0e
    29c4:	1d 86       	std	Y+13, r1	; 0x0d
    29c6:	8e 01       	movw	r16, r28
    29c8:	03 5f       	subi	r16, 0xF3	; 243
    29ca:	1f 4f       	sbci	r17, 0xFF	; 255
    29cc:	9e 01       	movw	r18, r28
    29ce:	21 5f       	subi	r18, 0xF1	; 241
    29d0:	3f 4f       	sbci	r19, 0xFF	; 255
    29d2:	0e 94 1a 11 	call	0x2234	; 0x2234 <_ZN3USB10SetAddressEhhPP6EpInfoPj>
    29d6:	81 11       	cpse	r24, r1
    29d8:	96 c0       	rjmp	.+300    	; 0x2b06 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x18e>
    29da:	39 82       	std	Y+1, r3	; 0x01
    29dc:	2a 82       	std	Y+2, r2	; 0x02
    29de:	eb 82       	std	Y+3, r14	; 0x03
    29e0:	89 89       	ldd	r24, Y+17	; 0x11
    29e2:	8c 83       	std	Y+4, r24	; 0x04
    29e4:	be 82       	std	Y+6, r11	; 0x06
    29e6:	ad 82       	std	Y+5, r10	; 0x05
    29e8:	98 86       	std	Y+8, r9	; 0x08
    29ea:	8f 82       	std	Y+7, r8	; 0x07
    29ec:	ae 01       	movw	r20, r28
    29ee:	4f 5f       	subi	r20, 0xFF	; 255
    29f0:	5f 4f       	sbci	r21, 0xFF	; 255
    29f2:	68 e0       	ldi	r22, 0x08	; 8
    29f4:	80 e2       	ldi	r24, 0x20	; 32
    29f6:	0e 94 86 12 	call	0x250c	; 0x250c <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE7bytesWrEhhPh.isra.7>
    29fa:	2d 85       	ldd	r18, Y+13	; 0x0d
    29fc:	3e 85       	ldd	r19, Y+14	; 0x0e
    29fe:	4f 2d       	mov	r20, r15
    2a00:	60 e1       	ldi	r22, 0x10	; 16
    2a02:	c3 01       	movw	r24, r6
    2a04:	0e 94 87 11 	call	0x230e	; 0x230e <_ZN3USB11dispatchPktEhhj>
    2a08:	e8 2e       	mov	r14, r24
    2a0a:	81 11       	cpse	r24, r1
    2a0c:	78 c0       	rjmp	.+240    	; 0x2afe <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x186>
    2a0e:	93 2d       	mov	r25, r3
    2a10:	90 78       	andi	r25, 0x80	; 128
    2a12:	39 2e       	mov	r3, r25
    2a14:	c1 14       	cp	r12, r1
    2a16:	d1 04       	cpc	r13, r1
    2a18:	09 f4       	brne	.+2      	; 0x2a1c <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0xa4>
    2a1a:	62 c0       	rjmp	.+196    	; 0x2ae0 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x168>
    2a1c:	ef 85       	ldd	r30, Y+15	; 0x0f
    2a1e:	f8 89       	ldd	r31, Y+16	; 0x10
    2a20:	82 81       	ldd	r24, Z+2	; 0x02
    2a22:	99 23       	and	r25, r25
    2a24:	09 f4       	brne	.+2      	; 0x2a28 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0xb0>
    2a26:	4d c0       	rjmp	.+154    	; 0x2ac2 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x14a>
    2a28:	82 60       	ori	r24, 0x02	; 2
    2a2a:	82 83       	std	Z+2, r24	; 0x02
    2a2c:	54 01       	movw	r10, r8
    2a2e:	22 24       	eor	r2, r2
    2a30:	23 94       	inc	r2
    2a32:	a1 14       	cp	r10, r1
    2a34:	b1 04       	cpc	r11, r1
    2a36:	09 f4       	brne	.+2      	; 0x2a3a <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0xc2>
    2a38:	58 c0       	rjmp	.+176    	; 0x2aea <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x172>
    2a3a:	5c 86       	std	Y+12, r5	; 0x0c
    2a3c:	4b 86       	std	Y+11, r4	; 0x0b
    2a3e:	4d 85       	ldd	r20, Y+13	; 0x0d
    2a40:	5e 85       	ldd	r21, Y+14	; 0x0e
    2a42:	6f 85       	ldd	r22, Y+15	; 0x0f
    2a44:	78 89       	ldd	r23, Y+16	; 0x10
    2a46:	e1 2c       	mov	r14, r1
    2a48:	86 01       	movw	r16, r12
    2a4a:	9e 01       	movw	r18, r28
    2a4c:	25 5f       	subi	r18, 0xF5	; 245
    2a4e:	3f 4f       	sbci	r19, 0xFF	; 255
    2a50:	c3 01       	movw	r24, r6
    2a52:	0e 94 d5 13 	call	0x27aa	; 0x27aa <_ZN3USB10InTransferEP6EpInfojPjPhh>
    2a56:	e8 2e       	mov	r14, r24
    2a58:	a6 e0       	ldi	r26, 0x06	; 6
    2a5a:	8a 13       	cpse	r24, r26
    2a5c:	0f c0       	rjmp	.+30     	; 0x2a7c <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x104>
    2a5e:	0f 85       	ldd	r16, Y+15	; 0x0f
    2a60:	18 89       	ldd	r17, Y+16	; 0x10
    2a62:	88 ef       	ldi	r24, 0xF8	; 248
    2a64:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    2a68:	85 fb       	bst	r24, 5
    2a6a:	88 27       	eor	r24, r24
    2a6c:	80 f9       	bld	r24, 0
    2a6e:	82 25       	eor	r24, r2
    2a70:	f8 01       	movw	r30, r16
    2a72:	92 81       	ldd	r25, Z+2	; 0x02
    2a74:	80 fb       	bst	r24, 0
    2a76:	91 f9       	bld	r25, 1
    2a78:	92 83       	std	Z+2, r25	; 0x02
    2a7a:	db cf       	rjmp	.-74     	; 0x2a32 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0xba>
    2a7c:	81 11       	cpse	r24, r1
    2a7e:	3f c0       	rjmp	.+126    	; 0x2afe <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x186>
    2a80:	8a a5       	ldd	r24, Y+42	; 0x2a
    2a82:	9b a5       	ldd	r25, Y+43	; 0x2b
    2a84:	00 97       	sbiw	r24, 0x00	; 0
    2a86:	a1 f0       	breq	.+40     	; 0x2ab0 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x138>
    2a88:	dc 01       	movw	r26, r24
    2a8a:	ed 91       	ld	r30, X+
    2a8c:	fc 91       	ld	r31, X
    2a8e:	11 97       	sbiw	r26, 0x01	; 1
    2a90:	01 90       	ld	r0, Z+
    2a92:	f0 81       	ld	r31, Z
    2a94:	e0 2d       	mov	r30, r0
    2a96:	c4 01       	movw	r24, r8
    2a98:	8a 19       	sub	r24, r10
    2a9a:	9b 09       	sbc	r25, r11
    2a9c:	9a 87       	std	Y+10, r25	; 0x0a
    2a9e:	89 87       	std	Y+9, r24	; 0x09
    2aa0:	6b 85       	ldd	r22, Y+11	; 0x0b
    2aa2:	7c 85       	ldd	r23, Y+12	; 0x0c
    2aa4:	9e 01       	movw	r18, r28
    2aa6:	27 5f       	subi	r18, 0xF7	; 247
    2aa8:	3f 4f       	sbci	r19, 0xFF	; 255
    2aaa:	a6 01       	movw	r20, r12
    2aac:	cd 01       	movw	r24, r26
    2aae:	09 95       	icall
    2ab0:	8b 85       	ldd	r24, Y+11	; 0x0b
    2ab2:	9c 85       	ldd	r25, Y+12	; 0x0c
    2ab4:	a8 1a       	sub	r10, r24
    2ab6:	b9 0a       	sbc	r11, r25
    2ab8:	84 15       	cp	r24, r4
    2aba:	95 05       	cpc	r25, r5
    2abc:	08 f0       	brcs	.+2      	; 0x2ac0 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x148>
    2abe:	b9 cf       	rjmp	.-142    	; 0x2a32 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0xba>
    2ac0:	0f c0       	rjmp	.+30     	; 0x2ae0 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x168>
    2ac2:	81 60       	ori	r24, 0x01	; 1
    2ac4:	82 83       	std	Z+2, r24	; 0x02
    2ac6:	4d 85       	ldd	r20, Y+13	; 0x0d
    2ac8:	5e 85       	ldd	r21, Y+14	; 0x0e
    2aca:	86 01       	movw	r16, r12
    2acc:	92 01       	movw	r18, r4
    2ace:	bf 01       	movw	r22, r30
    2ad0:	c3 01       	movw	r24, r6
    2ad2:	0e 94 ab 12 	call	0x2556	; 0x2556 <_ZN3USB11OutTransferEP6EpInfojjPh>
    2ad6:	81 11       	cpse	r24, r1
    2ad8:	16 c0       	rjmp	.+44     	; 0x2b06 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x18e>
    2ada:	2d 85       	ldd	r18, Y+13	; 0x0d
    2adc:	3e 85       	ldd	r19, Y+14	; 0x0e
    2ade:	11 c0       	rjmp	.+34     	; 0x2b02 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x18a>
    2ae0:	2d 85       	ldd	r18, Y+13	; 0x0d
    2ae2:	3e 85       	ldd	r19, Y+14	; 0x0e
    2ae4:	31 10       	cpse	r3, r1
    2ae6:	05 c0       	rjmp	.+10     	; 0x2af2 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x17a>
    2ae8:	0c c0       	rjmp	.+24     	; 0x2b02 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x18a>
    2aea:	e1 10       	cpse	r14, r1
    2aec:	08 c0       	rjmp	.+16     	; 0x2afe <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x186>
    2aee:	2d 85       	ldd	r18, Y+13	; 0x0d
    2af0:	3e 85       	ldd	r19, Y+14	; 0x0e
    2af2:	60 ea       	ldi	r22, 0xA0	; 160
    2af4:	4f 2d       	mov	r20, r15
    2af6:	c3 01       	movw	r24, r6
    2af8:	0e 94 87 11 	call	0x230e	; 0x230e <_ZN3USB11dispatchPktEhhj>
    2afc:	04 c0       	rjmp	.+8      	; 0x2b06 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x18e>
    2afe:	8e 2d       	mov	r24, r14
    2b00:	02 c0       	rjmp	.+4      	; 0x2b06 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x18e>
    2b02:	60 e8       	ldi	r22, 0x80	; 128
    2b04:	f7 cf       	rjmp	.-18     	; 0x2af4 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser+0x17c>
    2b06:	61 96       	adiw	r28, 0x11	; 17
    2b08:	0f b6       	in	r0, 0x3f	; 63
    2b0a:	f8 94       	cli
    2b0c:	de bf       	out	0x3e, r29	; 62
    2b0e:	0f be       	out	0x3f, r0	; 63
    2b10:	cd bf       	out	0x3d, r28	; 61
    2b12:	df 91       	pop	r29
    2b14:	cf 91       	pop	r28
    2b16:	1f 91       	pop	r17
    2b18:	0f 91       	pop	r16
    2b1a:	ff 90       	pop	r15
    2b1c:	ef 90       	pop	r14
    2b1e:	df 90       	pop	r13
    2b20:	cf 90       	pop	r12
    2b22:	bf 90       	pop	r11
    2b24:	af 90       	pop	r10
    2b26:	9f 90       	pop	r9
    2b28:	8f 90       	pop	r8
    2b2a:	7f 90       	pop	r7
    2b2c:	6f 90       	pop	r6
    2b2e:	5f 90       	pop	r5
    2b30:	4f 90       	pop	r4
    2b32:	3f 90       	pop	r3
    2b34:	2f 90       	pop	r2
    2b36:	08 95       	ret

00002b38 <_ZN3USB11getDevDescrEhhjPh>:
    2b38:	8f 92       	push	r8
    2b3a:	9f 92       	push	r9
    2b3c:	af 92       	push	r10
    2b3e:	bf 92       	push	r11
    2b40:	cf 92       	push	r12
    2b42:	ef 92       	push	r14
    2b44:	0f 93       	push	r16
    2b46:	1f 93       	push	r17
    2b48:	1f 92       	push	r1
    2b4a:	1f 92       	push	r1
    2b4c:	1f 93       	push	r17
    2b4e:	0f 93       	push	r16
    2b50:	3f 93       	push	r19
    2b52:	2f 93       	push	r18
    2b54:	49 01       	movw	r8, r18
    2b56:	a1 2c       	mov	r10, r1
    2b58:	b1 2c       	mov	r11, r1
    2b5a:	cc 24       	eor	r12, r12
    2b5c:	c3 94       	inc	r12
    2b5e:	e1 2c       	mov	r14, r1
    2b60:	06 e0       	ldi	r16, 0x06	; 6
    2b62:	20 e8       	ldi	r18, 0x80	; 128
    2b64:	0e 94 bc 14 	call	0x2978	; 0x2978 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser>
    2b68:	0f 90       	pop	r0
    2b6a:	0f 90       	pop	r0
    2b6c:	0f 90       	pop	r0
    2b6e:	0f 90       	pop	r0
    2b70:	0f 90       	pop	r0
    2b72:	0f 90       	pop	r0
    2b74:	1f 91       	pop	r17
    2b76:	0f 91       	pop	r16
    2b78:	ef 90       	pop	r14
    2b7a:	cf 90       	pop	r12
    2b7c:	bf 90       	pop	r11
    2b7e:	af 90       	pop	r10
    2b80:	9f 90       	pop	r9
    2b82:	8f 90       	pop	r8
    2b84:	08 95       	ret

00002b86 <_ZN3USB7setAddrEhhh>:
//set address

uint8_t USB::setAddr(uint8_t oldaddr, uint8_t ep, uint8_t newaddr) {
    2b86:	8f 92       	push	r8
    2b88:	9f 92       	push	r9
    2b8a:	af 92       	push	r10
    2b8c:	bf 92       	push	r11
    2b8e:	cf 92       	push	r12
    2b90:	ef 92       	push	r14
    2b92:	0f 93       	push	r16
    2b94:	cf 93       	push	r28
        uint8_t rcode = ctrlReq(oldaddr, ep, bmREQ_SET, USB_REQUEST_SET_ADDRESS, newaddr, 0x00, 0x0000, 0x0000, 0x0000, NULL, NULL);
    2b96:	1f 92       	push	r1
    2b98:	1f 92       	push	r1
    2b9a:	1f 92       	push	r1
    2b9c:	1f 92       	push	r1
    2b9e:	1f 92       	push	r1
    2ba0:	1f 92       	push	r1
    2ba2:	81 2c       	mov	r8, r1
    2ba4:	91 2c       	mov	r9, r1
    2ba6:	a1 2c       	mov	r10, r1
    2ba8:	b1 2c       	mov	r11, r1
    2baa:	c1 2c       	mov	r12, r1
    2bac:	e2 2e       	mov	r14, r18
    2bae:	05 e0       	ldi	r16, 0x05	; 5
    2bb0:	20 e0       	ldi	r18, 0x00	; 0
    2bb2:	0e 94 bc 14 	call	0x2978	; 0x2978 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser>
    2bb6:	c8 2f       	mov	r28, r24
        //delay(2); //per USB 2.0 sect.9.2.6.3
        delay(300); // Older spec says you should wait at least 200ms
    2bb8:	6c e2       	ldi	r22, 0x2C	; 44
    2bba:	71 e0       	ldi	r23, 0x01	; 1
    2bbc:	80 e0       	ldi	r24, 0x00	; 0
    2bbe:	90 e0       	ldi	r25, 0x00	; 0
    2bc0:	0e 94 de 06 	call	0xdbc	; 0xdbc <delay>
        return rcode;
    2bc4:	0f 90       	pop	r0
    2bc6:	0f 90       	pop	r0
    2bc8:	0f 90       	pop	r0
    2bca:	0f 90       	pop	r0
    2bcc:	0f 90       	pop	r0
    2bce:	0f 90       	pop	r0
        //return ( ctrlReq(oldaddr, ep, bmREQ_SET, USB_REQUEST_SET_ADDRESS, newaddr, 0x00, 0x0000, 0x0000, 0x0000, NULL, NULL));
}
    2bd0:	8c 2f       	mov	r24, r28
    2bd2:	cf 91       	pop	r28
    2bd4:	0f 91       	pop	r16
    2bd6:	ef 90       	pop	r14
    2bd8:	cf 90       	pop	r12
    2bda:	bf 90       	pop	r11
    2bdc:	af 90       	pop	r10
    2bde:	9f 90       	pop	r9
    2be0:	8f 90       	pop	r8
    2be2:	08 95       	ret

00002be4 <_ZN3USB17DefaultAddressingEhhb>:
                        //MAX3421E::Init();
                        break;
        } // switch( usb_task_state )
}

uint8_t USB::DefaultAddressing(uint8_t parent, uint8_t port, bool lowspeed) {
    2be4:	0f 93       	push	r16
    2be6:	1f 93       	push	r17
    2be8:	cf 93       	push	r28
    2bea:	df 93       	push	r29
        UsbDevice *p0 = NULL, *p = NULL;

        // Get pointer to pseudo device with address 0 assigned
        p0 = addrPool.GetUsbDevicePtr(0);

        if(!p0)
    2bec:	8a 3f       	cpi	r24, 0xFA	; 250
    2bee:	3f ef       	ldi	r19, 0xFF	; 255
    2bf0:	93 07       	cpc	r25, r19
    2bf2:	11 f4       	brne	.+4      	; 0x2bf8 <_ZN3USB17DefaultAddressingEhhb+0x14>
                return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
    2bf4:	86 ed       	ldi	r24, 0xD6	; 214
    2bf6:	2d c0       	rjmp	.+90     	; 0x2c52 <_ZN3USB17DefaultAddressingEhhb+0x6e>

        if(!p0->epinfo)
    2bf8:	dc 01       	movw	r26, r24
    2bfa:	16 96       	adiw	r26, 0x06	; 6
    2bfc:	ed 91       	ld	r30, X+
    2bfe:	fc 91       	ld	r31, X
    2c00:	17 97       	sbiw	r26, 0x07	; 7
    2c02:	ef 2b       	or	r30, r31
    2c04:	09 f1       	breq	.+66     	; 0x2c48 <_ZN3USB17DefaultAddressingEhhb+0x64>
    2c06:	12 2f       	mov	r17, r18
    2c08:	24 2f       	mov	r18, r20
    2c0a:	ec 01       	movw	r28, r24
                return USB_ERROR_EPINFO_IS_NULL;

        p0->lowspeed = (lowspeed) ? true : false;
    2c0c:	1a 87       	std	Y+10, r17	; 0x0a

        // Allocate new address according to device class
        uint8_t bAddress = addrPool.AllocAddress(parent, false, port);
    2c0e:	40 e0       	ldi	r20, 0x00	; 0
    2c10:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh>
    2c14:	08 2f       	mov	r16, r24

        if(!bAddress)
    2c16:	88 23       	and	r24, r24
    2c18:	c9 f0       	breq	.+50     	; 0x2c4c <_ZN3USB17DefaultAddressingEhhb+0x68>
                return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;

        p = addrPool.GetUsbDevicePtr(bAddress);
    2c1a:	68 2f       	mov	r22, r24
    2c1c:	ce 01       	movw	r24, r28
    2c1e:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>

        if(!p)
    2c22:	00 97       	sbiw	r24, 0x00	; 0
    2c24:	39 f3       	breq	.-50     	; 0x2bf4 <_ZN3USB17DefaultAddressingEhhb+0x10>
                return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;

        p->lowspeed = lowspeed;
    2c26:	fc 01       	movw	r30, r24
    2c28:	14 83       	std	Z+4, r17	; 0x04

        // Assign new address to the device
        rcode = setAddr(0, 0, bAddress);
    2c2a:	20 2f       	mov	r18, r16
    2c2c:	40 e0       	ldi	r20, 0x00	; 0
    2c2e:	60 e0       	ldi	r22, 0x00	; 0
    2c30:	ce 01       	movw	r24, r28
    2c32:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <_ZN3USB7setAddrEhhh>
    2c36:	18 2f       	mov	r17, r24

        if(rcode) {
    2c38:	88 23       	and	r24, r24
    2c3a:	51 f0       	breq	.+20     	; 0x2c50 <_ZN3USB17DefaultAddressingEhhb+0x6c>
                addrPool.FreeAddress(bAddress);
    2c3c:	60 2f       	mov	r22, r16
    2c3e:	ce 01       	movw	r24, r28
    2c40:	0e 94 53 10 	call	0x20a6	; 0x20a6 <_ZN15AddressPoolImplILh16EE11FreeAddressEh>
    2c44:	81 2f       	mov	r24, r17
    2c46:	05 c0       	rjmp	.+10     	; 0x2c52 <_ZN3USB17DefaultAddressingEhhb+0x6e>

        if(!p0)
                return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;

        if(!p0->epinfo)
                return USB_ERROR_EPINFO_IS_NULL;
    2c48:	87 ed       	ldi	r24, 0xD7	; 215
    2c4a:	03 c0       	rjmp	.+6      	; 0x2c52 <_ZN3USB17DefaultAddressingEhhb+0x6e>

        // Allocate new address according to device class
        uint8_t bAddress = addrPool.AllocAddress(parent, false, port);

        if(!bAddress)
                return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;
    2c4c:	84 ed       	ldi	r24, 0xD4	; 212
    2c4e:	01 c0       	rjmp	.+2      	; 0x2c52 <_ZN3USB17DefaultAddressingEhhb+0x6e>
        if(rcode) {
                addrPool.FreeAddress(bAddress);
                bAddress = 0;
                return rcode;
        }
        return 0;
    2c50:	80 e0       	ldi	r24, 0x00	; 0
};
    2c52:	df 91       	pop	r29
    2c54:	cf 91       	pop	r28
    2c56:	1f 91       	pop	r17
    2c58:	0f 91       	pop	r16
    2c5a:	08 95       	ret

00002c5c <_ZN3USB11ConfiguringEhhb>:
 * 7: for(each driver) {
 *      7a: Ask device if it knows this VID/PID. Acts exactly like 6a, but using VID/PID
 * 8: if we get here, no driver likes the device plugged in, so exit failure.
 *
 */
uint8_t USB::Configuring(uint8_t parent, uint8_t port, bool lowspeed) {
    2c5c:	2f 92       	push	r2
    2c5e:	3f 92       	push	r3
    2c60:	4f 92       	push	r4
    2c62:	5f 92       	push	r5
    2c64:	6f 92       	push	r6
    2c66:	7f 92       	push	r7
    2c68:	8f 92       	push	r8
    2c6a:	9f 92       	push	r9
    2c6c:	af 92       	push	r10
    2c6e:	bf 92       	push	r11
    2c70:	cf 92       	push	r12
    2c72:	df 92       	push	r13
    2c74:	ef 92       	push	r14
    2c76:	ff 92       	push	r15
    2c78:	0f 93       	push	r16
    2c7a:	1f 93       	push	r17
    2c7c:	cf 93       	push	r28
    2c7e:	df 93       	push	r29
    2c80:	cd b7       	in	r28, 0x3d	; 61
    2c82:	de b7       	in	r29, 0x3e	; 62
    2c84:	66 97       	sbiw	r28, 0x16	; 22
    2c86:	0f b6       	in	r0, 0x3f	; 63
    2c88:	f8 94       	cli
    2c8a:	de bf       	out	0x3e, r29	; 62
    2c8c:	0f be       	out	0x3f, r0	; 63
    2c8e:	cd bf       	out	0x3d, r28	; 61
        USB_DEVICE_DESCRIPTOR *udd = reinterpret_cast<USB_DEVICE_DESCRIPTOR *>(buf);
        UsbDevice *p = NULL;
        EpInfo *oldep_ptr = NULL;
        EpInfo epInfo;

        epInfo.epAddr = 0;
    2c90:	1b 8a       	std	Y+19, r1	; 0x13
        epInfo.maxPktSize = 8;
    2c92:	38 e0       	ldi	r19, 0x08	; 8
    2c94:	3c 8b       	std	Y+20, r19	; 0x14
        epInfo.bmSndToggle = 0;
        epInfo.bmRcvToggle = 0;
        epInfo.bmNakPower = USB_NAK_MAX_POWER;
    2c96:	3c e3       	ldi	r19, 0x3C	; 60
    2c98:	3d 8b       	std	Y+21, r19	; 0x15

        //delay(2000);
        AddressPool &addrPool = GetAddressPool();
        // Get pointer to pseudo device with address 0 assigned
        p = addrPool.GetUsbDevicePtr(0);
        if(!p) {
    2c9a:	8a 3f       	cpi	r24, 0xFA	; 250
    2c9c:	3f ef       	ldi	r19, 0xFF	; 255
    2c9e:	93 07       	cpc	r25, r19
    2ca0:	09 f4       	brne	.+2      	; 0x2ca4 <_ZN3USB11ConfiguringEhhb+0x48>
    2ca2:	64 c0       	rjmp	.+200    	; 0x2d6c <_ZN3USB11ConfiguringEhhb+0x110>
    2ca4:	52 2e       	mov	r5, r18
    2ca6:	34 2e       	mov	r3, r20
    2ca8:	46 2e       	mov	r4, r22
    2caa:	7c 01       	movw	r14, r24
                //printf("Configuring error: USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL\r\n");
                return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
        }

        // Save old pointer to EP_RECORD of address 0
        oldep_ptr = p->epinfo;
    2cac:	dc 01       	movw	r26, r24
    2cae:	16 96       	adiw	r26, 0x06	; 6
    2cb0:	cd 90       	ld	r12, X+
    2cb2:	dc 90       	ld	r13, X
    2cb4:	17 97       	sbiw	r26, 0x07	; 7

        // Temporary assign new pointer to epInfo to p->epinfo in order to
        // avoid toggle inconsistence

        p->epinfo = &epInfo;
    2cb6:	ce 01       	movw	r24, r28
    2cb8:	43 96       	adiw	r24, 0x13	; 19
    2cba:	17 96       	adiw	r26, 0x07	; 7
    2cbc:	9c 93       	st	X, r25
    2cbe:	8e 93       	st	-X, r24
    2cc0:	16 97       	sbiw	r26, 0x06	; 6

        p->lowspeed = lowspeed;
    2cc2:	1a 96       	adiw	r26, 0x0a	; 10
    2cc4:	2c 93       	st	X, r18
        // Get device descriptor
        rcode = getDevDescr(0, 0, sizeof (USB_DEVICE_DESCRIPTOR), (uint8_t*)buf);
    2cc6:	8e 01       	movw	r16, r28
    2cc8:	0f 5f       	subi	r16, 0xFF	; 255
    2cca:	1f 4f       	sbci	r17, 0xFF	; 255
    2ccc:	22 e1       	ldi	r18, 0x12	; 18
    2cce:	30 e0       	ldi	r19, 0x00	; 0
    2cd0:	40 e0       	ldi	r20, 0x00	; 0
    2cd2:	60 e0       	ldi	r22, 0x00	; 0
    2cd4:	c7 01       	movw	r24, r14
    2cd6:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <_ZN3USB11getDevDescrEhhjPh>

        // Restore p->epinfo
        p->epinfo = oldep_ptr;
    2cda:	f7 01       	movw	r30, r14
    2cdc:	d7 82       	std	Z+7, r13	; 0x07
    2cde:	c6 82       	std	Z+6, r12	; 0x06

        if(rcode) {
    2ce0:	81 11       	cpse	r24, r1
    2ce2:	a6 c0       	rjmp	.+332    	; 0x2e30 <_ZN3USB11ConfiguringEhhb+0x1d4>

        // to-do?
        // Allocate new address according to device class
        //bAddress = addrPool.AllocAddress(parent, false, port);

        uint16_t vid = udd->idVendor;
    2ce4:	89 84       	ldd	r8, Y+9	; 0x09
    2ce6:	9a 84       	ldd	r9, Y+10	; 0x0a
        uint16_t pid = udd->idProduct;
    2ce8:	6b 84       	ldd	r6, Y+11	; 0x0b
    2cea:	7c 84       	ldd	r7, Y+12	; 0x0c
        uint8_t klass = udd->bDeviceClass;
    2cec:	fd 81       	ldd	r31, Y+5	; 0x05
    2cee:	fe 8b       	std	Y+22, r31	; 0x16
        uint8_t subklass = udd->bDeviceSubClass;
    2cf0:	2e 80       	ldd	r2, Y+6	; 0x06
    2cf2:	67 01       	movw	r12, r14
    2cf4:	36 e5       	ldi	r19, 0x56	; 86
    2cf6:	c3 0e       	add	r12, r19
    2cf8:	d1 1c       	adc	r13, r1
    2cfa:	56 01       	movw	r10, r12
        // Qualify with subclass too.
        //
        // VID/PID & class tests default to false for drivers not yet ported
        // subclass defaults to true, so you don't have to define it if you don't have to.
        //
        for(devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
    2cfc:	10 e0       	ldi	r17, 0x00	; 0
                if(!devConfig[devConfigIndex]) continue; // no driver
    2cfe:	d5 01       	movw	r26, r10
    2d00:	8d 91       	ld	r24, X+
    2d02:	9c 91       	ld	r25, X
    2d04:	00 97       	sbiw	r24, 0x00	; 0
    2d06:	f1 f1       	breq	.+124    	; 0x2d84 <_ZN3USB11ConfiguringEhhb+0x128>
                if(devConfig[devConfigIndex]->GetAddress()) continue; // consumed
    2d08:	dc 01       	movw	r26, r24
    2d0a:	ed 91       	ld	r30, X+
    2d0c:	fc 91       	ld	r31, X
    2d0e:	00 84       	ldd	r0, Z+8	; 0x08
    2d10:	f1 85       	ldd	r31, Z+9	; 0x09
    2d12:	e0 2d       	mov	r30, r0
    2d14:	09 95       	icall
    2d16:	81 11       	cpse	r24, r1
    2d18:	35 c0       	rjmp	.+106    	; 0x2d84 <_ZN3USB11ConfiguringEhhb+0x128>
                if(devConfig[devConfigIndex]->DEVSUBCLASSOK(subklass) && (devConfig[devConfigIndex]->VIDPIDOK(vid, pid) || devConfig[devConfigIndex]->DEVCLASSOK(klass))) {
    2d1a:	f5 01       	movw	r30, r10
    2d1c:	80 81       	ld	r24, Z
    2d1e:	91 81       	ldd	r25, Z+1	; 0x01
    2d20:	dc 01       	movw	r26, r24
    2d22:	ed 91       	ld	r30, X+
    2d24:	fc 91       	ld	r31, X
    2d26:	00 88       	ldd	r0, Z+16	; 0x10
    2d28:	f1 89       	ldd	r31, Z+17	; 0x11
    2d2a:	e0 2d       	mov	r30, r0
    2d2c:	62 2d       	mov	r22, r2
    2d2e:	09 95       	icall
    2d30:	88 23       	and	r24, r24
    2d32:	41 f1       	breq	.+80     	; 0x2d84 <_ZN3USB11ConfiguringEhhb+0x128>
    2d34:	f5 01       	movw	r30, r10
    2d36:	80 81       	ld	r24, Z
    2d38:	91 81       	ldd	r25, Z+1	; 0x01
    2d3a:	dc 01       	movw	r26, r24
    2d3c:	ed 91       	ld	r30, X+
    2d3e:	fc 91       	ld	r31, X
    2d40:	04 84       	ldd	r0, Z+12	; 0x0c
    2d42:	f5 85       	ldd	r31, Z+13	; 0x0d
    2d44:	e0 2d       	mov	r30, r0
    2d46:	a3 01       	movw	r20, r6
    2d48:	b4 01       	movw	r22, r8
    2d4a:	09 95       	icall
    2d4c:	81 11       	cpse	r24, r1
    2d4e:	10 c0       	rjmp	.+32     	; 0x2d70 <_ZN3USB11ConfiguringEhhb+0x114>
    2d50:	f5 01       	movw	r30, r10
    2d52:	80 81       	ld	r24, Z
    2d54:	91 81       	ldd	r25, Z+1	; 0x01
    2d56:	dc 01       	movw	r26, r24
    2d58:	ed 91       	ld	r30, X+
    2d5a:	fc 91       	ld	r31, X
    2d5c:	06 84       	ldd	r0, Z+14	; 0x0e
    2d5e:	f7 85       	ldd	r31, Z+15	; 0x0f
    2d60:	e0 2d       	mov	r30, r0
    2d62:	6e 89       	ldd	r22, Y+22	; 0x16
    2d64:	09 95       	icall
    2d66:	81 11       	cpse	r24, r1
    2d68:	03 c0       	rjmp	.+6      	; 0x2d70 <_ZN3USB11ConfiguringEhhb+0x114>
    2d6a:	0c c0       	rjmp	.+24     	; 0x2d84 <_ZN3USB11ConfiguringEhhb+0x128>
        AddressPool &addrPool = GetAddressPool();
        // Get pointer to pseudo device with address 0 assigned
        p = addrPool.GetUsbDevicePtr(0);
        if(!p) {
                //printf("Configuring error: USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL\r\n");
                return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
    2d6c:	86 ed       	ldi	r24, 0xD6	; 214
    2d6e:	60 c0       	rjmp	.+192    	; 0x2e30 <_ZN3USB11ConfiguringEhhb+0x1d4>
        //
        for(devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
                if(!devConfig[devConfigIndex]) continue; // no driver
                if(devConfig[devConfigIndex]->GetAddress()) continue; // consumed
                if(devConfig[devConfigIndex]->DEVSUBCLASSOK(subklass) && (devConfig[devConfigIndex]->VIDPIDOK(vid, pid) || devConfig[devConfigIndex]->DEVCLASSOK(klass))) {
                        rcode = AttemptConfig(devConfigIndex, parent, port, lowspeed);
    2d70:	05 2d       	mov	r16, r5
    2d72:	23 2d       	mov	r18, r3
    2d74:	44 2d       	mov	r20, r4
    2d76:	61 2f       	mov	r22, r17
    2d78:	c7 01       	movw	r24, r14
    2d7a:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <_ZN3USB13AttemptConfigEhhhb>
                        if(rcode != USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED)
    2d7e:	81 3d       	cpi	r24, 0xD1	; 209
    2d80:	09 f0       	breq	.+2      	; 0x2d84 <_ZN3USB11ConfiguringEhhb+0x128>
    2d82:	56 c0       	rjmp	.+172    	; 0x2e30 <_ZN3USB11ConfiguringEhhb+0x1d4>
        // Qualify with subclass too.
        //
        // VID/PID & class tests default to false for drivers not yet ported
        // subclass defaults to true, so you don't have to define it if you don't have to.
        //
        for(devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
    2d84:	1f 5f       	subi	r17, 0xFF	; 255
    2d86:	b2 e0       	ldi	r27, 0x02	; 2
    2d88:	ab 0e       	add	r10, r27
    2d8a:	b1 1c       	adc	r11, r1
    2d8c:	10 31       	cpi	r17, 0x10	; 16
    2d8e:	09 f0       	breq	.+2      	; 0x2d92 <_ZN3USB11ConfiguringEhhb+0x136>
    2d90:	b6 cf       	rjmp	.-148    	; 0x2cfe <_ZN3USB11ConfiguringEhhb+0xa2>
    2d92:	10 e0       	ldi	r17, 0x00	; 0
        }


        // blindly attempt to configure
        for(devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
                if(!devConfig[devConfigIndex]) continue;
    2d94:	f6 01       	movw	r30, r12
    2d96:	80 81       	ld	r24, Z
    2d98:	91 81       	ldd	r25, Z+1	; 0x01
    2d9a:	00 97       	sbiw	r24, 0x00	; 0
    2d9c:	e1 f1       	breq	.+120    	; 0x2e16 <_ZN3USB11ConfiguringEhhb+0x1ba>
                if(devConfig[devConfigIndex]->GetAddress()) continue; // consumed
    2d9e:	dc 01       	movw	r26, r24
    2da0:	ed 91       	ld	r30, X+
    2da2:	fc 91       	ld	r31, X
    2da4:	00 84       	ldd	r0, Z+8	; 0x08
    2da6:	f1 85       	ldd	r31, Z+9	; 0x09
    2da8:	e0 2d       	mov	r30, r0
    2daa:	09 95       	icall
    2dac:	81 11       	cpse	r24, r1
    2dae:	33 c0       	rjmp	.+102    	; 0x2e16 <_ZN3USB11ConfiguringEhhb+0x1ba>
                if(devConfig[devConfigIndex]->DEVSUBCLASSOK(subklass) && (devConfig[devConfigIndex]->VIDPIDOK(vid, pid) || devConfig[devConfigIndex]->DEVCLASSOK(klass))) continue; // If this is true it means it must have returned USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED above
    2db0:	f6 01       	movw	r30, r12
    2db2:	80 81       	ld	r24, Z
    2db4:	91 81       	ldd	r25, Z+1	; 0x01
    2db6:	dc 01       	movw	r26, r24
    2db8:	ed 91       	ld	r30, X+
    2dba:	fc 91       	ld	r31, X
    2dbc:	00 88       	ldd	r0, Z+16	; 0x10
    2dbe:	f1 89       	ldd	r31, Z+17	; 0x11
    2dc0:	e0 2d       	mov	r30, r0
    2dc2:	62 2d       	mov	r22, r2
    2dc4:	09 95       	icall
    2dc6:	88 23       	and	r24, r24
    2dc8:	d9 f0       	breq	.+54     	; 0x2e00 <_ZN3USB11ConfiguringEhhb+0x1a4>
    2dca:	f6 01       	movw	r30, r12
    2dcc:	80 81       	ld	r24, Z
    2dce:	91 81       	ldd	r25, Z+1	; 0x01
    2dd0:	dc 01       	movw	r26, r24
    2dd2:	ed 91       	ld	r30, X+
    2dd4:	fc 91       	ld	r31, X
    2dd6:	04 84       	ldd	r0, Z+12	; 0x0c
    2dd8:	f5 85       	ldd	r31, Z+13	; 0x0d
    2dda:	e0 2d       	mov	r30, r0
    2ddc:	a3 01       	movw	r20, r6
    2dde:	b4 01       	movw	r22, r8
    2de0:	09 95       	icall
    2de2:	81 11       	cpse	r24, r1
    2de4:	18 c0       	rjmp	.+48     	; 0x2e16 <_ZN3USB11ConfiguringEhhb+0x1ba>
    2de6:	f6 01       	movw	r30, r12
    2de8:	80 81       	ld	r24, Z
    2dea:	91 81       	ldd	r25, Z+1	; 0x01
    2dec:	dc 01       	movw	r26, r24
    2dee:	ed 91       	ld	r30, X+
    2df0:	fc 91       	ld	r31, X
    2df2:	06 84       	ldd	r0, Z+14	; 0x0e
    2df4:	f7 85       	ldd	r31, Z+15	; 0x0f
    2df6:	e0 2d       	mov	r30, r0
    2df8:	6e 89       	ldd	r22, Y+22	; 0x16
    2dfa:	09 95       	icall
    2dfc:	81 11       	cpse	r24, r1
    2dfe:	0b c0       	rjmp	.+22     	; 0x2e16 <_ZN3USB11ConfiguringEhhb+0x1ba>
                rcode = AttemptConfig(devConfigIndex, parent, port, lowspeed);
    2e00:	05 2d       	mov	r16, r5
    2e02:	23 2d       	mov	r18, r3
    2e04:	44 2d       	mov	r20, r4
    2e06:	61 2f       	mov	r22, r17
    2e08:	c7 01       	movw	r24, r14
    2e0a:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <_ZN3USB13AttemptConfigEhhhb>

                //printf("ERROR ENUMERATING %2.2x\r\n", rcode);
                if(!(rcode == USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED || rcode == USB_ERROR_CLASS_INSTANCE_ALREADY_IN_USE)) {
    2e0e:	98 2f       	mov	r25, r24
    2e10:	97 7f       	andi	r25, 0xF7	; 247
    2e12:	91 3d       	cpi	r25, 0xD1	; 209
    2e14:	69 f4       	brne	.+26     	; 0x2e30 <_ZN3USB11ConfiguringEhhb+0x1d4>
                return rcode;
        }


        // blindly attempt to configure
        for(devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
    2e16:	1f 5f       	subi	r17, 0xFF	; 255
    2e18:	e2 e0       	ldi	r30, 0x02	; 2
    2e1a:	ce 0e       	add	r12, r30
    2e1c:	d1 1c       	adc	r13, r1
    2e1e:	10 31       	cpi	r17, 0x10	; 16
    2e20:	09 f0       	breq	.+2      	; 0x2e24 <_ZN3USB11ConfiguringEhhb+0x1c8>
    2e22:	b8 cf       	rjmp	.-144    	; 0x2d94 <_ZN3USB11ConfiguringEhhb+0x138>
                        //        devConfigIndex = 0;
                        return rcode;
                }
        }
        // if we get here that means that the device class is not supported by any of registered classes
        rcode = DefaultAddressing(parent, port, lowspeed);
    2e24:	25 2d       	mov	r18, r5
    2e26:	43 2d       	mov	r20, r3
    2e28:	64 2d       	mov	r22, r4
    2e2a:	c7 01       	movw	r24, r14
    2e2c:	0e 94 f2 15 	call	0x2be4	; 0x2be4 <_ZN3USB17DefaultAddressingEhhb>

        return rcode;
}
    2e30:	66 96       	adiw	r28, 0x16	; 22
    2e32:	0f b6       	in	r0, 0x3f	; 63
    2e34:	f8 94       	cli
    2e36:	de bf       	out	0x3e, r29	; 62
    2e38:	0f be       	out	0x3f, r0	; 63
    2e3a:	cd bf       	out	0x3d, r28	; 61
    2e3c:	df 91       	pop	r29
    2e3e:	cf 91       	pop	r28
    2e40:	1f 91       	pop	r17
    2e42:	0f 91       	pop	r16
    2e44:	ff 90       	pop	r15
    2e46:	ef 90       	pop	r14
    2e48:	df 90       	pop	r13
    2e4a:	cf 90       	pop	r12
    2e4c:	bf 90       	pop	r11
    2e4e:	af 90       	pop	r10
    2e50:	9f 90       	pop	r9
    2e52:	8f 90       	pop	r8
    2e54:	7f 90       	pop	r7
    2e56:	6f 90       	pop	r6
    2e58:	5f 90       	pop	r5
    2e5a:	4f 90       	pop	r4
    2e5c:	3f 90       	pop	r3
    2e5e:	2f 90       	pop	r2
    2e60:	08 95       	ret

00002e62 <_ZN3USB7setConfEhhh>:
        return rcode;
        //return ( ctrlReq(oldaddr, ep, bmREQ_SET, USB_REQUEST_SET_ADDRESS, newaddr, 0x00, 0x0000, 0x0000, 0x0000, NULL, NULL));
}
//set configuration

uint8_t USB::setConf(uint8_t addr, uint8_t ep, uint8_t conf_value) {
    2e62:	8f 92       	push	r8
    2e64:	9f 92       	push	r9
    2e66:	af 92       	push	r10
    2e68:	bf 92       	push	r11
    2e6a:	cf 92       	push	r12
    2e6c:	ef 92       	push	r14
    2e6e:	0f 93       	push	r16
        return ( ctrlReq(addr, ep, bmREQ_SET, USB_REQUEST_SET_CONFIGURATION, conf_value, 0x00, 0x0000, 0x0000, 0x0000, NULL, NULL));
    2e70:	1f 92       	push	r1
    2e72:	1f 92       	push	r1
    2e74:	1f 92       	push	r1
    2e76:	1f 92       	push	r1
    2e78:	1f 92       	push	r1
    2e7a:	1f 92       	push	r1
    2e7c:	81 2c       	mov	r8, r1
    2e7e:	91 2c       	mov	r9, r1
    2e80:	a1 2c       	mov	r10, r1
    2e82:	b1 2c       	mov	r11, r1
    2e84:	c1 2c       	mov	r12, r1
    2e86:	e2 2e       	mov	r14, r18
    2e88:	09 e0       	ldi	r16, 0x09	; 9
    2e8a:	20 e0       	ldi	r18, 0x00	; 0
    2e8c:	0e 94 bc 14 	call	0x2978	; 0x2978 <_ZN3USB7ctrlReqEhhhhhhjjjPhP13USBReadParser>
    2e90:	0f 90       	pop	r0
    2e92:	0f 90       	pop	r0
    2e94:	0f 90       	pop	r0
    2e96:	0f 90       	pop	r0
    2e98:	0f 90       	pop	r0
    2e9a:	0f 90       	pop	r0
}
    2e9c:	0f 91       	pop	r16
    2e9e:	ef 90       	pop	r14
    2ea0:	cf 90       	pop	r12
    2ea2:	bf 90       	pop	r11
    2ea4:	af 90       	pop	r10
    2ea6:	9f 90       	pop	r9
    2ea8:	8f 90       	pop	r8
    2eaa:	08 95       	ret

00002eac <_ZN3USB10inTransferEhhPjPhh>:
/* IN transfer to arbitrary endpoint. Assumes PERADDR is set. Handles multiple packets if necessary. Transfers 'nbytes' bytes. */
/* Keep sending INs and writes data to memory area pointed by 'data'                                                           */

/* rcode 0 if no errors. rcode 01-0f is relayed from dispatchPkt(). Rcode f0 means RCVDAVIRQ error,
            fe USB xfer timeout */
uint8_t USB::inTransfer(uint8_t addr, uint8_t ep, uint16_t *nbytesptr, uint8_t* data, uint8_t bInterval /*= 0*/) {
    2eac:	8f 92       	push	r8
    2eae:	9f 92       	push	r9
    2eb0:	af 92       	push	r10
    2eb2:	bf 92       	push	r11
    2eb4:	cf 92       	push	r12
    2eb6:	df 92       	push	r13
    2eb8:	ef 92       	push	r14
    2eba:	0f 93       	push	r16
    2ebc:	1f 93       	push	r17
    2ebe:	cf 93       	push	r28
    2ec0:	df 93       	push	r29
    2ec2:	00 d0       	rcall	.+0      	; 0x2ec4 <_ZN3USB10inTransferEhhPjPhh+0x18>
    2ec4:	00 d0       	rcall	.+0      	; 0x2ec6 <_ZN3USB10inTransferEhhPjPhh+0x1a>
    2ec6:	cd b7       	in	r28, 0x3d	; 61
    2ec8:	de b7       	in	r29, 0x3e	; 62
    2eca:	6c 01       	movw	r12, r24
    2ecc:	59 01       	movw	r10, r18
    2ece:	48 01       	movw	r8, r16
        EpInfo *pep = NULL;
    2ed0:	1c 82       	std	Y+4, r1	; 0x04
    2ed2:	1b 82       	std	Y+3, r1	; 0x03
        uint16_t nak_limit = 0;
    2ed4:	1a 82       	std	Y+2, r1	; 0x02
    2ed6:	19 82       	std	Y+1, r1	; 0x01

        uint8_t rcode = SetAddress(addr, ep, &pep, &nak_limit);
    2ed8:	8e 01       	movw	r16, r28
    2eda:	0f 5f       	subi	r16, 0xFF	; 255
    2edc:	1f 4f       	sbci	r17, 0xFF	; 255
    2ede:	9e 01       	movw	r18, r28
    2ee0:	2d 5f       	subi	r18, 0xFD	; 253
    2ee2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ee4:	0e 94 1a 11 	call	0x2234	; 0x2234 <_ZN3USB10SetAddressEhhPP6EpInfoPj>

        if(rcode) {
    2ee8:	81 11       	cpse	r24, r1
    2eea:	09 c0       	rjmp	.+18     	; 0x2efe <_ZN3USB10inTransferEhhPjPhh+0x52>
                USBTRACE3("(USB::InTransfer) SetAddress Failed ", rcode, 0x81);
                USBTRACE3("(USB::InTransfer) addr requested ", addr, 0x81);
                USBTRACE3("(USB::InTransfer) ep requested ", ep, 0x81);
                return rcode;
        }
        return InTransfer(pep, nak_limit, nbytesptr, data, bInterval);
    2eec:	49 81       	ldd	r20, Y+1	; 0x01
    2eee:	5a 81       	ldd	r21, Y+2	; 0x02
    2ef0:	6b 81       	ldd	r22, Y+3	; 0x03
    2ef2:	7c 81       	ldd	r23, Y+4	; 0x04
    2ef4:	84 01       	movw	r16, r8
    2ef6:	95 01       	movw	r18, r10
    2ef8:	c6 01       	movw	r24, r12
    2efa:	0e 94 d5 13 	call	0x27aa	; 0x27aa <_ZN3USB10InTransferEP6EpInfojPjPhh>
}
    2efe:	0f 90       	pop	r0
    2f00:	0f 90       	pop	r0
    2f02:	0f 90       	pop	r0
    2f04:	0f 90       	pop	r0
    2f06:	df 91       	pop	r29
    2f08:	cf 91       	pop	r28
    2f0a:	1f 91       	pop	r17
    2f0c:	0f 91       	pop	r16
    2f0e:	ef 90       	pop	r14
    2f10:	df 90       	pop	r13
    2f12:	cf 90       	pop	r12
    2f14:	bf 90       	pop	r11
    2f16:	af 90       	pop	r10
    2f18:	9f 90       	pop	r9
    2f1a:	8f 90       	pop	r8
    2f1c:	08 95       	ret

00002f1e <_ZN3USB4TaskEv>:
        return ( rcode);
}

/* USB main task. Performs enumeration/cleanup */
void USB::Task(void) //USB state machine
{
    2f1e:	af 92       	push	r10
    2f20:	bf 92       	push	r11
    2f22:	cf 92       	push	r12
    2f24:	df 92       	push	r13
    2f26:	ef 92       	push	r14
    2f28:	ff 92       	push	r15
    2f2a:	0f 93       	push	r16
    2f2c:	1f 93       	push	r17
    2f2e:	cf 93       	push	r28
    2f30:	8c 01       	movw	r16, r24
        uint8_t pinvalue;
        //USB_HOST_SERIAL.print("Vbus state: ");
        //USB_HOST_SERIAL.println( vbusState, HEX );
        pinvalue = INTR::IsSet(); //Read();
        //pinvalue = digitalRead( MAX_INT );
        if(pinvalue == 0) {
    2f32:	19 99       	sbic	0x03, 1	; 3
    2f34:	0e c0       	rjmp	.+28     	; 0x2f52 <_ZN3USB4TaskEv+0x34>

template< typename SPI_SS, typename INTR >
uint8_t MAX3421e< SPI_SS, INTR >::IntHandler() {
        uint8_t HIRQ;
        uint8_t HIRQ_sendback = 0x00;
        HIRQ = regRd(rHIRQ); //determine interrupt source
    2f36:	88 ec       	ldi	r24, 0xC8	; 200
    2f38:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
        //if( HIRQ & bmFRAMEIRQ ) {               //->1ms SOF interrupt handler
        //    HIRQ_sendback |= bmFRAMEIRQ;
        //}//end FRAMEIRQ handling
        if(HIRQ & bmCONDETIRQ) {
    2f3c:	85 ff       	sbrs	r24, 5
    2f3e:	05 c0       	rjmp	.+10     	; 0x2f4a <_ZN3USB4TaskEv+0x2c>
                busprobe();
    2f40:	c8 01       	movw	r24, r16
    2f42:	0e 94 2b 03 	call	0x656	; 0x656 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE8busprobeEv>
                HIRQ_sendback |= bmCONDETIRQ;
    2f46:	60 e2       	ldi	r22, 0x20	; 32
    2f48:	01 c0       	rjmp	.+2      	; 0x2f4c <_ZN3USB4TaskEv+0x2e>
}

template< typename SPI_SS, typename INTR >
uint8_t MAX3421e< SPI_SS, INTR >::IntHandler() {
        uint8_t HIRQ;
        uint8_t HIRQ_sendback = 0x00;
    2f4a:	60 e0       	ldi	r22, 0x00	; 0
        if(HIRQ & bmCONDETIRQ) {
                busprobe();
                HIRQ_sendback |= bmCONDETIRQ;
        }
        /* End HIRQ interrupts handling, clear serviced IRQs    */
        regWr(rHIRQ, HIRQ_sendback);
    2f4c:	88 ec       	ldi	r24, 0xC8	; 200
    2f4e:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
        MAX3421E::Task();

        tmpdata = getVbusState();

        /* modify USB task state if Vbus changed */
        switch(tmpdata) {
    2f52:	80 91 46 04 	lds	r24, 0x0446	; 0x800446 <__data_end>
    2f56:	81 30       	cpi	r24, 0x01	; 1
    2f58:	39 f0       	breq	.+14     	; 0x2f68 <_ZN3USB4TaskEv+0x4a>
    2f5a:	40 f0       	brcs	.+16     	; 0x2f6c <_ZN3USB4TaskEv+0x4e>
    2f5c:	82 30       	cpi	r24, 0x02	; 2
    2f5e:	79 f0       	breq	.+30     	; 0x2f7e <_ZN3USB4TaskEv+0x60>
    2f60:	83 30       	cpi	r24, 0x03	; 3
    2f62:	39 f5       	brne	.+78     	; 0x2fb2 <_ZN3USB4TaskEv+0x94>
                                usb_task_state = USB_DETACHED_SUBSTATE_INITIALIZE;
                        lowspeed = false;
                        break;
                case LSHOST:

                        lowspeed = true;
    2f64:	c1 e0       	ldi	r28, 0x01	; 1
    2f66:	0c c0       	rjmp	.+24     	; 0x2f80 <_ZN3USB4TaskEv+0x62>
        tmpdata = getVbusState();

        /* modify USB task state if Vbus changed */
        switch(tmpdata) {
                case SE1: //illegal state
                        usb_task_state = USB_DETACHED_SUBSTATE_ILLEGAL;
    2f68:	83 e1       	ldi	r24, 0x13	; 19
    2f6a:	06 c0       	rjmp	.+12     	; 0x2f78 <_ZN3USB4TaskEv+0x5a>
                        lowspeed = false;
                        break;
                case SE0: //disconnected
                        if((usb_task_state & USB_STATE_MASK) != USB_STATE_DETACHED)
    2f6c:	80 91 31 06 	lds	r24, 0x0631	; 0x800631 <_ZL14usb_task_state>
    2f70:	80 7f       	andi	r24, 0xF0	; 240
    2f72:	80 31       	cpi	r24, 0x10	; 16
    2f74:	f1 f0       	breq	.+60     	; 0x2fb2 <_ZN3USB4TaskEv+0x94>
                                usb_task_state = USB_DETACHED_SUBSTATE_INITIALIZE;
    2f76:	81 e1       	ldi	r24, 0x11	; 17
    2f78:	80 93 31 06 	sts	0x0631, r24	; 0x800631 <_ZL14usb_task_state>
    2f7c:	1a c0       	rjmp	.+52     	; 0x2fb2 <_ZN3USB4TaskEv+0x94>
{
        uint8_t rcode;
        uint8_t tmpdata;
        static uint32_t delay = 0;
        //USB_DEVICE_DESCRIPTOR buf;
        bool lowspeed = false;
    2f7e:	c0 e0       	ldi	r28, 0x00	; 0
                case LSHOST:

                        lowspeed = true;
                        //intentional fallthrough
                case FSHOST: //attached
                        if((usb_task_state & USB_STATE_MASK) == USB_STATE_DETACHED) {
    2f80:	80 91 31 06 	lds	r24, 0x0631	; 0x800631 <_ZL14usb_task_state>
    2f84:	80 7f       	andi	r24, 0xF0	; 240
    2f86:	80 31       	cpi	r24, 0x10	; 16
    2f88:	a9 f4       	brne	.+42     	; 0x2fb4 <_ZN3USB4TaskEv+0x96>
                                delay = (uint32_t)millis() + USB_SETTLE_DELAY;
    2f8a:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    2f8e:	dc 01       	movw	r26, r24
    2f90:	cb 01       	movw	r24, r22
    2f92:	88 53       	subi	r24, 0x38	; 56
    2f94:	9f 4f       	sbci	r25, 0xFF	; 255
    2f96:	af 4f       	sbci	r26, 0xFF	; 255
    2f98:	bf 4f       	sbci	r27, 0xFF	; 255
    2f9a:	80 93 2d 06 	sts	0x062D, r24	; 0x80062d <_ZZN3USB4TaskEvE5delay>
    2f9e:	90 93 2e 06 	sts	0x062E, r25	; 0x80062e <_ZZN3USB4TaskEvE5delay+0x1>
    2fa2:	a0 93 2f 06 	sts	0x062F, r26	; 0x80062f <_ZZN3USB4TaskEvE5delay+0x2>
    2fa6:	b0 93 30 06 	sts	0x0630, r27	; 0x800630 <_ZZN3USB4TaskEvE5delay+0x3>
                                usb_task_state = USB_ATTACHED_SUBSTATE_SETTLE;
    2faa:	80 e2       	ldi	r24, 0x20	; 32
    2fac:	80 93 31 06 	sts	0x0631, r24	; 0x800631 <_ZL14usb_task_state>
    2fb0:	01 c0       	rjmp	.+2      	; 0x2fb4 <_ZN3USB4TaskEv+0x96>
                        lowspeed = false;
                        break;
                case SE0: //disconnected
                        if((usb_task_state & USB_STATE_MASK) != USB_STATE_DETACHED)
                                usb_task_state = USB_DETACHED_SUBSTATE_INITIALIZE;
                        lowspeed = false;
    2fb2:	c0 e0       	ldi	r28, 0x00	; 0
    2fb4:	78 01       	movw	r14, r16
    2fb6:	86 e5       	ldi	r24, 0x56	; 86
    2fb8:	e8 0e       	add	r14, r24
    2fba:	f1 1c       	adc	r15, r1
    2fbc:	68 01       	movw	r12, r16
    2fbe:	a6 e7       	ldi	r26, 0x76	; 118
    2fc0:	ca 0e       	add	r12, r26
    2fc2:	d1 1c       	adc	r13, r1
    2fc4:	57 01       	movw	r10, r14
                        }
                        break;
        }// switch( tmpdata

        for(uint8_t i = 0; i < USB_NUMDEVICES; i++)
                if(devConfig[i])
    2fc6:	f5 01       	movw	r30, r10
    2fc8:	81 91       	ld	r24, Z+
    2fca:	91 91       	ld	r25, Z+
    2fcc:	5f 01       	movw	r10, r30
    2fce:	00 97       	sbiw	r24, 0x00	; 0
    2fd0:	39 f0       	breq	.+14     	; 0x2fe0 <_ZN3USB4TaskEv+0xc2>
                        rcode = devConfig[i]->Poll();
    2fd2:	dc 01       	movw	r26, r24
    2fd4:	ed 91       	ld	r30, X+
    2fd6:	fc 91       	ld	r31, X
    2fd8:	06 80       	ldd	r0, Z+6	; 0x06
    2fda:	f7 81       	ldd	r31, Z+7	; 0x07
    2fdc:	e0 2d       	mov	r30, r0
    2fde:	09 95       	icall
                                usb_task_state = USB_ATTACHED_SUBSTATE_SETTLE;
                        }
                        break;
        }// switch( tmpdata

        for(uint8_t i = 0; i < USB_NUMDEVICES; i++)
    2fe0:	ac 14       	cp	r10, r12
    2fe2:	bd 04       	cpc	r11, r13
    2fe4:	81 f7       	brne	.-32     	; 0x2fc6 <_ZN3USB4TaskEv+0xa8>
                if(devConfig[i])
                        rcode = devConfig[i]->Poll();

        switch(usb_task_state) {
    2fe6:	80 91 31 06 	lds	r24, 0x0631	; 0x800631 <_ZL14usb_task_state>
    2fea:	80 34       	cpi	r24, 0x40	; 64
    2fec:	09 f4       	brne	.+2      	; 0x2ff0 <_ZN3USB4TaskEv+0xd2>
    2fee:	3f c0       	rjmp	.+126    	; 0x306e <_ZN3USB4TaskEv+0x150>
    2ff0:	50 f4       	brcc	.+20     	; 0x3006 <_ZN3USB4TaskEv+0xe8>
    2ff2:	80 32       	cpi	r24, 0x20	; 32
    2ff4:	21 f1       	breq	.+72     	; 0x303e <_ZN3USB4TaskEv+0x120>
    2ff6:	80 33       	cpi	r24, 0x30	; 48
    2ff8:	a1 f1       	breq	.+104    	; 0x3062 <_ZN3USB4TaskEv+0x144>
    2ffa:	81 31       	cpi	r24, 0x11	; 17
    2ffc:	09 f0       	breq	.+2      	; 0x3000 <_ZN3USB4TaskEv+0xe2>
    2ffe:	82 c0       	rjmp	.+260    	; 0x3104 <_ZN3USB4TaskEv+0x1e6>
}

/* Initialize data structures */
void USB::init() {
        //devConfigIndex = 0;
        bmHubPre = 0;
    3000:	f6 01       	movw	r30, r12
    3002:	10 82       	st	Z, r1
    3004:	0a c0       	rjmp	.+20     	; 0x301a <_ZN3USB4TaskEv+0xfc>

        for(uint8_t i = 0; i < USB_NUMDEVICES; i++)
                if(devConfig[i])
                        rcode = devConfig[i]->Poll();

        switch(usb_task_state) {
    3006:	81 35       	cpi	r24, 0x51	; 81
    3008:	09 f4       	brne	.+2      	; 0x300c <_ZN3USB4TaskEv+0xee>
    300a:	58 c0       	rjmp	.+176    	; 0x30bc <_ZN3USB4TaskEv+0x19e>
    300c:	80 38       	cpi	r24, 0x80	; 128
    300e:	09 f4       	brne	.+2      	; 0x3012 <_ZN3USB4TaskEv+0xf4>
    3010:	6a c0       	rjmp	.+212    	; 0x30e6 <_ZN3USB4TaskEv+0x1c8>
    3012:	80 35       	cpi	r24, 0x50	; 80
    3014:	09 f0       	breq	.+2      	; 0x3018 <_ZN3USB4TaskEv+0xfa>
    3016:	76 c0       	rjmp	.+236    	; 0x3104 <_ZN3USB4TaskEv+0x1e6>
    3018:	39 c0       	rjmp	.+114    	; 0x308c <_ZN3USB4TaskEv+0x16e>
                case USB_DETACHED_SUBSTATE_INITIALIZE:
                        init();

                        for(uint8_t i = 0; i < USB_NUMDEVICES; i++)
                                if(devConfig[i])
    301a:	d7 01       	movw	r26, r14
    301c:	8d 91       	ld	r24, X+
    301e:	9d 91       	ld	r25, X+
    3020:	7d 01       	movw	r14, r26
    3022:	00 97       	sbiw	r24, 0x00	; 0
    3024:	39 f0       	breq	.+14     	; 0x3034 <_ZN3USB4TaskEv+0x116>
                                        rcode = devConfig[i]->Release();
    3026:	dc 01       	movw	r26, r24
    3028:	ed 91       	ld	r30, X+
    302a:	fc 91       	ld	r31, X
    302c:	04 80       	ldd	r0, Z+4	; 0x04
    302e:	f5 81       	ldd	r31, Z+5	; 0x05
    3030:	e0 2d       	mov	r30, r0
    3032:	09 95       	icall

        switch(usb_task_state) {
                case USB_DETACHED_SUBSTATE_INITIALIZE:
                        init();

                        for(uint8_t i = 0; i < USB_NUMDEVICES; i++)
    3034:	ec 14       	cp	r14, r12
    3036:	fd 04       	cpc	r15, r13
    3038:	81 f7       	brne	.-32     	; 0x301a <_ZN3USB4TaskEv+0xfc>
                                if(devConfig[i])
                                        rcode = devConfig[i]->Release();

                        usb_task_state = USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE;
    303a:	82 e1       	ldi	r24, 0x12	; 18
    303c:	61 c0       	rjmp	.+194    	; 0x3100 <_ZN3USB4TaskEv+0x1e2>
                case USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE: //just sit here
                        break;
                case USB_DETACHED_SUBSTATE_ILLEGAL: //just sit here
                        break;
                case USB_ATTACHED_SUBSTATE_SETTLE: //settle time for just attached device
                        if((int32_t)((uint32_t)millis() - delay) >= 0L)
    303e:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    3042:	00 91 2d 06 	lds	r16, 0x062D	; 0x80062d <_ZZN3USB4TaskEvE5delay>
    3046:	10 91 2e 06 	lds	r17, 0x062E	; 0x80062e <_ZZN3USB4TaskEvE5delay+0x1>
    304a:	20 91 2f 06 	lds	r18, 0x062F	; 0x80062f <_ZZN3USB4TaskEvE5delay+0x2>
    304e:	30 91 30 06 	lds	r19, 0x0630	; 0x800630 <_ZZN3USB4TaskEvE5delay+0x3>
    3052:	dc 01       	movw	r26, r24
    3054:	cb 01       	movw	r24, r22
    3056:	80 1b       	sub	r24, r16
    3058:	91 0b       	sbc	r25, r17
    305a:	a2 0b       	sbc	r26, r18
    305c:	b3 0b       	sbc	r27, r19
    305e:	b7 fd       	sbrc	r27, 7
    3060:	51 c0       	rjmp	.+162    	; 0x3104 <_ZN3USB4TaskEv+0x1e6>
                                usb_task_state = USB_ATTACHED_SUBSTATE_RESET_DEVICE;
                        else break; // don't fall through
                case USB_ATTACHED_SUBSTATE_RESET_DEVICE:
                        regWr(rHCTL, bmBUSRST); //issue bus reset
    3062:	61 e0       	ldi	r22, 0x01	; 1
    3064:	88 ee       	ldi	r24, 0xE8	; 232
    3066:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
                        usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE;
    306a:	80 e4       	ldi	r24, 0x40	; 64
    306c:	49 c0       	rjmp	.+146    	; 0x3100 <_ZN3USB4TaskEv+0x1e2>
                        break;
                case USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE:
                        if((regRd(rHCTL) & bmBUSRST) == 0) {
    306e:	88 ee       	ldi	r24, 0xE8	; 232
    3070:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    3074:	80 fd       	sbrc	r24, 0
    3076:	46 c0       	rjmp	.+140    	; 0x3104 <_ZN3USB4TaskEv+0x1e6>
                                tmpdata = regRd(rMODE) | bmSOFKAENAB; //start SOF generation
    3078:	88 ed       	ldi	r24, 0xD8	; 216
    307a:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
                                regWr(rMODE, tmpdata);
    307e:	68 2f       	mov	r22, r24
    3080:	68 60       	ori	r22, 0x08	; 8
    3082:	88 ed       	ldi	r24, 0xD8	; 216
    3084:	0e 94 f7 10 	call	0x21ee	; 0x21ee <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regWrEhh.isra.6>
                                usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_SOF;
    3088:	80 e5       	ldi	r24, 0x50	; 80
    308a:	3a c0       	rjmp	.+116    	; 0x3100 <_ZN3USB4TaskEv+0x1e2>
                                //delay = (uint32_t)millis() + 20; //20ms wait after reset per USB spec
                        }
                        break;
                case USB_ATTACHED_SUBSTATE_WAIT_SOF: //todo: change check order
                        if(regRd(rHIRQ) & bmFRAMEIRQ) {
    308c:	88 ec       	ldi	r24, 0xC8	; 200
    308e:	0e 94 e1 10 	call	0x21c2	; 0x21c2 <_ZN8MAX3421eI4TPinI5PortbLh2EES0_IS1_Lh1EEE5regRdEh.isra.5>
    3092:	86 ff       	sbrs	r24, 6
    3094:	37 c0       	rjmp	.+110    	; 0x3104 <_ZN3USB4TaskEv+0x1e6>
                                //when first SOF received _and_ 20ms has passed we can continue
                                /*
                                if (delay < (uint32_t)millis()) //20ms passed
                                        usb_task_state = USB_STATE_CONFIGURING;
                                 */
                                usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_RESET;
    3096:	81 e5       	ldi	r24, 0x51	; 81
    3098:	80 93 31 06 	sts	0x0631, r24	; 0x800631 <_ZL14usb_task_state>
                                delay = (uint32_t)millis() + 20;
    309c:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    30a0:	dc 01       	movw	r26, r24
    30a2:	cb 01       	movw	r24, r22
    30a4:	44 96       	adiw	r24, 0x14	; 20
    30a6:	a1 1d       	adc	r26, r1
    30a8:	b1 1d       	adc	r27, r1
    30aa:	80 93 2d 06 	sts	0x062D, r24	; 0x80062d <_ZZN3USB4TaskEvE5delay>
    30ae:	90 93 2e 06 	sts	0x062E, r25	; 0x80062e <_ZZN3USB4TaskEvE5delay+0x1>
    30b2:	a0 93 2f 06 	sts	0x062F, r26	; 0x80062f <_ZZN3USB4TaskEvE5delay+0x2>
    30b6:	b0 93 30 06 	sts	0x0630, r27	; 0x800630 <_ZZN3USB4TaskEvE5delay+0x3>
    30ba:	24 c0       	rjmp	.+72     	; 0x3104 <_ZN3USB4TaskEv+0x1e6>
                        }
                        break;
                case USB_ATTACHED_SUBSTATE_WAIT_RESET:
                        if((int32_t)((uint32_t)millis() - delay) >= 0L) usb_task_state = USB_STATE_CONFIGURING;
    30bc:	0e 94 ad 06 	call	0xd5a	; 0xd5a <millis>
    30c0:	c0 90 2d 06 	lds	r12, 0x062D	; 0x80062d <_ZZN3USB4TaskEvE5delay>
    30c4:	d0 90 2e 06 	lds	r13, 0x062E	; 0x80062e <_ZZN3USB4TaskEvE5delay+0x1>
    30c8:	e0 90 2f 06 	lds	r14, 0x062F	; 0x80062f <_ZZN3USB4TaskEvE5delay+0x2>
    30cc:	f0 90 30 06 	lds	r15, 0x0630	; 0x800630 <_ZZN3USB4TaskEvE5delay+0x3>
    30d0:	dc 01       	movw	r26, r24
    30d2:	cb 01       	movw	r24, r22
    30d4:	8c 19       	sub	r24, r12
    30d6:	9d 09       	sbc	r25, r13
    30d8:	ae 09       	sbc	r26, r14
    30da:	bf 09       	sbc	r27, r15
    30dc:	b7 fd       	sbrc	r27, 7
    30de:	12 c0       	rjmp	.+36     	; 0x3104 <_ZN3USB4TaskEv+0x1e6>
    30e0:	80 e8       	ldi	r24, 0x80	; 128
    30e2:	80 93 31 06 	sts	0x0631, r24	; 0x800631 <_ZL14usb_task_state>
                case USB_STATE_CONFIGURING:

                        //Serial.print("\r\nConf.LS: ");
                        //Serial.println(lowspeed, HEX);

                        rcode = Configuring(0, 0, lowspeed);
    30e6:	2c 2f       	mov	r18, r28
    30e8:	40 e0       	ldi	r20, 0x00	; 0
    30ea:	60 e0       	ldi	r22, 0x00	; 0
    30ec:	c8 01       	movw	r24, r16
    30ee:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <_ZN3USB11ConfiguringEhhb>

                        if(rcode) {
    30f2:	88 23       	and	r24, r24
    30f4:	21 f0       	breq	.+8      	; 0x30fe <_ZN3USB4TaskEv+0x1e0>
                                if(rcode != USB_DEV_CONFIG_ERROR_DEVICE_INIT_INCOMPLETE) {
    30f6:	82 3d       	cpi	r24, 0xD2	; 210
    30f8:	29 f0       	breq	.+10     	; 0x3104 <_ZN3USB4TaskEv+0x1e6>
                                        usb_error = rcode;
                                        usb_task_state = USB_STATE_ERROR;
    30fa:	80 ea       	ldi	r24, 0xA0	; 160
    30fc:	01 c0       	rjmp	.+2      	; 0x3100 <_ZN3USB4TaskEv+0x1e2>
                                }
                        } else
                                usb_task_state = USB_STATE_RUNNING;
    30fe:	80 e9       	ldi	r24, 0x90	; 144
    3100:	80 93 31 06 	sts	0x0631, r24	; 0x800631 <_ZL14usb_task_state>
                        break;
                case USB_STATE_ERROR:
                        //MAX3421E::Init();
                        break;
        } // switch( usb_task_state )
}
    3104:	cf 91       	pop	r28
    3106:	1f 91       	pop	r17
    3108:	0f 91       	pop	r16
    310a:	ff 90       	pop	r15
    310c:	ef 90       	pop	r14
    310e:	df 90       	pop	r13
    3110:	cf 90       	pop	r12
    3112:	bf 90       	pop	r11
    3114:	af 90       	pop	r10
    3116:	08 95       	ret

00003118 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    3118:	08 95       	ret

0000311a <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    311a:	83 30       	cpi	r24, 0x03	; 3
    311c:	81 f0       	breq	.+32     	; 0x313e <turnOffPWM+0x24>
    311e:	28 f4       	brcc	.+10     	; 0x312a <turnOffPWM+0x10>
    3120:	81 30       	cpi	r24, 0x01	; 1
    3122:	99 f0       	breq	.+38     	; 0x314a <turnOffPWM+0x30>
    3124:	82 30       	cpi	r24, 0x02	; 2
    3126:	a1 f0       	breq	.+40     	; 0x3150 <turnOffPWM+0x36>
    3128:	08 95       	ret
    312a:	87 30       	cpi	r24, 0x07	; 7
    312c:	a9 f0       	breq	.+42     	; 0x3158 <turnOffPWM+0x3e>
    312e:	88 30       	cpi	r24, 0x08	; 8
    3130:	b9 f0       	breq	.+46     	; 0x3160 <turnOffPWM+0x46>
    3132:	84 30       	cpi	r24, 0x04	; 4
    3134:	d1 f4       	brne	.+52     	; 0x316a <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    3136:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    313a:	8f 7d       	andi	r24, 0xDF	; 223
    313c:	03 c0       	rjmp	.+6      	; 0x3144 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    313e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    3142:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    3144:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    3148:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    314a:	84 b5       	in	r24, 0x24	; 36
    314c:	8f 77       	andi	r24, 0x7F	; 127
    314e:	02 c0       	rjmp	.+4      	; 0x3154 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    3150:	84 b5       	in	r24, 0x24	; 36
    3152:	8f 7d       	andi	r24, 0xDF	; 223
    3154:	84 bd       	out	0x24, r24	; 36
    3156:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    3158:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    315c:	8f 77       	andi	r24, 0x7F	; 127
    315e:	03 c0       	rjmp	.+6      	; 0x3166 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    3160:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    3164:	8f 7d       	andi	r24, 0xDF	; 223
    3166:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    316a:	08 95       	ret

0000316c <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    316c:	cf 93       	push	r28
    316e:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    3170:	90 e0       	ldi	r25, 0x00	; 0
    3172:	fc 01       	movw	r30, r24
    3174:	e1 5b       	subi	r30, 0xB1	; 177
    3176:	fe 4f       	sbci	r31, 0xFE	; 254
    3178:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    317a:	fc 01       	movw	r30, r24
    317c:	ed 59       	subi	r30, 0x9D	; 157
    317e:	fe 4f       	sbci	r31, 0xFE	; 254
    3180:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    3182:	88 23       	and	r24, r24
    3184:	61 f1       	breq	.+88     	; 0x31de <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    3186:	90 e0       	ldi	r25, 0x00	; 0
    3188:	88 0f       	add	r24, r24
    318a:	99 1f       	adc	r25, r25
    318c:	fc 01       	movw	r30, r24
    318e:	ef 57       	subi	r30, 0x7F	; 127
    3190:	fe 4f       	sbci	r31, 0xFE	; 254
    3192:	c5 91       	lpm	r28, Z+
    3194:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    3196:	fc 01       	movw	r30, r24
    3198:	e9 58       	subi	r30, 0x89	; 137
    319a:	fe 4f       	sbci	r31, 0xFE	; 254
    319c:	a5 91       	lpm	r26, Z+
    319e:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    31a0:	61 11       	cpse	r22, r1
    31a2:	09 c0       	rjmp	.+18     	; 0x31b6 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    31a4:	9f b7       	in	r25, 0x3f	; 63
                cli();
    31a6:	f8 94       	cli
		*reg &= ~bit;
    31a8:	88 81       	ld	r24, Y
    31aa:	20 95       	com	r18
    31ac:	82 23       	and	r24, r18
    31ae:	88 83       	st	Y, r24
		*out &= ~bit;
    31b0:	ec 91       	ld	r30, X
    31b2:	2e 23       	and	r18, r30
    31b4:	0b c0       	rjmp	.+22     	; 0x31cc <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    31b6:	62 30       	cpi	r22, 0x02	; 2
    31b8:	61 f4       	brne	.+24     	; 0x31d2 <pinMode+0x66>
		uint8_t oldSREG = SREG;
    31ba:	9f b7       	in	r25, 0x3f	; 63
                cli();
    31bc:	f8 94       	cli
		*reg &= ~bit;
    31be:	88 81       	ld	r24, Y
    31c0:	32 2f       	mov	r19, r18
    31c2:	30 95       	com	r19
    31c4:	83 23       	and	r24, r19
    31c6:	88 83       	st	Y, r24
		*out |= bit;
    31c8:	ec 91       	ld	r30, X
    31ca:	2e 2b       	or	r18, r30
    31cc:	2c 93       	st	X, r18
		SREG = oldSREG;
    31ce:	9f bf       	out	0x3f, r25	; 63
    31d0:	06 c0       	rjmp	.+12     	; 0x31de <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    31d2:	8f b7       	in	r24, 0x3f	; 63
                cli();
    31d4:	f8 94       	cli
		*reg |= bit;
    31d6:	e8 81       	ld	r30, Y
    31d8:	2e 2b       	or	r18, r30
    31da:	28 83       	st	Y, r18
		SREG = oldSREG;
    31dc:	8f bf       	out	0x3f, r24	; 63
	}
}
    31de:	df 91       	pop	r29
    31e0:	cf 91       	pop	r28
    31e2:	08 95       	ret

000031e4 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    31e4:	1f 93       	push	r17
    31e6:	cf 93       	push	r28
    31e8:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    31ea:	28 2f       	mov	r18, r24
    31ec:	30 e0       	ldi	r19, 0x00	; 0
    31ee:	f9 01       	movw	r30, r18
    31f0:	e5 5c       	subi	r30, 0xC5	; 197
    31f2:	fe 4f       	sbci	r31, 0xFE	; 254
    31f4:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    31f6:	f9 01       	movw	r30, r18
    31f8:	e1 5b       	subi	r30, 0xB1	; 177
    31fa:	fe 4f       	sbci	r31, 0xFE	; 254
    31fc:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    31fe:	f9 01       	movw	r30, r18
    3200:	ed 59       	subi	r30, 0x9D	; 157
    3202:	fe 4f       	sbci	r31, 0xFE	; 254
    3204:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    3206:	cc 23       	and	r28, r28
    3208:	c1 f0       	breq	.+48     	; 0x323a <digitalWrite+0x56>
    320a:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    320c:	81 11       	cpse	r24, r1
    320e:	0e 94 8d 18 	call	0x311a	; 0x311a <turnOffPWM>

	out = portOutputRegister(port);
    3212:	ec 2f       	mov	r30, r28
    3214:	f0 e0       	ldi	r31, 0x00	; 0
    3216:	ee 0f       	add	r30, r30
    3218:	ff 1f       	adc	r31, r31
    321a:	e9 58       	subi	r30, 0x89	; 137
    321c:	fe 4f       	sbci	r31, 0xFE	; 254
    321e:	a5 91       	lpm	r26, Z+
    3220:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    3222:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3224:	f8 94       	cli

	if (val == LOW) {
    3226:	11 11       	cpse	r17, r1
    3228:	04 c0       	rjmp	.+8      	; 0x3232 <digitalWrite+0x4e>
		*out &= ~bit;
    322a:	8c 91       	ld	r24, X
    322c:	d0 95       	com	r29
    322e:	d8 23       	and	r29, r24
    3230:	02 c0       	rjmp	.+4      	; 0x3236 <digitalWrite+0x52>
	} else {
		*out |= bit;
    3232:	ec 91       	ld	r30, X
    3234:	de 2b       	or	r29, r30
    3236:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    3238:	9f bf       	out	0x3f, r25	; 63
}
    323a:	df 91       	pop	r29
    323c:	cf 91       	pop	r28
    323e:	1f 91       	pop	r17
    3240:	08 95       	ret

00003242 <__udivmodqi4>:
    3242:	99 1b       	sub	r25, r25
    3244:	79 e0       	ldi	r23, 0x09	; 9
    3246:	04 c0       	rjmp	.+8      	; 0x3250 <__udivmodqi4_ep>

00003248 <__udivmodqi4_loop>:
    3248:	99 1f       	adc	r25, r25
    324a:	96 17       	cp	r25, r22
    324c:	08 f0       	brcs	.+2      	; 0x3250 <__udivmodqi4_ep>
    324e:	96 1b       	sub	r25, r22

00003250 <__udivmodqi4_ep>:
    3250:	88 1f       	adc	r24, r24
    3252:	7a 95       	dec	r23
    3254:	c9 f7       	brne	.-14     	; 0x3248 <__udivmodqi4_loop>
    3256:	80 95       	com	r24
    3258:	08 95       	ret

0000325a <__udivmodsi4>:
    325a:	a1 e2       	ldi	r26, 0x21	; 33
    325c:	1a 2e       	mov	r1, r26
    325e:	aa 1b       	sub	r26, r26
    3260:	bb 1b       	sub	r27, r27
    3262:	fd 01       	movw	r30, r26
    3264:	0d c0       	rjmp	.+26     	; 0x3280 <__udivmodsi4_ep>

00003266 <__udivmodsi4_loop>:
    3266:	aa 1f       	adc	r26, r26
    3268:	bb 1f       	adc	r27, r27
    326a:	ee 1f       	adc	r30, r30
    326c:	ff 1f       	adc	r31, r31
    326e:	a2 17       	cp	r26, r18
    3270:	b3 07       	cpc	r27, r19
    3272:	e4 07       	cpc	r30, r20
    3274:	f5 07       	cpc	r31, r21
    3276:	20 f0       	brcs	.+8      	; 0x3280 <__udivmodsi4_ep>
    3278:	a2 1b       	sub	r26, r18
    327a:	b3 0b       	sbc	r27, r19
    327c:	e4 0b       	sbc	r30, r20
    327e:	f5 0b       	sbc	r31, r21

00003280 <__udivmodsi4_ep>:
    3280:	66 1f       	adc	r22, r22
    3282:	77 1f       	adc	r23, r23
    3284:	88 1f       	adc	r24, r24
    3286:	99 1f       	adc	r25, r25
    3288:	1a 94       	dec	r1
    328a:	69 f7       	brne	.-38     	; 0x3266 <__udivmodsi4_loop>
    328c:	60 95       	com	r22
    328e:	70 95       	com	r23
    3290:	80 95       	com	r24
    3292:	90 95       	com	r25
    3294:	9b 01       	movw	r18, r22
    3296:	ac 01       	movw	r20, r24
    3298:	bd 01       	movw	r22, r26
    329a:	cf 01       	movw	r24, r30
    329c:	08 95       	ret

0000329e <__tablejump2__>:
    329e:	ee 0f       	add	r30, r30
    32a0:	ff 1f       	adc	r31, r31
    32a2:	05 90       	lpm	r0, Z+
    32a4:	f4 91       	lpm	r31, Z
    32a6:	e0 2d       	mov	r30, r0
    32a8:	09 94       	ijmp

000032aa <malloc>:
    32aa:	0f 93       	push	r16
    32ac:	1f 93       	push	r17
    32ae:	cf 93       	push	r28
    32b0:	df 93       	push	r29
    32b2:	82 30       	cpi	r24, 0x02	; 2
    32b4:	91 05       	cpc	r25, r1
    32b6:	10 f4       	brcc	.+4      	; 0x32bc <malloc+0x12>
    32b8:	82 e0       	ldi	r24, 0x02	; 2
    32ba:	90 e0       	ldi	r25, 0x00	; 0
    32bc:	e0 91 34 06 	lds	r30, 0x0634	; 0x800634 <__flp>
    32c0:	f0 91 35 06 	lds	r31, 0x0635	; 0x800635 <__flp+0x1>
    32c4:	20 e0       	ldi	r18, 0x00	; 0
    32c6:	30 e0       	ldi	r19, 0x00	; 0
    32c8:	a0 e0       	ldi	r26, 0x00	; 0
    32ca:	b0 e0       	ldi	r27, 0x00	; 0
    32cc:	30 97       	sbiw	r30, 0x00	; 0
    32ce:	19 f1       	breq	.+70     	; 0x3316 <malloc+0x6c>
    32d0:	40 81       	ld	r20, Z
    32d2:	51 81       	ldd	r21, Z+1	; 0x01
    32d4:	02 81       	ldd	r16, Z+2	; 0x02
    32d6:	13 81       	ldd	r17, Z+3	; 0x03
    32d8:	48 17       	cp	r20, r24
    32da:	59 07       	cpc	r21, r25
    32dc:	c8 f0       	brcs	.+50     	; 0x3310 <malloc+0x66>
    32de:	84 17       	cp	r24, r20
    32e0:	95 07       	cpc	r25, r21
    32e2:	69 f4       	brne	.+26     	; 0x32fe <malloc+0x54>
    32e4:	10 97       	sbiw	r26, 0x00	; 0
    32e6:	31 f0       	breq	.+12     	; 0x32f4 <malloc+0x4a>
    32e8:	12 96       	adiw	r26, 0x02	; 2
    32ea:	0c 93       	st	X, r16
    32ec:	12 97       	sbiw	r26, 0x02	; 2
    32ee:	13 96       	adiw	r26, 0x03	; 3
    32f0:	1c 93       	st	X, r17
    32f2:	27 c0       	rjmp	.+78     	; 0x3342 <malloc+0x98>
    32f4:	00 93 34 06 	sts	0x0634, r16	; 0x800634 <__flp>
    32f8:	10 93 35 06 	sts	0x0635, r17	; 0x800635 <__flp+0x1>
    32fc:	22 c0       	rjmp	.+68     	; 0x3342 <malloc+0x98>
    32fe:	21 15       	cp	r18, r1
    3300:	31 05       	cpc	r19, r1
    3302:	19 f0       	breq	.+6      	; 0x330a <malloc+0x60>
    3304:	42 17       	cp	r20, r18
    3306:	53 07       	cpc	r21, r19
    3308:	18 f4       	brcc	.+6      	; 0x3310 <malloc+0x66>
    330a:	9a 01       	movw	r18, r20
    330c:	bd 01       	movw	r22, r26
    330e:	ef 01       	movw	r28, r30
    3310:	df 01       	movw	r26, r30
    3312:	f8 01       	movw	r30, r16
    3314:	db cf       	rjmp	.-74     	; 0x32cc <malloc+0x22>
    3316:	21 15       	cp	r18, r1
    3318:	31 05       	cpc	r19, r1
    331a:	f9 f0       	breq	.+62     	; 0x335a <malloc+0xb0>
    331c:	28 1b       	sub	r18, r24
    331e:	39 0b       	sbc	r19, r25
    3320:	24 30       	cpi	r18, 0x04	; 4
    3322:	31 05       	cpc	r19, r1
    3324:	80 f4       	brcc	.+32     	; 0x3346 <malloc+0x9c>
    3326:	8a 81       	ldd	r24, Y+2	; 0x02
    3328:	9b 81       	ldd	r25, Y+3	; 0x03
    332a:	61 15       	cp	r22, r1
    332c:	71 05       	cpc	r23, r1
    332e:	21 f0       	breq	.+8      	; 0x3338 <malloc+0x8e>
    3330:	fb 01       	movw	r30, r22
    3332:	93 83       	std	Z+3, r25	; 0x03
    3334:	82 83       	std	Z+2, r24	; 0x02
    3336:	04 c0       	rjmp	.+8      	; 0x3340 <malloc+0x96>
    3338:	90 93 35 06 	sts	0x0635, r25	; 0x800635 <__flp+0x1>
    333c:	80 93 34 06 	sts	0x0634, r24	; 0x800634 <__flp>
    3340:	fe 01       	movw	r30, r28
    3342:	32 96       	adiw	r30, 0x02	; 2
    3344:	44 c0       	rjmp	.+136    	; 0x33ce <malloc+0x124>
    3346:	fe 01       	movw	r30, r28
    3348:	e2 0f       	add	r30, r18
    334a:	f3 1f       	adc	r31, r19
    334c:	81 93       	st	Z+, r24
    334e:	91 93       	st	Z+, r25
    3350:	22 50       	subi	r18, 0x02	; 2
    3352:	31 09       	sbc	r19, r1
    3354:	39 83       	std	Y+1, r19	; 0x01
    3356:	28 83       	st	Y, r18
    3358:	3a c0       	rjmp	.+116    	; 0x33ce <malloc+0x124>
    335a:	20 91 32 06 	lds	r18, 0x0632	; 0x800632 <__brkval>
    335e:	30 91 33 06 	lds	r19, 0x0633	; 0x800633 <__brkval+0x1>
    3362:	23 2b       	or	r18, r19
    3364:	41 f4       	brne	.+16     	; 0x3376 <malloc+0xcc>
    3366:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    336a:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    336e:	30 93 33 06 	sts	0x0633, r19	; 0x800633 <__brkval+0x1>
    3372:	20 93 32 06 	sts	0x0632, r18	; 0x800632 <__brkval>
    3376:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    337a:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    337e:	21 15       	cp	r18, r1
    3380:	31 05       	cpc	r19, r1
    3382:	41 f4       	brne	.+16     	; 0x3394 <malloc+0xea>
    3384:	2d b7       	in	r18, 0x3d	; 61
    3386:	3e b7       	in	r19, 0x3e	; 62
    3388:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    338c:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    3390:	24 1b       	sub	r18, r20
    3392:	35 0b       	sbc	r19, r21
    3394:	e0 91 32 06 	lds	r30, 0x0632	; 0x800632 <__brkval>
    3398:	f0 91 33 06 	lds	r31, 0x0633	; 0x800633 <__brkval+0x1>
    339c:	e2 17       	cp	r30, r18
    339e:	f3 07       	cpc	r31, r19
    33a0:	a0 f4       	brcc	.+40     	; 0x33ca <malloc+0x120>
    33a2:	2e 1b       	sub	r18, r30
    33a4:	3f 0b       	sbc	r19, r31
    33a6:	28 17       	cp	r18, r24
    33a8:	39 07       	cpc	r19, r25
    33aa:	78 f0       	brcs	.+30     	; 0x33ca <malloc+0x120>
    33ac:	ac 01       	movw	r20, r24
    33ae:	4e 5f       	subi	r20, 0xFE	; 254
    33b0:	5f 4f       	sbci	r21, 0xFF	; 255
    33b2:	24 17       	cp	r18, r20
    33b4:	35 07       	cpc	r19, r21
    33b6:	48 f0       	brcs	.+18     	; 0x33ca <malloc+0x120>
    33b8:	4e 0f       	add	r20, r30
    33ba:	5f 1f       	adc	r21, r31
    33bc:	50 93 33 06 	sts	0x0633, r21	; 0x800633 <__brkval+0x1>
    33c0:	40 93 32 06 	sts	0x0632, r20	; 0x800632 <__brkval>
    33c4:	81 93       	st	Z+, r24
    33c6:	91 93       	st	Z+, r25
    33c8:	02 c0       	rjmp	.+4      	; 0x33ce <malloc+0x124>
    33ca:	e0 e0       	ldi	r30, 0x00	; 0
    33cc:	f0 e0       	ldi	r31, 0x00	; 0
    33ce:	cf 01       	movw	r24, r30
    33d0:	df 91       	pop	r29
    33d2:	cf 91       	pop	r28
    33d4:	1f 91       	pop	r17
    33d6:	0f 91       	pop	r16
    33d8:	08 95       	ret

000033da <free>:
    33da:	cf 93       	push	r28
    33dc:	df 93       	push	r29
    33de:	00 97       	sbiw	r24, 0x00	; 0
    33e0:	09 f4       	brne	.+2      	; 0x33e4 <free+0xa>
    33e2:	81 c0       	rjmp	.+258    	; 0x34e6 <free+0x10c>
    33e4:	fc 01       	movw	r30, r24
    33e6:	32 97       	sbiw	r30, 0x02	; 2
    33e8:	13 82       	std	Z+3, r1	; 0x03
    33ea:	12 82       	std	Z+2, r1	; 0x02
    33ec:	a0 91 34 06 	lds	r26, 0x0634	; 0x800634 <__flp>
    33f0:	b0 91 35 06 	lds	r27, 0x0635	; 0x800635 <__flp+0x1>
    33f4:	10 97       	sbiw	r26, 0x00	; 0
    33f6:	81 f4       	brne	.+32     	; 0x3418 <free+0x3e>
    33f8:	20 81       	ld	r18, Z
    33fa:	31 81       	ldd	r19, Z+1	; 0x01
    33fc:	82 0f       	add	r24, r18
    33fe:	93 1f       	adc	r25, r19
    3400:	20 91 32 06 	lds	r18, 0x0632	; 0x800632 <__brkval>
    3404:	30 91 33 06 	lds	r19, 0x0633	; 0x800633 <__brkval+0x1>
    3408:	28 17       	cp	r18, r24
    340a:	39 07       	cpc	r19, r25
    340c:	51 f5       	brne	.+84     	; 0x3462 <free+0x88>
    340e:	f0 93 33 06 	sts	0x0633, r31	; 0x800633 <__brkval+0x1>
    3412:	e0 93 32 06 	sts	0x0632, r30	; 0x800632 <__brkval>
    3416:	67 c0       	rjmp	.+206    	; 0x34e6 <free+0x10c>
    3418:	ed 01       	movw	r28, r26
    341a:	20 e0       	ldi	r18, 0x00	; 0
    341c:	30 e0       	ldi	r19, 0x00	; 0
    341e:	ce 17       	cp	r28, r30
    3420:	df 07       	cpc	r29, r31
    3422:	40 f4       	brcc	.+16     	; 0x3434 <free+0x5a>
    3424:	4a 81       	ldd	r20, Y+2	; 0x02
    3426:	5b 81       	ldd	r21, Y+3	; 0x03
    3428:	9e 01       	movw	r18, r28
    342a:	41 15       	cp	r20, r1
    342c:	51 05       	cpc	r21, r1
    342e:	f1 f0       	breq	.+60     	; 0x346c <free+0x92>
    3430:	ea 01       	movw	r28, r20
    3432:	f5 cf       	rjmp	.-22     	; 0x341e <free+0x44>
    3434:	d3 83       	std	Z+3, r29	; 0x03
    3436:	c2 83       	std	Z+2, r28	; 0x02
    3438:	40 81       	ld	r20, Z
    343a:	51 81       	ldd	r21, Z+1	; 0x01
    343c:	84 0f       	add	r24, r20
    343e:	95 1f       	adc	r25, r21
    3440:	c8 17       	cp	r28, r24
    3442:	d9 07       	cpc	r29, r25
    3444:	59 f4       	brne	.+22     	; 0x345c <free+0x82>
    3446:	88 81       	ld	r24, Y
    3448:	99 81       	ldd	r25, Y+1	; 0x01
    344a:	84 0f       	add	r24, r20
    344c:	95 1f       	adc	r25, r21
    344e:	02 96       	adiw	r24, 0x02	; 2
    3450:	91 83       	std	Z+1, r25	; 0x01
    3452:	80 83       	st	Z, r24
    3454:	8a 81       	ldd	r24, Y+2	; 0x02
    3456:	9b 81       	ldd	r25, Y+3	; 0x03
    3458:	93 83       	std	Z+3, r25	; 0x03
    345a:	82 83       	std	Z+2, r24	; 0x02
    345c:	21 15       	cp	r18, r1
    345e:	31 05       	cpc	r19, r1
    3460:	29 f4       	brne	.+10     	; 0x346c <free+0x92>
    3462:	f0 93 35 06 	sts	0x0635, r31	; 0x800635 <__flp+0x1>
    3466:	e0 93 34 06 	sts	0x0634, r30	; 0x800634 <__flp>
    346a:	3d c0       	rjmp	.+122    	; 0x34e6 <free+0x10c>
    346c:	e9 01       	movw	r28, r18
    346e:	fb 83       	std	Y+3, r31	; 0x03
    3470:	ea 83       	std	Y+2, r30	; 0x02
    3472:	49 91       	ld	r20, Y+
    3474:	59 91       	ld	r21, Y+
    3476:	c4 0f       	add	r28, r20
    3478:	d5 1f       	adc	r29, r21
    347a:	ec 17       	cp	r30, r28
    347c:	fd 07       	cpc	r31, r29
    347e:	61 f4       	brne	.+24     	; 0x3498 <free+0xbe>
    3480:	80 81       	ld	r24, Z
    3482:	91 81       	ldd	r25, Z+1	; 0x01
    3484:	84 0f       	add	r24, r20
    3486:	95 1f       	adc	r25, r21
    3488:	02 96       	adiw	r24, 0x02	; 2
    348a:	e9 01       	movw	r28, r18
    348c:	99 83       	std	Y+1, r25	; 0x01
    348e:	88 83       	st	Y, r24
    3490:	82 81       	ldd	r24, Z+2	; 0x02
    3492:	93 81       	ldd	r25, Z+3	; 0x03
    3494:	9b 83       	std	Y+3, r25	; 0x03
    3496:	8a 83       	std	Y+2, r24	; 0x02
    3498:	e0 e0       	ldi	r30, 0x00	; 0
    349a:	f0 e0       	ldi	r31, 0x00	; 0
    349c:	12 96       	adiw	r26, 0x02	; 2
    349e:	8d 91       	ld	r24, X+
    34a0:	9c 91       	ld	r25, X
    34a2:	13 97       	sbiw	r26, 0x03	; 3
    34a4:	00 97       	sbiw	r24, 0x00	; 0
    34a6:	19 f0       	breq	.+6      	; 0x34ae <free+0xd4>
    34a8:	fd 01       	movw	r30, r26
    34aa:	dc 01       	movw	r26, r24
    34ac:	f7 cf       	rjmp	.-18     	; 0x349c <free+0xc2>
    34ae:	8d 91       	ld	r24, X+
    34b0:	9c 91       	ld	r25, X
    34b2:	11 97       	sbiw	r26, 0x01	; 1
    34b4:	9d 01       	movw	r18, r26
    34b6:	2e 5f       	subi	r18, 0xFE	; 254
    34b8:	3f 4f       	sbci	r19, 0xFF	; 255
    34ba:	82 0f       	add	r24, r18
    34bc:	93 1f       	adc	r25, r19
    34be:	20 91 32 06 	lds	r18, 0x0632	; 0x800632 <__brkval>
    34c2:	30 91 33 06 	lds	r19, 0x0633	; 0x800633 <__brkval+0x1>
    34c6:	28 17       	cp	r18, r24
    34c8:	39 07       	cpc	r19, r25
    34ca:	69 f4       	brne	.+26     	; 0x34e6 <free+0x10c>
    34cc:	30 97       	sbiw	r30, 0x00	; 0
    34ce:	29 f4       	brne	.+10     	; 0x34da <free+0x100>
    34d0:	10 92 35 06 	sts	0x0635, r1	; 0x800635 <__flp+0x1>
    34d4:	10 92 34 06 	sts	0x0634, r1	; 0x800634 <__flp>
    34d8:	02 c0       	rjmp	.+4      	; 0x34de <free+0x104>
    34da:	13 82       	std	Z+3, r1	; 0x03
    34dc:	12 82       	std	Z+2, r1	; 0x02
    34de:	b0 93 33 06 	sts	0x0633, r27	; 0x800633 <__brkval+0x1>
    34e2:	a0 93 32 06 	sts	0x0632, r26	; 0x800632 <__brkval>
    34e6:	df 91       	pop	r29
    34e8:	cf 91       	pop	r28
    34ea:	08 95       	ret

000034ec <memset>:
    34ec:	dc 01       	movw	r26, r24
    34ee:	01 c0       	rjmp	.+2      	; 0x34f2 <memset+0x6>
    34f0:	6d 93       	st	X+, r22
    34f2:	41 50       	subi	r20, 0x01	; 1
    34f4:	50 40       	sbci	r21, 0x00	; 0
    34f6:	e0 f7       	brcc	.-8      	; 0x34f0 <memset+0x4>
    34f8:	08 95       	ret

000034fa <_exit>:
    34fa:	f8 94       	cli

000034fc <__stop_program>:
    34fc:	ff cf       	rjmp	.-2      	; 0x34fc <__stop_program>
